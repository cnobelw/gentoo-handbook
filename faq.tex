\renewcommand{\thesection}{\arabic{section}}

\chapter{FAQ}\label{FAQ}

\section{什么是 LiveCD ?}\label{FAQ:LiveCD}
一种让 Linux 系统脱离硬盘，只需要一张 DVD 或者 CD 运行的技术。使用者只需要插入一张 LiveCD 就可以使用 Linux  系统了。当然，由于 CD-ROM 是只读的，所以对 LiveCD 系统本身所做的更改重启后都会消失。由于 Linux 发行版的膨胀，一张 CD-ROM 无法装下，于是就有了 LiveDVD , 除了容量增加外，和LiveCD 是一致的。此外还有 LiveUSB , 也就是使用 USB 存储设备的 liveCD。用法和 LiveCD 并无二致。

\section{如何使用 LiveCD。}\label{FAQ:UseLiveCD}

\section{UEFI和BIOS是什么？}


\section{什么是API?。}\label{FAQ:API}

\section{Shell 是什么？}
操作系统是由内核和一系列的系统程序组成的。

\section{什么是进程和线程？}\label{FAQ:Process}

\section{什么是内存分页？}\label{FAQ:Paging}

\section{如何不重新登录切换到root帐号？}\label{FAQ:su}

\section{内核参数}\label{FAQ：kernelparamter}



\section{Initramfs是什么}　\label{FAQ:initramfs}

Linux启动过程中内核主动做的最后一件事情就是执行/sbin/init，那么倒数第二件事情必然是挂载根目录。
挂载根目录有2个前提条件：找到根分区和支持根分区所使用的文件系统。
找到根分区，第一点，需要其所在设备的驱动。第二点就是内核需要知道哪个是根分区。这个可以通过内核参数 root= 设定。

Linux下驱动可以编译进内核，也可以编译为模块动态加载。如果恰巧磁盘设备的驱动被编译成了模块，就出现“鸡生蛋和蛋生鸡”的问题了：不访问磁盘就无法加载模块，而不加载模块有没有磁盘的驱动。这对于自己编译内核的童鞋不成问题。只要知道自己的SATA/IDE控制器的型号，将对应的驱动编译进内核就解决了。但是如果是打算制作“通用内核”的发行版呢？

文件系统也是同样的问题，没有文件系统驱动就无法挂载分区访问上面的文件，无法访问文件就无法加载模块。这对于自己编译内核的童鞋不成问题。只要将自己根分区所使用的文件系统编译进内核就解决了。但是如果是打算制作“通用内核”的发行版呢？将所有的文件系统都编译进内核么？

initramfs就是为解决这个“鸡生蛋和蛋生鸡”的问题诞生的。

GRUB加载内核的时候通过initrd 命令加载一个initramfs，该initramfs就会成为内核的根分区\footnote{事实上是Linux内核拥有一个不挂载就存在的rootfs文件系统，Linux启动过程中将initramfs的内容解压到rootfs中。作为理解，可以认为initramfs挂载成Linux的临时根目录。}。内核初始化完毕后直接执行initramfs中的/sbin/init而不理会root=命令行参数。由initramfs中的/sbin/init程序负责加载磁盘驱动，查找根分区，挂载根分区到 /sysroot 并调用pivot\_root()\footnote{使用命令　man 2 pivot\_root查看介绍。}将找到的根目录替换为真正的根目录。然后执行真正的/sbin/init程序。

initramfs是一个目录的压缩包。由dracut程序生成。initramfs用于寻找真正的根目录时的临时根目录，通常只包含一些必要的驱动和一些用于查找根分区的脚本，但有时候可以成为一个完成的系统的根目录，这样的系统可以脱离磁盘运行。比如Fedora的安装DVD,使用一个巨大initramfs作为安装环境的根目录。该initramfs包含的是一个真正的OS，带有完整的工具。

