

对命令行是不是有点枯燥了？是时候来点新鲜的东西了 只所以现在才讲，因为图形实在是太复杂了。说Linux图形系统的复杂度已经超过所有其他子系统的总和都不为过。

所有的图形系统，都有一个“指点”设备。图形界面是一种“看得见”的界面，同时需要有种东西能模拟“摸得着”。模拟“摸得着”就需要“指点”设备。通常在桌面型电脑上是鼠标，而在平板电脑上则是触摸屏。“指点”设备告诉计算机，用户“指”的地方和“点”的地方。

除了“指点”设备，传统的键盘也是一个重要的组成部分\footnote{在平板上，键盘被取消了。取而代之使用屏幕键盘和手写输入法}。键盘和指点设备都是用户输入设备。

图形界面下，多个图形程序相互之间共享输入设备和输出设备。输出设备通常就是指的屏幕。

同控制台程序只能接收字符化的用户输入和输出字符串相比，图形程序能输出表意更直观的图像，接收的输入也更为复杂——有鼠标事件，有键盘事件，还有其他图形程序发来的消息，更有系统发送的重绘消息。

由于系统要进行多任务处理，输入和输出设备就不可避免的需要进行共享。完成这个共享的，就是操作系统的窗口系统。

\section{图形、字体和窗口}

窗口是一块有属主并能联接到输入设备的屏幕区域（通常这个也是一块矩形区域）。这块有属主的区域可以为其所有者所控制，接受输入设备的输入并用来输出图形信息。

在操控系统控制的屏幕上有且只有一个窗口能接受键盘输入。接受键盘输入的窗口被称为当前窗口。用户敲击键盘所产生的输入事件被发送给当前窗口，并由该窗口的所有者接受输入事件。

用户可以移动和切换窗口。某个窗口变成当前窗口的操作称为激活。被激活了可以接受到键盘输入的窗口被称为拥有了键盘焦点。
键盘事件总是发送给拥有键盘焦点的窗口。
窗口之间可以相互遮挡，被称为窗口Z轴层级。
拥有焦点的窗口需要处在顶层，所以被激活的窗口总是自动被提升到顶层。
鼠标被移动的时候需要向鼠标经过的窗口发送移动事件。鼠标点击的时候向被点击的鼠标发送点击事件。

从上面的描述可以推测，操作系统的窗口系统的主要任务有：

\begin{enumerate}

\item	提供输入设备的共享。鼠标消息总是发送给鼠标所在的窗口。键盘消息总是发送给拥有键盘焦点的窗口。键盘焦点可以切换。

\item	维护窗口的位置、大小等属性。

\item	管理窗口父子关系。

\item	维护窗口层级。因为运行窗口重叠，层级在前的窗口会覆盖掉层级在后的窗口的内容。

\end{enumerate}

我为什么没有在这里提到窗口绘制呢？严格来说，窗口内容的绘制并不是窗口系统本身的工作，尽管窗口绘制也是图形界面的基础功能之一。窗口内容的绘制，包括文字的渲染，都是被称作为图形渲染系统的工作。
图形渲染系统并不是窗口系统的一部分，而是作为一个基础系统被窗口系统所依赖——窗口系统利用图形渲染系统提供的功能进行窗口绘制。
甚至为了安全，图形渲染系统只能透过窗口系统间接使用\footnote{Linux下可以绕过X直接在屏幕绘图的办法有
/dev/fb*，DirectFB和KMS。}。

图形渲染系统需要提供的功能有：
\begin{enumerate}
\item	提供一个framebuffer。这个framebuffer就是显示器的输出。显示器的内容是由framebuffer直接呈现的。提供framebuffer，意味着可有查询和设定framebuffer的分辨率，
色深，刷新率。

\item	提供绘图API。最基本的API就是bitblt，也就是向framebuffer执行块拷贝操作。其他的一切API都是可选的\footnote{这也就是为何现代X11被用到的渲染API只有XRender（硬件加速的块拷贝操作）一个而已。我们在wayland一节里提到。}。

%\item	提供字体查找和绘制
\item	（可选）提供硬件加速。也就是可有访问GPU，利用GPU加速图形操作。最佳的方式就是提供OpenGL绘图API并使用GPU加速。
\end{enumerate}

正图\ref{fig:guisystem}描述的那样。窗口系统是建立在图形渲染系统基础之上的。
GUI程序使用窗口系统管理窗口，并通过窗口系统获得自己对应的framebuffer区域，然后时候图形渲染系统执行界面渲染向用户呈现图形化的界面。
因为安全性的原因，GUI程序是不能直接使用图形渲染系统，必须通过窗口系统进行授权以获得一块屏幕区域。否则一个程序能向不属于自己的窗口绘制，不是乱套了么？

\chatu{guisystem}{窗口系统}

其他的功能，如“字体渲染”是建立在原有的功能基础之上的。应用程序可以将文字自行绘制为位图然后bitblt到framebuffer，所以字体功能并不是必须的。
但是为了程序间字体的一致性，通常这个可选的功能仍然由图形系统统一提供\footnote{X提供了Xfont核心字体和Xft扩展，用于绘制X内建字体和freetype矢量字体。不过Gtk和Qt都不使用它，而是使用freetype2库自行绘制然后使用XRender绘制到窗口。这样freetype2+fontconfig而不是X提供的基础反而成了Linux下字体渲染的标准。Windows{}和{}Mac OS X{}也都在窗口系统上内建字体支持。}。由图形系统统一提供的好处是系统里只有一套字体管理机制，不容易带来混乱\footnote{在freetyp2和fontconfig接管X的字体功能之前，Linux下的字体管理曾经相当的混乱。安装一个字体需要到X、Xft和fontconfig下分别配置三次。而现在只需要利用fontconfig的自动配置能力即可实现即拷即用——拷贝字体到字体文件夹下即可使用。}。

\chatu{fontsystem}{字体系统}

可以看出的是，操作系统可以不提供字体字体系统，完全不影响。如图中所示，字体选择和光栅化\footnote{显示输出设备通常是像素构成的位图，而高质量的字体则是矢量图形。需要将矢量图形转化为位图，这个过程叫光栅化。}可以由应用程序自己\footnote{或自己写或拜托freetype2这样的库}进行。

\section{X窗口系统}

X的全称是X Window System。安装名称，是一个窗口系统。其实并不全面。X除了是一个窗口系统，还是一个图形渲染系统。X不仅提供窗口管理功能，也提供了图形绘制功能\footnote{而正是因为X提供了图形渲染，而导致了X成为性能低下的代名词。下面马上会讲到原因 !\_!}。

X协议下的Linux图形系统构造是如图\ref{fig:Xstruct} 这样的。

X是MIT在1984年的时候开发的，到1987年的时候出到了第11版本，也是当前正在使用的版本。当前的第11版X称为X11。

X实际上只是一个协议。就像HTTP是个统治互联网的超文本协议一样，X是统治UNIX图形界面的协议。
X是个协议就意味着必须有Server和Client。Server和Client相互使用X协议进行通信。所有的操作都是Server代为Client进行的。Client只需要通过X协议向Server发生请求即可。

也就是说, Client可以和Server处在不同的电脑上。这也是X的一个优势——网络透明。

\chatu{Xstruct}{X结构}

X的优势也是一个劣势：通过网络进行的操作不可避免的带来了大量的开销和延时。X通过缓存一部分请求然后封装成一个包进行批量发送在一定程度上减小了网络开销。但是延时是不可避免的。

\begin{notice}

想想用户点击一个按钮后，要从硬件到内核再到X Server，这都是很快的，慢速的地方在进入X Server后开始了。X Server同时连接了大量的 X Client， 任意时间都有大量的请求过来，非常忙碌。鼠标事件首先被X Server缓存，等处理完X Client的请求，开始把鼠标事件进行翻译，找到鼠标所在的窗口，将鼠标点击事件按照X协议格式化，再发送给X Client。X Client收到鼠标信息后，要进行“视觉回馈”。于是紧接着开始了大量的绘图操作，而所有的绘图操作，在X环境下，都是通过X协议透过网络转发到X Server上代为执行的。
想到一个简单的鼠标点击就产生多少次网络来回的数据包吧。 再想想，X同时为数十个X Client服务——极限环境下可能成百上千个——X Server 很有可能忙于处理X Client的请求而导致延时大大增加。

% 想如果X学Windows 7在入门版只允许开3个程序。

\chatu{XstructInteract}{一个按钮的交互}

\end{notice}


不过X也使用了很多的办法来提高速度。当前大部分环境下，基于X Server和X Client都是在同一台电脑上执行的事实，X还可以做很多的优化。比如使用共享内存代替网络传输。

\begin{notice}

\chatu{Xstructuselesscopy}{多余的拷贝}

这对视频播放软件特别有用。播放器在播放一个高清视频视频的时候，相当于每秒向X Server发送25幅全尺寸未压缩的高清图片。这是接近每秒198MB的数据量。想到这么多的数据，事实上发生了至少3次拷贝：一次是从播放器到内核（调用send(2)），一次是从内核到
X server（X Server使用recv(2)接收网络数据），一次是X Server拷贝到显存。放大这些拷贝因素后，得出实际上是每秒近600MB的数据量。这大大占用了系统的总线带宽。
如果这个时候共享内存介入，拷贝就只有一次了：播放器准备好的数据直接被X Server共享获得，然后拷贝到显存。



\end{notice}

\subsection{窗口管理}

用户移动窗口，改变大小，全屏/最大化窗口，最小化窗口，改变窗口次序，切换键盘焦点等这些操作都是所谓的窗口管理。有管理就会有策略。移动窗口，可以移出屏幕不？
改变大小，可以任意变小不？改变次序，以何种形式更改窗口堆叠次序呢？这些都是属于策略问题。不同的人有不同的喜好。一些人还有不允许窗口重叠的喜好，想让所有的窗口都平铺到屏幕上；不同的人喜好不同的窗口装饰\footnote{窗口的外框，最上门一排有窗口的标题和各种控制按钮——最大化，最小化和关闭按钮}风格$\cdots\cdots$

既然策略是一直非常众口难调的东西，MIT发明X的时候决定，X只提供实现窗口管理的机制，不实现窗口管理策略。窗口的管理策略连同窗口装饰，都由一个特殊的程序——窗口管理器——实现。

窗口管理器和其他X程序一样，都是X Client。只不过这个Client比较特殊，一个X Server上有且仅有一个Client能是窗口管理器——在同一个X Server下不能启动两个窗口管理器。

\chatu[width=0.8\textwidth]{kwinconfigfocuspolicy}{KWin配置焦点策略}

窗口管理器定义了窗口管理的规则。比如大部分窗口管理器都使用“点击获得焦点”的策略。点击一个窗口后，能将键盘焦点移动到被点击的窗口上，并将窗口提升到最前端。许多窗口管理器（通过可配置选项）还支持由鼠标所在的窗口自动获得焦点。如图 \ref{fig:kwinconfigfocuspolicy}所示，KWin\footnote{KDE默认的窗口管理器}允许4中焦点策略。默认是“点击获得焦点”。

\chatu[width=0.8\textwidth]{kwinconfigstyle1}{KWin配置装饰风格}
\chatu[width=0.8\textwidth]{kwinconfigstyle2}{KWin配置装饰风格}

窗口装饰是窗口管理器绘制的，通过修改窗口管理器的配置来修改窗口装饰的外观，如图 \ref{fig:kwinconfigstyle1} 和 \ref{fig:kwinconfigstyle2}所示。
图中我使用了2个装饰风格。


%\FloatBarrier

\subsection{混合窗口管理器}

混合窗口管理器——composited window manager——带合成功能的窗口管理器。
即是一个窗口管理器又是一个合成器。窗口管理我们了解了，那么混合是什么呢？

合成——composite——如名字所言，是用来混合的。那么混合的什么呢？
在介绍混合器（Compositor）前我们来看一张绚丽的桌面截图\footnote{当然，老样子，还是我的桌面，避免被窥视隐私，将系统托盘图标和浏览器书签栏和谐了。}：

\chatu[width=\textwidth]{3ddesktop}{三维桌面}

从传统的X结构上，这是不可能实现的。窗口不可能脱离屏幕出现在一个立方体上。
显然这绝对不是X Server能做到的事情。实现这个就需要窗口管理器做点小小的手脚了。

通常，一个X程序的窗口位于屏幕，窗口直接连接到帧缓冲区，调用XDraw*绘制会直接修改窗口所覆盖的帧缓冲区的内容，也就是直接绘制到屏幕上。

%TODO 图片

在合成环境下，窗口管理器利用特权\footnote{窗口管理相对一般的X Client有特权，否则怎么做管理。}向X Server标记窗口为redirected状态。被redirected的窗口，其绘图操作不会反应到屏幕上，而是绘制到一个缓冲区（off-screen buffer，离屏缓冲区）， 之后窗口管理器把各个窗口的离屏缓冲区的像素数据合成到屏幕上显示。合成期间可以加入各种效果，比如半透明（alpha合成），窗口阴影等等。也就是说，窗口管理器独占了整个屏幕的绘制，
其他程序的窗口被迫被重定向到一个离屏缓冲区绘制，绘制完成后由窗口管理器将绘制好的窗口内容合成到屏幕上。整个系统结构如图 \ref{fig:compositing} 所示。

\chatu{compositing}{X合成管理器}

那么一个窗口被绘制的路径是 X程序-->X Server-->离屏缓存-->合成管理器-->帧缓存（屏幕）。而没有使用混合管理器的窗口绘制线路图是：X程序-->X Server-->帧缓存（屏幕）。
由于多了合成操作，所以合成管理器对系统的要求要比直接绘制稍微多了点，故而合成管理器通常要求显卡具有“硬件加速”能力以使屏幕不至于看“幻灯片”。

\begin{insertnote}
\subsubsection{硬件加速小常识}
在计算机的显卡上，有一块固定的内存区域，被称之为“帧缓冲区”，其实内容就是一幅位图图片。显卡的扫描电路不停的扫描帧缓冲区的内容并转化为显示器驱动信号。
计算机向屏幕绘图的即为将帧缓冲区的图片进行更新。计算机绘制图形就是将帧缓冲区的每一个像素修改为指定颜色的过程。
通常程序使用比较高级的绘图原语——绘图原语通常提供“点，线，多边形，曲线”的绘制操作\footnote{复杂的图形都是又数不清的多边形和曲线构成的}——由绘图引擎将其转化为对每一个具体像素的修改。这个步骤叫“光栅化”。

由于绘图原语中的每一个操作都是对批量数据的简单操作，所以有可能通过硬件直接实现。这样费时的光栅化操作就可以交给专门的硬件电路执行，释放了CPU的处理能力。这个就叫硬件加速。

由于显卡硬件复杂度的提升，越来越多的绘图指令被“硬件加速”了。能够专门利用硬件加速的绘图指令集有2个，一个是Direct3D一个OpenGL\footnote{我们将在 \secref{sec:OpenGL} 介绍OpenGL。}。一小部分X的绘图操作也是硬件加速的——当然，前提是驱动支持。

由于Direct3D为微软专有，所有Linux下的硬件加速无一例外的是采用的OpenGL，故大部分混合窗口管理器都要求显卡支持OpenGL以便发挥显卡的功效获得最佳体验。

\end{insertnote}

现代的桌面有很多地方依赖于“半透明”窗口来提供最佳的用户体验。而要实现半透明窗口就意味着：窗口要和位于其下的窗口执行alpha混合。这就必须要求使用一个混合窗口管理器了。
所幸运的是，并不是所有的混合窗口管理器都要求有OpenGL支持的显卡，仔细优化的纯软件混合一样能获得流畅的桌面。
KWin检测到用户电脑显卡无法开启OpenGL的时候——不论是因为硬件太老而不支持KWin所需要的OpenGL功能还是因为缺乏正确的驱动程序——就自动进入软件混合模式。
作为对比，GNOME使用的mutter窗口管理器拒绝在不支持OpenGL的机器上启动。

看来编写一个性能不错的软件混合管理器难度相当的大。为了节省开发者的精力，我们还是老实的把驱动给安装好吧！

\subsection{OpenGL和Mesa}\label{sec:OpenGL}

前面在讲X结构的时候，都没有说到硬件加速。引入了硬件加速后，X的结构要发生重大的变化，前述的图例已经不能表达X的结构了。

说到硬件加速就不得不说OpenGL。OpenGL从其首页上的描述\footnote{ \url{http://www.khronos.org/opengl} }来说，是2D和3D图形硬件的编程接口。
OpenGL是一个编程接口（API）的规范，应用程序只要使用这个通用的API编写就可以利用强大的GPU的处理能力。OpenGL的实现通常由GPU制造商提供，包含在显卡驱动里。
使用OpenGL的程序链接到 libGL.so.1 库，libGL.so.1 库又由显卡驱动提供。硬件开发商在库中将OpenGL的调用转换为显卡GPU能执行的命令然后交又GPU执行。这样大量的绘图指令就交给GPU而不是CPU执行了。大大提升了图形程序的执行效率。
通常需要如此执行效率的程序都需要绘制3D图形，如3D游戏和3D设计软件。

在Linux的世界，除了显卡厂家提供的闭源的libGL.so.1实现，还有开源的实现。实现开源OpenGL的程序就是Mesa。

在初期，Mesa将OpenGL绘图指令转化为Xlib的绘图指令。中间的转换纯粹是由软件执行的。Mesa又被称为软件渲染。之后 Mesa 加入了针对特定显卡的“驱动”。OpenGL 指令由这些“驱动”翻译为对应显卡GPU的控制指令，然后再发送给显卡执行。我这里“驱动” 加了引号，是因为这个驱动是纯粹的Mesa针对不同显卡写的不同的“GPU指令生成器”。并不是通常意义上载入内核的驱动模块。
由于向显卡发送指令需要root权限，所以这个时候Mesa需要由 X server调用，而 X client则需要将 OpenGL 调用包裹到 X11 协议中。

不过，在加入了DRI\footnote{Direct Rendering Infrastructure}后，X client 就能直接使用显卡的OpenGL功能了。

\begin{insertnote}

\subsubsection{名词解释：DRI}

DRI是Xorg提出的一种全新的渲染架构。结构如图 \ref{fig:dri} 表示。


\chatu[scale=0.7]{dri}{dri结构简图}

X Client 程序还是利用Xlib发出传统的绘图指令。如果使用了OpenGL，并使用直接渲染, 绘图指令将绕过X Server之间经过 libdrm 发送给内核一个叫 drm （Direct Rendering Manager） 的模块。
drm再将指令直接发送给显卡。 因为中间的绘图过程绕过了X，直接向显卡发送绘图指令将图像写入帧缓冲，故而得名直接渲染。 这里请注意的是，直接渲染和间接渲染的差别就是渲染过程 有没有经过X server， 而和是不是利用了显卡加速是没有关系的。间接渲染一样可以使用显卡加速。 直接渲染的优势是中间没有经过X server， 减小了延迟，去除了X11协议的网络开销。
极大的提升了 3D 渲染的效率。

%因为在间接渲染模式下，OpenGL 也被包裹到了X11协议中发送给Xserver由 X server代为调用 OpenGL。

闭源驱动并不使用DRI，闭源驱动有自己的直接渲染方式。因为drm模块是GPL协议的，闭源驱动若使用了drm岂不是要开源掉自己OpenGL实现。所以闭源驱动会自己带有libGL.so.1而覆盖掉Mesa提供的。Gentoo使用eselect机制，安装的时候将libGL.so.1安装到各自的目录，然后使用
\begin{code}
\#eselect opengl set [name] 
\end{code}
设定一个 OpenGL 实现，系统目录下的/usr/lib/libGL.so.1将链接到被选择的OpenGL实现。
通常是 nvidia,xorg,fglrx三者中选一个。xorg 就是使用的Mesa提供的 OpenGL实现。可以用
\begin{code}
\# eselect opengl list
\end{code}
 列出系统已经安装的 opengl 实现。没有安装的并不会列出。

\end{insertnote}

\subsection{内核模式设置KMS}

TODO

%TODO KMS 介绍


\section{安装基础X环境}

%一个基础的X环境包括一个X Server和支持库。这些库包括 Xlib（以及一些扩展）和libGL。值得注意的是，X Server 依赖于libGL而不是反过来。

在Linux世界，曾经有一个开源的X11实现名字叫做XFree86\footnote{x86上用的自由（Free）的X}。不过XFree86的幕后公司开始拿XFree86做商业盈利的时候伤害到了社区的感情。大量的开发者逃离XFree86项目，以最后一个公开的XFree86源码为基础重新组建了一个X.org组织。所以Gentoo曾一度提供两个X Server: XFree86 和X.org。不过UNIX世界有个经典名言：里开源越近越繁荣。被社区抛弃的XFree86很快销声匿迹了。所以现在的X11就是用的X.org了\footnote{后来MIT将X11协议本身的维护也交由X.org了。这都是后话了。}。


前面图片里可以看到，X Server分成两个部分：DIX（Device Independent X）和DDX（Device Dependent X）。 DIX实现X11协议，和X Client通讯，接受请求。
DDX实现的是和硬件的交流。硬件分两个大总类：Video和input。
之前在图 \ref{fig:Xstruct} 提到过，X对显卡的操作是不经过内核的。X有自己的显卡驱动。X必须运行在root权限的缘由也是基于此。X通过将显卡的IO映射到自己的内存空间来实现直接操作显卡。对内存映射IO可以参考 \faqref{FAQ:MMIO}。

X Server即利用了这一点。X Server首先通过内核的帮助将显存映射到自己的内存里，之后就可以绕过内核直接对显存进行访问。除了显存外，显卡还有IO端口，用于向GPU发送命令。X Server也将显卡的IO端口映射到自己的内存里，之后就可以直接对显卡进行操作了。故而X需要显卡驱动。

显卡驱动是DIX的重要组成部分。X.org 发布的X Server中自带有大量的显卡驱动（开源驱动）。还有一些驱动由硬件厂家提供（闭源的二进制驱动），需要自行下载安装。

Gentoo portage有个重要的变量VIDEO\_CARDS\footnote{到 /etc/portage/make.conf 中设置} 指示emerge使用的显卡驱动，一来安装X的时候能正确的自动安装好驱动，二来能自动选择好Mesa使用的驱动，三来可以略过全部无关驱动的安装。

VIDEO\_CARDS的取值如表 \ref{table:videocards} 所示。

\begin{longtable}{|l|p{0.7\textwidth}|}
\caption{VIDEO\_CARDS 驱动列表}\label{table:videocards}\\
\hline
apm & Alliance ProMotion显卡驱动。 \\\hline
ark & ark 显卡驱动。 \\\hline
ask & ask 显卡驱动。 \\\hline
chips & Chips and Technologies 显卡驱动。 \\\hline
cirrus & Cirrus Logic 显卡驱动。\\\hline
%cyrix & Cyrix 显卡驱动。 \\\hline
%displaylink & displaylink 显卡驱动。 \\\hline
dummy & 伪显卡驱动。只用于Xvfb。 \\\hline
fbdev & 通用帧缓存驱动 ， 使用 /dev/fb* 设备。 \\\hline
fglrx & AMD/ATI 闭源驱动。  \\\hline
%geode & AMD Geode GX 和 LX 显卡驱动。 \\\hline
glint & GLINT/Permedia 显卡驱动。 \\\hline
i128 & I128 显卡驱动。\\\hline
%i740\footnote{服务器芯片。家用电脑没有使用过。} & Intel 740 系列显卡驱动。 \\\hline
%impact & Impact 驱动 \\\hline
intel & Intel 显卡驱动。如无例外，Intel显卡全部适用此驱动。\\\hline
%ivtv & ivtvdev 显卡的 IV-out 功能驱动。 \\\hline
mach64 & ATI Mach64 显卡驱动。 \\\hline
mga & Matrox 显卡驱动。 \\\hline
modesetting & 通用显卡驱动，适用于KMS\footnote{见 \secref{FAQ:KMS} } 帧缓存设备。\\\hline
meomagic & Neomagic 显卡驱动。 \\\hline
%nested & 伪显卡驱动，用于 Xnested。 \\\hline
%newport & Newport 显卡驱动。 \\\hline
nouveau & 开源的NVIDIA显卡驱动。带3D加速。 \\\hline
nv & 开源的 NVIDIA 显卡驱动。无3D加速。可用于nouveau无法驱动的旧型号显卡。 \\\hline
nvidia & 二进制NVIDIA显卡驱动，由 NVIDIA 官方提供。\\\hline
%nsc & nsc显卡驱动\\\hline
%omap & ARM 芯片供应商德州仪器制造的OMAP系列芯片的片上集成显卡的驱动。 \\\hline
%omapfb & OMAP芯片提供的帧缓存的驱动。\\\hline
%psb &  一些上网本使用的 GMA500 显卡驱动，intel贴牌，实际由poulsbo制造。\\\hline
qxl & Qemu虚拟机 QXL paravirt 显卡驱动。\\\hline
r128 & ATI Rage128 系列显卡驱动。\\\hline
radeon & 开源 AMD/ATI 显卡的驱动。 \\\hline
rendition & Rendition 显卡驱动。\\\hline
s3 & S3 显卡驱动。\\\hline
s3virge & S3 ViRGE 显卡驱动。\\\hline
savage & S3 savage 显卡驱动。\\\hline
siliconmotion & Silicon Motion 显卡驱动。\\\hline
sis &  SiS 和 XGI 显卡驱动。\\\hline
sisusb & SiS的USB显卡驱动。\\\hline
tdfx & 3Dfx 显卡驱动。\\\hline
tga & tga 显卡驱动。 \\\hline
trident & Trident 显卡驱动。\\\hline
tsend & Tsend Libs显卡驱动。\\\hline
v4l & video4linux驱动。\\\hline
vesa & 通用显卡驱动。最后的救命稻草哦！\\\hline
via & VIA/S3G 集成显卡驱动。\\\hline
virtualbox & VirtualBox 虚拟机里安装Gentoo的话使用这个驱动。\\\hline
vmware & vmware虚拟机里使用Gentoo的话安装这驱动。\\\hline

\caption{VIDEO\_CARDS 驱动列表}\label{table:videocards}
\end{longtable}


\begin{insertnote}
注意：显卡驱动不看显卡板卡本身，而是看显卡所使用的GPU芯片。
\end{insertnote}


其实值得说明的是，虽然看上去驱动很多，其实现在显卡世界经过多年激烈的竞争后，已经只剩下 intel AMD NVIDIA三巨头了。
intel自不用说，有且仅有开源驱动，VIDEO\_CARDS安心的写上intel即可。AMD和NVIDIA则是开源驱动和闭源驱动共存。使用开源还是闭源驱动，第一要务是：必须能跑起来！如果两种驱动都合适，就看各位自己抉择了，是使用厂家提供的驱动还是使用开源驱动。AMD 的闭源驱动叫 fglrx 支持的是 AMD自家显卡和收购 ATI 之前年开发的显卡， 开源驱动实际上安装的是 xf86-video-ati 不过，VIDEO\_CARDS的设置是 radeon，支持的显卡比fglrx稍微在旧的批次上多点——如果fglrx放弃支持你的老显卡了，你只能用radeon驱动了。 最早一批的ATI显卡使用的是r128驱动,没有闭源驱动支持，不过我很怀疑现在是否还能看得到这些显卡。

NVIDIA显卡则有3种驱动可选 nv nouveau 和 nvidia。 在nouveau之前nv是nvidia唯一的开源驱动，nouveau出现后已经不建议使用了。nvidia的闭源驱动有多个版本，96.XX 版本 173.XX 版本和 3XX 版本。分别对应的支持最老旧的NVIDIA显卡，很老的NVIDIA显卡和现在还在使用的NVIDIA显卡。具体你的显卡适用哪个版本可以到官方网站的驱动下载页面查询。
一帮来说，除了非常老的显卡，最新驱动都可以支持。

接下来要设定的就是输入设备的驱动了。输入设备的驱动由 INPUT\_DEVICES\footnote{同样在 /etc/portage/make.conf 设置。} 选择。

INPUT\_DEVICES可用的取值如表 \ref{table:inputdevice} 所示。


\begin{longtable}{|l|p{0.7\textwidth}|}
\caption{INPUT\_DEVICES 输入设备驱动列表}\label{table:inputdevice}\\\hline
evdev & 标准Linux输入设备驱动。适用于键盘和鼠标。 \\\hline
acecad & Acecad Flair input driver。  \\\hline
aiptek & Aiptek  USB 数字平板输入仪驱动。 \\\hline
elograhpics & Elographics 触屏驱动。\\\hline
fpit & Fujitsu Stylistic平板的触屏驱动 \\\hline
hyperpen & hyperpen 手写笔驱动 \\\hline
joystick & 游戏手柄驱动 \\\hline
mouse & 鼠标驱动（已被evdev替代） \\\hline
keyborad & 键盘驱动（已经被evdev替代）\\\hline
synaptics & 触摸板驱动，不安装则触摸板只是一个鼠标，不能使用触摸板的高级功能 \\\hline
tslib & 利用 tslib 实现的触摸屏驱动。 \\\hline
vmmouse & VMWARE 虚拟机鼠标，使用此驱动代替evdev可以获得VMWARE和宿主机的集成功能。\\\hline
%evdev -acecad -aiptek -elographics -fpit -hyperpen -joystick -keyboard -mouse -mutouch -penmount -synaptics -tslib -vmmouse -void -wacom
wacom & wacom手写板输入 \\\hline

\caption{INPUT\_DEVICES 输入设备驱动列表}
\end{longtable}


evdev 是 Linux下的新设备驱动,代替之前分开的鼠标和键盘驱动。Linux内核提供统一的 /dev/input/event* 设备文件供用户空间的程序使用。

如果不是使用BSD的话，一般只需要使用evdev即可。对于笔记本，还需要启用 

设置好  INPUT\_DEVICES 和 VIDEO\_DEVICES 即可通过

\begin{code}
\#emerge xorg-server
\end{code}

安装 Xorg 的X Server了。安装Xorg需要较长的时间，除了本身Xorg比较大之外，Xorg引入了大量的依赖也是重要的原因。而且很有可能会出现循环依赖。需要依据提示暂时禁止某个USE标记
以打破循环依赖。

\section{桌面环境}

光有一个X什么也做不了，X是一套实现GUI的机制，我们需要一个“操作环境”。正如shell提供了文本模式的操作环境一样，在X下也需要一个“shell”来提供图形模式的操作环境。
做到这样一个图形操作环境，需要：窗口管理器、桌面、文件管理器、任务栏（提供窗口切换）、系统托盘区域、各种小程序等等东西，整合一些提供这样功能的程序集合就构成了一个“桌面环境”。
Linux有很多各种各样的桌面环境，最流行的还是KDE和GNOME。

\subsection{KDE}

传统的UNIX使用的桌面环境是CDE——Common Desktop Environment。但由于昂贵的授权费和对其他一些可选的替代方案的不满导致了德国人Matthias Ettrich\footnote{同时也是LyX的作者。}于1996年发起了KDE（Kool Desktop Environment）项目。也许看看他当时的宣言能更好的理解当时的状况。

\begin{insertnote}


\begin{center}
KDE 项目宣告

新项目: Kool Desktop Environment (KDE)

{\scriptsize 急需程序员！}

{\footnotesize 译：微蔡}
\end{center}

{\large  \noindent \bf 动机}

自由UNIX衍生版特别是Linux的出现让UNIX变得更流行了。但是仍然缺乏一个外表好看，界面统一的自由桌面环境。便宜甚至免费的程序已不在少数，只要能提供一个真正的GUI环境，Linux+X11基本上就能满足所有人的需求了。

这其中当然有这样的GUI环境，Commond Desktop Environment（太贵了）和Lookin Glas（相对便宜点），当然还有其他一些能算的上是“GUI环境”的免费程序：
比如 Moxfm 工作的就很好。可惜他是基于Motif设计的。当然，更重要的问题是：啥是一个GUI环境？它应该是怎么样的？


首先，我列出什么不是GUI环境：

\begin{enumerate}
\item [\textbullet] X窗口系统不是GUI环境。如名字所言，是一个窗口系统。
\item [\textbullet] Motif 不是一个GUI环境。Motif创立者曾希望通过Motif创建一个GUI环境，不幸的是他们意见没能统一，只好将Motif作为一个控件库发布并附带了一个文件管理器。

\item [\textbullet] 窗口管理器也不是GUI环境。他们只是一个管理窗口的小程序。把很多东西放进窗口管理器本身并不是个明智的做法。
\end{enumerate}

就我所知，一个GUI环境应该提供一个完整的图形环境。允许用户用它来做每天的工作，比如开启程序、阅读邮件、配置桌面、编辑文件、删除文件、看看图片等等。
所有的这些部件都应该整合到一起协调工作。带一个编辑器图标的按钮如果启动了xterm这个终端仿真程序在里头执行个vi就不能算是一个真正的GUI。
可能你很早就失望的发现，点击桌面上漂亮的帮助图标却等来的却只是一个终端仿真器，里面因为运行着man而正在显示man手册。

{\large \noindent \bf 面向最终用户的GUI}

我的主意并不是为一个完整的UNIX系统或者系统管理员创建GUI——这种情况下一个shell和上千个命令行工具可能是个更好的办法——而是面向最终用户。为那些希望上上网，写写文档，玩玩游戏的用户准备。

直到我配置我女朋友电脑前，我真心觉得Linux更能做到这点\footnote{这句话为fcitx作者csslayer帮我翻译的，原文是“I really believed that is even yet possible with Linux until I configured my girlfriends' Box. ”}。
就别提我要处理多少种形式和风格各易的菜单、滚动条和文本编辑框了。
我已经知道一些控件必须在鼠标下才能进行输入，一些页面需要用鼠标中建拖动，一些编辑框甚至只能使用和emacs一样的快捷键——连“End”按键都不能支持。
各个程序也都有不同的选择文字的办法。甚至连菜单和按钮都完全不具有一致的行为（比如Xaw, Fvwm, XForms, Motif）。

一句话来形容这些雅典娜\footnote{智慧与技艺的女神，这里指的是每个程序作者都发挥自己的智慧和技艺创造出各种形式的界面，风格及其难以统一。}型的控件：
尽管有很多使用这些雅典娜控件的程序，我们最好还是丢了他们吧。“雅典娜控件”和“X是GUI”应该是一样的错误想法。这种雅典娜式的控件应该视为如何使用Xlib和Xt构建一个控件库的反面例子。
X应该有一个控件库作者的在线帮助，而无论如何不应该成为应用程序作者的文档\footnote{指的是应用程序作者应该使用一套统一的方便的UI库来创建程序而不是直接使用Xlib。}。 不信的是，应用程序作者就是靠的X手册编写的。

所以，我提议一个GUI环境首先就应该为所有的程序提供一个一致的“外观”。这正是本项目所以和其他的项目最本质的不同点。

就在几个星期前，一个对自由软件开发而言即免费又自由的UI控件库出现了，\url{http://www.troll.no}\footnote{光阴似剑啊！Qt最原始的网站早已不可访问了。} 去看看吧。

这个库就是Qt，并且将是X界面编程的革命。它差不多已经非常完善了，完全的C++类库，提供了Motif相仿的外观，或者可以配置为类Windows95的外观。

它由一家公司控制的事实反而是一个大大的好处：我们有代码和这么好的库，他们有测试人员。他们也全力的提高这个库的质量。他们还提供技术支持。这就意味着，Qt也能用于开发商业软件。
它是Motif的真正替代品 ：）。  让我觉得Qt很专业的地方就是它的代码了。它真的是非常容易使用的C++库。

Qt还是可移植的，是的，兼容Windows。当然这你不用当心。在你代码里稍微加点UNIX/X专有的东西就跨不到Windows平台了 :)。


我强烈的建议大家看看这个库。它有能力成为自由软件开发的领军库。使用它就轻而易举的逃过了那个会吃掉所有内存和CPU的怪物级TCL/TK库$\cdots$

是时候为桌面设立一个标准了。同时往内存里放10个不同的控件库是在是一点意义都没有。想象一下这些程序和使用的库：

\begin{enumerate}
\item[\textbullet]    fvwm （自己的控件）
\item[\textbullet]    rxvt （自己的控件）
\item[\textbullet]    tgif （自己的控件）
\item[\textbullet]    xv （自己的控件）
\item[\textbullet]    ghostview （雅典娜控件）
\item[\textbullet]    lyx （xforms 空间库）
\item[\textbullet]    xftp （Motif 控件库）
\item[\textbullet]    textedit （xview控件库）
\item[\textbullet]    arena （自己的控件）
\end{enumerate}

可能有人会狡辩说，UNIX机器内存很大，往内存里放那么多UI控件库不是问题。即便是这样，真正的问题是：所有这些控件（菜单，按钮，滚动条等）库统统都没有一致的外观和行为。
这不是学院研究的例子，这是我真实见到过的 :-\}

我知道不可能一下子就清除掉它们，我也希望Motif和Qt能共存。


{\large \noindent \bf The Kool Desktop Environment (KDE)}

我没有时间自己一个人全部做下来（也有LyX\footnote{LyX是一个基于\LaTeX的图形化编辑器。}是我的主要项目这个原因。）。
像KDE那样的打项目能很容易的切成各种小部分。其中就有给你的部分！如果你要学一些X编程，那干嘛不开始给KDE写点小东西呢？
要是你知道有人能写点程序，请千万不要让他们再写第1004\footnote{作者这里的意思是，别浪费才能和时间在克隆已经写过无数遍的游戏了，参加到KDE项目中来吧！}个俄罗斯方块或者地768个扫雷了。;-) 我们已经有很多了 ... 

然后接下来就是我的KDE项目需要的程序的列表。也许还有更多，这是一个开发的项目，欢迎添加。

{
\leftskip=2.2em
\small 

{\noindent \tt 面板：}

    基本程序。开始是Fvwm的一个模块运行。提供类型Windows 95那样的底部任务栏和CDE那样的顶部面板。面板左边有菜单按钮用来开启程序，中间有4个用来切换虚拟桌面的按钮，然后右边有些快捷启动。
    比如有个邮件图标并且能通知新邮件的到来，一个垃圾桶指示回收站是否为空并能快速打开。或许还可以有一些电子时钟放在最右边。
    最好还有个漂亮的图标用来锁定屏幕、注销和关机。所有这些都是（在图形界面下）完全可配置的。
    我还在想一个解决办法，只让可用的GUI程序出现在桌面上，并且新安装的程序能自动的出现在桌面上。

    我已经着手开始写面板了，非常希望能获得一些帮助。还有很多事情要做呢！比如一个工具用来设置一个壁纸。
    
    一个好看的图标也是很有帮助的！

{ \noindent \tt 文件管理器：}

    KDE的另一个重要软件。创建一个功能强大的bash图形替代品, 并对简单的任务有一个易用的界面。简单的任务就是上传文件，拷贝文件，双击打开文件啊之类的。

    我还想到为每个目录打开一个漂亮的窗口，每个文件都是一个图标。图标可以拖动以复制或者移动文件——甚至可以在窗口直接拖动。
    还有一个重要的功能就是支持移动设备的自动挂载，这样对用户就是透明的了，无需关心mount/umount命令。

    拖动应该使用比较优雅的方式实现。拖动的图标应该是一个特殊的从窗口（参照 Qt 的 xshape 例子）而不像xfm或是xfilemanager那样是通过设定鼠标的图标来进行。

    所以把文件作为一个图标放到桌面上也是可行的了。这非常有意思，不是么？ 一些应用程序用面板启动，现在很清楚了，图标就是个数据对象，而fvwm1和 FvwmFileMgr都不能确定一个图标是文件还是最小化的窗口。    

    Qt程序之间实现拖动并不难。文件管理器实现起来并不难，并且也花不了多少时间，有谁能接手这个任务？
    
{ \noindent \tt 邮件客户端：}

    真正舒心的邮件客户端。现在我发现最好的邮件客户端（X环境下的）是XF-Mail。作者表示一旦KDE项目启动会将其移植到Qt下。不过他表示需要一些协助（比如写个简单的弹出菜单）。 
   
{ \noindent \tt 简单的编辑器：}

    很小但很重要的项目。一个月都编辑不了一次文件的人不可能乐意去学vi这样的软件或者等x-emacs\footnote{emacs的优良传统，启动非常慢。}启动甚至都不会掏钱去买个motif-static-nedit\footnote{一个基于Motif开发的文本编辑器}，更不可能乐意使用怪兽级别的 tkedit\footnote{作者说tk是怪兽，自然用tk开发的tkedit也是如此了。} ....

	不幸的是，Qt-1.0 还没有提供多行编辑控件。但是Troll-Tech公司已经在测试版里提供了，所以几个星期后应该就可以着手编写文本编辑器了。
	
{ \noindent \tt 终端模拟器：}

    和CDE的终端模拟器差不多。就是带菜单，能设置字体的 xterm。 很好的项目，拿xterm的代码修修，移植到Qt下就可以了。
    
{ \noindent \tt 图像查看器：}

    这个程序在文件管理器里将会被默认用于查看gif，jpeg等图片文件。额，xv是不错，不过是个共享软件。启动速度也不快。有个没有菜单没有按钮的纯Xlib软件叫xli启动速度倒是飞快。把它的代码拿来移植
    到Qt下作为起始点吧。 %. But there is a plain Xlib programm without any menues or buttons called "xli". Get the sources and make it userfriendly with Qt!
    
    
{ \noindent \tt 其他一些有用的工具：}

        xdvi 改成 Qt-Gui
        ghostview 改成 Qt-Gui
        xmag 改成 Qt-Gui
        其他

{ \noindent \tt 超文本格式的帮助系统：}

    一个完整的桌面需要一个友好的帮助系统。我认为一个很好的选择就是 HTML （>=2.0） 。 需要一个基于Qt的HTML查看器。
    可以借用 Arena 的代码，不过Arena 启动太慢了。最好还是从头写一个。Qt 提供了非常简便的接口处理字体。对于一个帮助系统来说， HTML 2.0 已经足够了。再添加一些搜索功能就可以了
    因为传统的 troff 格式的man手册也能转换为HTML格式，我们还能集成man手册到帮助系统里。

    顺便一提：Troll Tech公司开出了一个Qt竞赛（看看他们的首页）。最好的Qt程序（不仅仅是功能上，还包括设计上。仅仅将现有的程序移植到Qt下还不够的 :-( ）将赢得 2000美金和 Qt 的Windows版的授权（价值2000美金。）。他们还提到了一个浏览器作为例子。所以一个 Qt 的浏览器将值 4000 美金哦 （把用不到的 Windows版Qt授权卖掉） ;-)。


{ \noindent \tt 窗口管理器：}

    最开始，KDE面板将作为Fvwm的一个模块。等做好了，很多东西就可以从 fvwm 窗口管理器里剥离了。我们不需要fvwm的菜单、图标和难懂的配置文件。我们只需要一个很小的靠谱的窗口管理器。
    所以从 fvwm里删除一切不需要的代码，应该很快就能完成。


{ \noindent \tt 系统工具：}

    不管你是什么类型的用户，都会需要的。一个图形化的密码设置对话框出现在我脑海里。还有更多的吧！可能会导致一个小型系统管理工具集合也说不定。
    

{ \noindent \tt 游戏：}

    俄罗斯方块我们已经有了（作为Qt的一个示例）。我们还需要的是很多其他的小游戏，比如纸牌。有一些已经跑在X下的游戏，干嘛比从中汲取资源，然后自己写个真正的游戏呢？就像微软的纸牌那样。
    有时候我就为了玩纸牌安装个Wine。还有很多很多的游戏，多多益善。要么从现有的修改，要么从头写，咋样都行：）
    
{ \noindent \tt 图标：}

    一组漂亮的图标。可以从3D-pixmaps开始。（如果我们用的UI库有按钮的话干嘛还需要用图片模拟按钮呢？）
    
{ \noindent \tt 文档：}

	文档总是好东西。在这之前，我们的超文本格式的帮助系统应该先设计出来。然后我们就能开始写HTML格式的帮助页面了。喏，在这之前我们还得有程序可文档啊！

{ \noindent \tt 基础设施——页面/文件服务器/管理员：}

    我们需要一个服务器来保存这么多文件和页面，通告大家项目的状态。特别是当前我们在做什么，还需要人做什么。稍后我会在
    
    	\begin{center}
    	\url{http://www-pu.informatik.uni-tuebingen.de/users/ettrich}
    	\end{center}

设置一个首页。当然，只包含本文和一些链接。之后我会捣鼓出一个真正的首页——如果有人帮我做这个事情这样我只需呀关心编码我会非常高兴的。
要是有谁想帮KDE设计和维护首页，我很乐意让他这么做哦。:)

{ \noindent \tt 讨论：}

	最后，也是最重要的事情 :-) , 如果你们有兴趣就请加入我们的邮件列表  \email{kde@kde.org} 讨论吧！
	订阅邮件列表只需要发送一封如下内容的邮件到 \email{kde-request@kde.org} 就可以了。
	
\begin{center}
	{\tt subscribe 你的邮箱}
\end{center}


{ \noindent \tt 应用程序：}

	当KDE开始广泛使用的时候，新的程序有望基于Qt开发。获得和桌面环境协调一致的观感。

    我们很可能会把 LyX 移植到Qt，这样一个舒适的字处理软件就有了。不过这还在和LyX组成员讨论中。

    一个矢量绘图软件也很好。Xfig虽然丑了点，不过还是不错的。 tgif 也很强大。这些丑程序的作者并不喜欢添加 Qt 的界面，因为Qt是 C++ 的，而原作者只希望使用C——一些平台没有c++编译器。
    当然，KDE才不关系连c++编译器都没有的平台。（而且我认为 g++ 已经到处都有了。） 也许 tgif 作者赞成让别人来添加Qt界面 （反正源码在那里，不知道是不是GPL的。）。
    因为 tgif 没有使用第三方控件库而是全部自己实现，添加一个Qt界面应该不是什么难事。Qt里直接使用Xlib还是相当轻松的，所以并不需要重写很多代码。
    C++也兼容C，这样保护原有的C代码和是相当的容易。

    一个新闻阅读器怎么样？也能集成到KDE里。还有很多很多很多 ............

}

所以有趣的事情还是蛮多的。你要是感兴趣请加入我们吧！召集二三十人我们就可以开始了。可能平安夜前我们就能给自己一个礼物了。

KDE将使用GPL许可发布。

我承认这听起来有点疯狂。我可以告诉你，我是否非常认真的。每个和我讨论的人都说希望能有个简洁的桌面。Qt是实现这个目的的一个机遇。
让我们把业余时间利用起来开始干吧！

希望很有很多很多的回帖!
此致,\\
\qquad 敬礼！

Matthias Ettrich
(\email{ettrich@informatik.uni-tuebingen.de})

顺便说一下：通常这样的帖子会遭到这样的回复：“你要喜欢GUI就去用苹果好了”；“我就喜欢桌面程序上有各种不同风格的控件，你要是蠢的学习就去用Windows好了” ； “内存不够啊，我只用Motif”；
“你永远不会成功的，做点别的事情吧。”；“干嘛Qt? 我更喜欢用 schnurz-purz-widgets with xyz-lisp-shell, 还是 GPL 的！”； 等等。
非常感谢这样的回复，让我知道我还是有梦想的人 ......

好吧，又来了：你可能想问我干嘛那么讨厌 Tk。 恩，我不喜欢它的设计哲学： Tk 连个文本编辑控件都没有，却有一个缓慢的字处理程序。其他控件也差不多。
再同TCL语言结合起来，这个 Tk 程序就慢到家了（当然也有例外）。我还没有看到哪个 C/C++ 程序是用Tk库的，尽管Tk也包含C接口。TCL/TK 做点原型还行，写点内核图形配置工具倒不错，用来写应用程序就算了。
我压根就不想让哪个 Tk 程序待在桌面上。Qt就简单多了。试试看吧！

我确定是最后一段废话了：我和Troll Tech公司没有任何联系。我只是单纯的喜欢他们的产品（看看他们的代码，质量非常高！）和市场策略：对自由软件免授权费。

\end{insertnote}

耐心的看完{}Matthias Ettrich{}关于开始KDE项目的声明后能发现一些有趣的事情：
商业的桌面环境有，CDE , Looking Glas。 贵而且也不咋好用；多数程序都是直接使用Xlib开发，重复发明轮子。而且外观都无法统一；少数有几个帮助开发X程序的控件库，要么丑陋要么本身是个怪物；当时唯一可以扛担次重任的就只有一个Qt，虽然不是GPL授权的软件，好歹对开发自由软件是不收钱的。

KDE就在这样的环境下起步了。到本文写作的时间为止，KDE已经发布到 4.10了。

Gentoo下安装 KDE 环境非常简单。只要一条命令即可

\begin{code}
\#emerge kde-meta
\end{code}

这会将所有的KDE组件全部按照。依据提示可能需要开启一些 USE flag。将其添加到 make.conf 即可。更方便的莫过于直接启用 kde profile

\begin{code}
\#eselect profile  set default/linux/amd64/10.0/desktop/kde
\end{code}

这个 profile 会预先将 KDE 相关的 USE flags 全局启用。

如果不想把全部的 KDE 都安装（那意味着要编译数百个软件包），可以只安装一个基础的KDE运行环境。 

\begin{code}
\#emerge kdebase-meta
\end{code}

这样将只安装运行KDE所需的最小环境。不过{}Matthias Ettrich{}在声明里提到的邮件客户端，各种小游戏，新闻阅读器等等东西可全都没了。
不过，这不失为一个好办法，先折腾出KDE桌面，进去了再说，慢慢再编译全 :) 


\subsection{GNOME-Shell}

GNOME 是各个主流发行版的默认桌面环境。不过这个名声得来的有点不是那么厚道，起码不是靠实力获得的。GNOME无论是在易用性还是在可定制性上都离KDE差了一大截。GNOME能获得今天的成就，原因是
一开始就站在了道义的制高点牵制住了KDE。这是为何呢？

原因就在Qt上。{}Matthias Ettrich{}开发KDE选择了Qt。而当时的Qt并不是一个开源软件。Qt由一家叫做Troll Tech的公司掌握。Qt采取办法是的是对开源软件的开发使用免费授权，只有开发商业软件才需要购买商业授权。但是社区的一些人开始担心Qt的未来。
特别是RedHat这样的大公司，不希望Linux桌面被一家挪威公司掐住咽喉。于是 RedHat 伙同 IBM ，再拉上其他公司\textbf{资助}了另一个项目：GNOME。

没有大公司的资助GNOME从一开始就不会存在。所谓兵马未动粮草先行嘛。GNOME名义为社区项目，实际上参与GNOME开发的人有大量是Linux界有影响力的大公司的全职员工。
特别是RedHat派出了数量最多的人员参与了GNOME项目。因此在一些人当中流程GNOME是RedHat项目的说法。这当然是无稽之谈，不过GNOME获得大公司的资金和人员上的直接资助是事实。

GNOME为了避免KDE依赖于一个私有的Qt软件的弊端，选择了Gtk作为其GUI界面库。GTK是GIMP的副产品。全称为 Gimp Tool Kit。是为了开发GIMP而编写的一个UI库。同Qt一样是对Xlib的一次包装。
和Qt不同的是Gtk采用C语言开发。

相比采用不标准的C++语言, GNOME选择了同Gtk一样使用C语言进行开发。当时C++还不是一个标准语言，使用C++的开发者并没有C语言多。所以从一开始GNOME的选择就能吸引更多的社区开发者。

\begin{notice}
注意：C++语言的第一个标准是在 1998 年通过的，又叫C++98标准。第二个C++标准是2011年通过的，叫C++11。有人会提到2003年通过的C++03，那个是对标准库的一次扩充和修正，语言本身没有变化。
所以KDE创立于1996年，实际上是在使用一个没有标准的语言。标准要到2年后才有。
\end{notice}

由于没有协议的问题，GNOME获得了飞快的发展。从1997年立项开始没过多久，就迅速的变成各大发行版的默认桌面环境。

GNOME的目的是提供一个完全自由的桌面。通过使用完全GPL的Gtk进行开发，GNOME规避了KDE可能遇到的潜在风险。为了应对这件事，Troll Tech宣布Qt以GPL许可发布。Qt正式开始了GPL和商业授权的双授权模式。可以说，Qt采用GPL协议后，GNOME一下子失去了靶子（重新创建一个完全自由的桌面。）。而Qt最后被Nokia收购的时候，更是采用了LGPL协议发布，连开发商业软件都不再需要购买授权了。

重重危机下，也许是GNOME推出Gnome-Shell寻求差异化的原因吧！

GNOME-Shell 和其他桌面有一个显著的不同点：GNOME-Shell即是窗口管理器又是面板。传统上，窗口管理器和面板是2个独立的进程。但是GNOME认为窗口管理器的任务是管理窗口，面板的任务之一
就是启动和切换窗口。窗口管理和面板是桌面环境非常重要的两个部件，最好还是纳入一个进程统一指挥吧！于是就有了GONOME-Shell。

GNOME-Shell一开始就提出了一个其他桌面项目想都不敢想的事情：强制要求机器支持OpenGL加速！ 这可真够大胆的。GNOME基于如下考虑：

\begin{enumerate}
\item 为了用户体验，更为了让应用程序开发者能专注于一个平台，强制要求支持OpenGL加速，使得为Gnome设计的程序可以假定硬件加速总是存在的而无需担心没有硬件加速。简化应用程序的开发。
\item 混合管理器一直存在，是的窗口“半透明效果”总是能实现\footnote{窗口的透明度是一种指示给窗口管理器的属性。只有带混合功能的窗口管理器才能实现半透明效果。半透明效果无法在应用程序自身实现。}。类似的必须依赖混合管理器的功能还有“窗口阴影”、淡出淡入。可以保证一致的用户体验。
\item 启用用户体验更好的桌面效果。并保证任何Gnome桌面都有这些效果，带来用户体验的一致性。
\item 强迫上游开发者修复硬件驱动问题。其实这个也很重要。GNOME-Shell刚推出的时候把原本很多没有暴露的驱动问题都暴露出来了。而且驱动开发者因为GNOME-Shell也显著的提升了驱动的质量。
不管是开源驱动还是闭源驱动，都因为GNOME-Shell的到来大大的提升了驱动的质量。

\item 话说，现在硬件上不支持 OpenGL 的电脑已经是古董中的古董了吧。基本都是驱动问题导致的不支持硬件加速。所以说，GNOME让社区想明白，专注于眼下需要支持的硬件。减少无畏的人力资源浪费。
\end{enumerate}



\section{办公和打印}
\subsection{LibreOffice}
\subsection{使用CUPS打印文档}
\section{声音的那些事}
\subsection{声音的数字编码}
\subsection{逐渐被遗忘的OSS声音架构}
\subsection{ALSA高级Linux声音架构}
\subsection{PulseAudio优秀的声音服务器}
\subsection{播放器}

\section{Wayland}

X确实是一个优秀的架构。如果说他有什么缺点，那就是它老了。真的老了。单是第11版\footnote{1987年发布的第11版X协议。}X协议也已经拥有超过25年的历史了。很多当年没有考虑到的、
或者不能考虑的技术，现在都已经变成理所当然的普遍了。

\subsection{X的局限和扩展}

随着Linux桌面的发展，X暴露出来的第一个局限性就是硬件加速。硬件加速通过DRI比较完善的被解决了。DRI绕过了X11协议让图形程序直接操作图形设备。给X11开了第一个洞。
（不过 DRI 只用来实现了 OpenGL， 并没有将一般的X绘图API交给DRI实现。）

Linux桌面的第二个发展是出现了“混合窗口管理器”。混合管理器和DRI天生就是一对矛盾体。

\begin{insertnote}

混合管理器的实现依赖于X的一个特性：窗口管理器可以指示X Server将一个窗口的绘图操作进行重定向。混合窗口管理器将普通程序的窗口操作重定向到位图上，然后将不同窗口的位图图像“合成”到屏幕上。因为一般窗口的绘制依赖于X协议中的绘图指令。
X Server很简单的就能实现绘图操作的重定向。可是遇到了DRI这个事情就范了难。一个使用OpenGL直接渲染（ 间接渲染依然使用X协议来传输OpenGL命令，所以和混合管理器不冲突的。）
的程序，其窗口的内容是由它自己直接绘制的，并没有经过X Server。 这样混合管理器按照道理来说是不能获得直接渲染的窗口的内容的。就算能获得，混合管理器也必须知道窗口内容“变动”，以便更新屏幕内容。
跟糟糕的是直接渲染的窗口并不能使用重定向功能！
\end{insertnote}

为了解决这个矛盾问题，X11加了一个Composite扩展。允许窗口管理器追踪使用直接渲染技术绘制的窗口变化。并且允许直接渲染的窗口使用重定向功能绘制到一个缓冲区上。

这就是DRI这个洞的补丁了。

随着Linux发普及，人们自然希望程序的“字体”能漂亮些。原有的X协议定义了一套核心字体。但是第一不支持UNICODE，第二不支持矢量字体。于是X又修补了这个漏洞：添加Xft扩展。

Xft允许在X中使用truetype字体。不过在X中配置truetype字体相当的麻烦。首先要在 /etc/X11/xorg.conf 中配置存放字体的文件夹路径，然后每个字体文件夹下都要 font.dir 和 font.scale文件。更要命的是，添加了字体需要\textbf{重启X}才能使用。所以这个补丁补的也不怎么好，导致大家更乐意在程序中自己管理和渲染字体，而不使用Xft扩展。

接下来X打的一个补丁理解起来就比较费力了。这个扩展名字叫 XRender。

XRender的出现源自两个事实：一是应用程序越来越不喜欢直接使用Xlib中“点”、“线”等基本图形的绘制API去绘制复杂图形了，而是采取直接“贴”图的办法。这个图可能是预先绘制好的图片（图标等资源），
也可能是其他软件生成的——比如FreeType2库渲染而成的文字，还可能是其他的绘图API生成的图片——比如cairo。二是贴图的时候希望能使用Alpha通道合成——半透明效果。

X在设计之初就考虑到了各种绘图需求。除了提供点线面绘图之外，还允许使用像素图。X程序可以使用自己任何最合适的方式生成象素图片，然后贴到窗口上\footnote{XPutImage(3)}。
这样单纯的点线面不足已绘制复杂图形的时候还有这一个API可用。现代的X程序已经不使用X提供的XDrawString(3)绘制字体了，而是使用Freetype2这样的库，在内存中绘制要一个字符的像素图然后贴到窗口上。不过问题就出在这里。我们知道矢量字体要想绘制的好看必须开启“抗锯齿”功能。

%TODO： 
加一幅抗锯齿示意图片

因为抗锯齿，线的边缘一些像素就要“灰度化”。灰度化本身并不会导致Xrender的催生。关键的原因是：这个灰度化并不是颜色灰度化，而是透明值。
在纯白的背景上以kang锯齿的方式绘制一条黑色线段。边缘像素会灰度化。事实是，这个灰度的像素仍然是黑色的，只不过增加了透明度，在白色背景下看上去是灰色颜色。使用透明值而不是像素本身个的颜色，在非白色背景下才能混合为正确的颜色。

那么，知道抗锯齿是在边缘像素使用透明值实现的。如何绘制呢？就拿字体渲染为例。字体通常是绘制于白色背景，但是也有例外。所以绘制好的字体图片是包含透明通道值的。背景部分全透明，边缘部分像素是半透明的。接着应用程序将渲染好的字体图片贴到窗口上（通常来说，背景是白色的）。这样边缘就会出现灰度化的抗锯齿效果。

%TODO: 
加两张示意图

也就是说，绘制带透明通道的图片的时候，是需要执行“Alpha混合的\footnote{Alpha混合是指两个像素混合为一个的时候，被叠加的像素使用叠加像素的透明值混合成新的颜色。而非Alpha混合，就是使用新的像素覆盖掉老的像素。}”。老式的X协议并没有提供Alpha混合。XPutImage是不接受带Alpha通道\footnote{计算机图形学中，称保存像素透明度的存储空间。}的图片的（或者说忽略Alpha通道。）。

应用程序有一个绕过这个限制的办法，就是使用XGetImage(3)首先获得目的像素，然后自己执行Alpha混合，最后将混合结果交给X。

听上去是一个解决办法，这也正是Xft使用的办法。但是问题就在X是网络协议，这样会导致X程序和X Server之间来来回回的交互数据，在网络延迟很大的时候，有严重的性能问题。

解决这个问题的补丁就是XRender。XRender扩展给X Server添加了Alpha混合功能。

%TODO

XRender模式示意图

XRender出来是补XPutImage的缺陷的，而XPutImage本身就是用来补X的绘图原的：原自80年代的绘图方式：点，线段，椭圆，圆形，矩形。这种绘图形式现如今已经没有哪个X程序还在用了。
都使用Cairo（或者相同功能的库）这样的矢量图形库了。Cairo提供非常丰富的API用来绘制图形。而Cario并不使用X的绘图API，而是自己进行光栅化，最后使用XRender绘制到屏幕上。


\subsection{渲染库和静态链接}

X是一种网络透明的协议。为了能实现远程显示，X除了定义一套窗口管理规则，还定义了一套绘图API。X的很多局限性都是从绘图这个功能层面开始暴露的。如果X只包含了窗口功能而没有绘图功能，事情会变得简单很多。

如果X没有渲染功能，渲染可以借助 OpenGL 这样的库进行。OpenGL的一个强大的优势就是它是硬件加速的。有人可能觉得简单的二维图形怎么使用OpenGL，那就大错特错了。OpenGL并不是3维专用的库。
2D可以认为是3D的一个子集。Clutter这样的一个库即是使用OpenGL构建的GUI库。Clutter本身就足以证明OpenGL绝对足够担当GUI的二维界面绘制的任务。

除了OpenGL，还有很多软件渲染库存在。cairo就是这样一个。所以，就算将图形绘制功能完全从X移除，GUI一样能跑的很好。事实上这件事情已经发生了。X目前为止还在被使用的绘图API只剩下了一个：XRender。
其他的API包括X提供的字体渲染都已经没有人再使用了。我更乐意将XRender定义为Buffer提交。由应用程序使用各种绘图库绘制界面，然后将绘制好的图形提交给X Server。

那么X就只有窗口管理功能还在被继续使用了。不过，如果将渲染功能从X中移除，是做不到的。移除了就不再是X了。要声称自己是X Server就必须支持已经没有人使用的功能。这给X Server的维护带来了严重的负担。我们不禁要问：

\begin{center}
X协议设计之初为何要包含绘图功能呢？
\end{center}

这个问题的回答还得回到80年代初。没错，当时的一个技术限制导致了X不得不设计成 C/S 结构并在核心协议中包括绘图操作。

仔细回想一下，一个渲染库要包含各种绘图指令，并且有可能的话还能利用使用硬件加速，必定是一个庞大的图形库。如 310.19 版本的NVIDIA驱动，其OpenGL实现\footnote{/usr/lib/libnvidia-glcore.so.310.19}庞大到有35MB之巨！ 
虽然这个例子有点极端，但是这正证明了一点，图形渲染事一件复杂的事情。复杂的事情就需要更多的代码实现。

虽然 X 是个窗口系统，但是从代码数量上看，管理窗口用的代码远远少于窗口渲染的代码。

那么回过头来，80年代初的一个技术限制，就是“代码共享\footnote{其实就是动态链接库啦！}”技术远未普及到今天这个地步。缺乏“代码共享”技术，意味着所有使用图形界面的程序执行期
都必须在内存中载入一份图形渲染代码——这就是静态链接的弊端。这是对内存和磁盘空间的极大浪费。其次，如果渲染库升级了，使用它的程序必须全部重新编译链接以享用新的库带来的改进——功能上的和性能上的。更糟糕的事情是，如果你的程序要放到不同的硬件上执行（使用了不同的显卡）就必须要将为不同显卡编写的代码全部包含进去！最糟糕的是已经编译好的程序将无法使用新的硬件！

想象一下：libGL 这个库是由显卡驱动提供的。如果这个库是静态链接的，意味着你要么为不同的显卡链接不同的库生成不同的程序为客户使用\footnote{话说当年DOS平台的一些游戏就是这么干的。要分不同的显卡插入不同的磁盘进行游戏。}，要么就得找到一直办法同时将所有的厂商提供的OpenGL库链接到同一个程序中。


在没有动态链接库的时代，要想共享渲染库就只有一个办法了：使用C/S结构。C/S结构下，应用程序链接到一个比较小的“转发库”，转发库将所有的绘图请求通过
网络协议发送到一个“渲染服务程序”，由渲染程序代为执行。只要协议统一了，可以为不同的硬件平台编写不同的渲染程序。而一般的图形应用程序就可以不需要重写。
这个转发程序比较小，所以静态链接也没什么问题。听起来是不是很熟悉？\textbf{这也正是X所使用的结构！}

\subsection{混合}

即便是说“X本身的渲染功能，不用就不用吧”，还有一个麻烦事情摆在X的面前。

\chatu[scale=0.7]{x-architecture}{一个X事件的处理}

顺着图\thefigure{}标记的序号，一个输入设备事件首先被内核的evdev驱动层捕，然后发送到X Server。接着X Server\textbf{判断这个事件应该属于哪个窗口}并将事件转发给相应的X Client，如图中\textcircled{\oldstylenums{2}} 所示。接着X Client对事件响应，绘制界面变化来做这一响应，\textcircled{\oldstylenums{3}}所示。

本来X Server这个时候只需要再将X命令解析了执行了，把绘制好的图形叫到显卡即可。
但是因为混合窗口管理器的缘故，这个时候X Server还不能这么做，它要给混合窗口管理器发送通知告诉它窗口内容变更了，如图中\textcircled{\oldstylenums{4}} 所示。
混合窗口管理器获得窗口内容更新事件，要重新向X索取新窗口的内容，然后执行混合（Composite）。
接将合成的整个屏幕的内容交给X Server，如图中\textcircled{\oldstylenums{5}} 所示。
最后X Server将混合窗口管理器绘制的屏幕内容呈现到屏幕上。

同一个内容被绘制了三次！第一次是在Client绘制的时候，该绘制被重定向到离屏缓冲区，接着X Server告诉混合窗口管理器代表该窗口的缓冲区内容变化了。混合窗口管理器读取缓冲区数据，将所有的窗口的内容执行一次混合，这是第二次绘制。
第三次绘制是窗口管理器将最终合成后的全屏内容交给X Server，X Server再次将该内容绘制到根窗口上\footnote{根窗口是一个全屏窗口，由X启动后自动创建。}。
%也就是说，X使用C/S结构并不是为了网络透明，而是没有动态链接的时候的选择。

在这里，还有一个潜在的问题暴露出来了。所有的窗口事实上都是隐藏的！你看到的窗口实际上并不是窗口，而是窗口管理器用实际窗口内容绘制的一个矩形区域。
窗口管理器创建了一个全屏的窗口，将所有其他窗口都重定向了。以致他们的内容是不会呈现于屏幕上的。一个窗口被用户看到的唯一途径就是被窗口管理器混合后绘制于它创建的全屏窗口上。

也就是说，如果窗口管理器对窗口做了一些“变形”处理...... 那么 X 将不会知道一个鼠标点击事件真正应该发送给谁！

TODO 添加一个图形描述
%TODO 

所以一旦窗口管理器这么做了，就必须接管X的事件判断。窗口管理器向X Server申请将所有的鼠标事件都揽给自己，然后自己进行判断鼠标事件到底该属于哪个窗口。再将该鼠标时间发送给对应的窗口（XSendEvent(3)）。

现如今，混合窗口管理器接管了越来越多的X本身应该做的事情。为了执行正确的混合，窗口管理器也在内部维护了窗口位置关系。为了“被变形的窗口”正确收到鼠标事件，窗口管理器也接管了
鼠标事件判断。不用说键盘焦点本身就是窗口管理器维护的。X的输入功能已经沦落为一个“形式过程”，真正的维护都交给了窗口管理器。

而窗口绘制（且不说窗口系统根本就不应该包含这个功能）这个功能X也早就保不住了。就连最后“将多个窗口的内容正确的执行‘裁剪’最终呈现于屏幕上”这个功能，也早就被混合窗口管理器接管了。

X剩下的唯一能做的事情,就是一个消息中转站：用来连接窗口管理器和X Client。

说到这里，有人觉得，既然X所有的事情越来越多的被窗口管理器接管，并且有的事情也通过“直接渲染”不再需要X Server进行而是X Client直接进行了，那么让X Client直接和窗口管理器通信，踢开X Server怎么样？

\subsection{窗口管理器做为Display Server怎么样}

这个“让窗口管理器成为X Server”的想法，最终的结果就是导致Wayland项目的诞生。

\chatu[scale=0.7]{wayland-architecture}{Wayland结构}

在这个架构中，因为移除了X Server，同时也意味着移除了X Client通常使用的渲染方式。但是Wayland Client可以使用在X时代就存在的一直渲染方式：直接渲染。
应用程序使用 OpenGL 或者它认为最合适的库进行直接渲染。
然后将渲染好的窗口内容——可共享的缓冲区——通过wayland协议提交给compositor。传输的是一个共享缓冲区的引用\footnote{需要显卡驱动的支持。目前开源的显卡去的都支持，不过闭源的NVIDIA和ATI驱动没有提供支持，只能可以使用共享内存来共享这个缓冲区，有性能损失。}，而不是数据本身，所以非常快，无需当心性能问题。compositor直接使用这个缓冲区执行合成然后将最终结果直接绘制到屏幕上。

Wayland是一个纯粹的窗口管理协议，没有渲染功能。应用程序需要使用其他的渲染库绘制窗口内容。然后将绘制好的窗口内容提交给Compositor。

Wayland被誉为Linux桌面的未来。Wayland移除了X Server同时也移除了X的C/S结构带来的性能损失。Wayland结构下，窗口管理依然是C/S结构。由Wayland Compositor负责管理窗口。
但是最影响性能的渲染部分，则完全使用了“直接渲染”技术，彻底摆脱X的性能禁锢。

Wayland在桌面上还是一个非常试验性的项目，但是在嵌入式领域，已经开始应用了。影响Wayland在桌面环境应用的主要原因，就是驱动和旧的X程序。
Wayland通过XWayland来兼容旧时代的X程序。而驱动问题则是任重道远。

\begin{insertnote}
\subsubsection*{XWayland}

没有规定X Server必须以真实显卡硬件作为输出吧，如果X Server本身成为Wayland Client呢？由于Wayland使用的是直接渲染，意味着X实际上还是直接控制显卡执行渲染的，所以旧有的X驱动只需要稍微进行修改即可支持Wayland。而且不存在性能损失。
对于驱动没有Wayland支持的情况，还有 “shmwl”这个伪X驱动。使用软件渲染然后使用共享内存提交给Wayland。

\end{insertnote}

Wayland需要驱动支持，因为旧时代X使用的是用户空间的驱动。而Wayland不能使用X的驱动。所以所有的X驱动都不能使用。幸好DRI将大部分驱动拆分成了DRM内核模块和Mesa两个部分，
所以Wayland目前只能使用有DRI支持的显卡：也就是 intel 显卡。NVIDIA和AMD的显卡必须使用开源驱动才能使用Wayland。以为前文说过闭源驱动虽然也支持直接渲染，但是并不是DRI结构的。

目前Qt 和 Gtk 的已经实现了Wayland支持。应用程序稍作修改甚至不做修改即可支持Wayland，只要驱动问题解决了，Wayland还是能够普及开来，替换掉过时的X的。
