

UNIX的哲学到底是什么？UNIX的哲学一言以蔽之，就是：\chatu*{kiss}{KISS}


UNIX无处不在，生命力顽强。从1969年诞生的那一刻起，没有人想到它会如此成功。得益于C语言，UNIX以其绝佳的可移植性轻松的被移植到各种类型的机器上。小到各种移动设备，达到超级计算机，UNIX都能在这些设备上畅快的运行。恐怕没有哪个操作系统能像UNIX那样拥有持续40多年的生命力。UNIX不仅存在于UNIX操作系统本身。许多非UNIX系统都能找到UNIX的影子。


%TODO:  主要的系统管理思想和一些小工具也在这里介绍，比如 ps grep 用户和组，用户权限的概念也在这里讲解

\section{一切都是文件}

这是最明显的一条UNIX设计哲学了。通过将一切设备抽象为文件，就可以使用统一的方法去操作设备。不管设备是磁带机也好，猫也罢，都使用同样文件操作。唯一不同的，也只有操作的设备文件名不一样而已。彻头彻尾的反UNIX，就是将设备和文件系统隔离。

\begin{example}{备份 MBR}

在 Linux下，第一个磁盘的设备文件是 /dev/sda , 第二个磁盘的设备文件是 /dev/sdb 
要备份第一个硬盘的 MBR ,可以使用  dd 命令。

\begin{code}
dd if=/dev/sda of=mbr.bak bs=512 count=1
\end{code}

使用这条命令就可以把硬盘的第一个扇区备份到 mbr.bak 文件了。对于其他的UNIX系统，只有对硬盘设备的命名不一致而已，没有其他区别。

而彻头彻尾的反UNIX，就需要使用特殊的备份MBR/分区表的“工具”。
\end{example}


\begin{example}{查看硬扇区}

直接查看硬盘的扇区，就和查看一般文件没有任何区别。使用二进制编辑器打开磁盘设备就可以了。
如果只是为了查看一下，还有个非常方便的工具：\textbf{hexdump}

\begin{code}
hexdump /dev/sda
\end{code}

这条命令就可以把第一块硬盘的扇区数据直接显示到屏幕上，按Ctrl-C终止。想屏幕不要快速滚动的话，请仔细阅读下面的章节，你会找到办法的。

而彻头彻尾的反UNIX，就需要使用特殊的查看磁盘扇区的“工具”。
\end{example}

从两个例子可以看出，UNIX将硬盘看作一个普通的文件（只不过文件大小固定为磁盘容量）。像这样的设备文件UNIX将他们组织起来统一放到/dev目录下面。
/dev 目录下的文件一度是由内核进行管理的，不过Linux后来放弃了内核管理/dev的办法而改为由一个叫udev\footnote{udev最后被systemd合并。}的程序进行管理。


\section{鼓励程序间协作}

UNIX鼓励短小精湛的程序，不鼓励编写大而全式的程序\footnote{据说是因为当年PDP-7内存有限}。正是因为UNIX鼓励短小的程序，并相互配合，所以创造了无穷的灵活性。
UNIX通过组合各种小程序，能发挥出各个小工具独立工作的时候不能完成的功能。

实现程序间协作的最伟大的发明就是\textbf{管道}。通过管道，一个程序的输出可以变成另一个程序的输入，将多个程序进行串街------每个程序变成这条处理链上的一个\textbf{过滤器}------组合的这些工具能产生工具的开发者都没有预料到的功能。

\chatu{Douglas-McIlroy}{管道发明人 Malcolm Douglas McIlroy}

图\thefigure 为管道发明人Malcolm Douglas McIlroy。 \chatu[width=\textwidth]{pipe-draft}{管道} 图\thefigure 为他发明管道的时候提出的建议的打字稿扫描图片。

管道能够让你用简单的程序去构 造更复杂的程序。管道能够以意想不到的方式去使用命令,管道使得你可以用更简单的方式去实现复杂的功能。
UNIX简单就是美的设计哲学，让管道这种强大的功能简单到只需要使用“|”就可以实现了。

\begin{example}{还是查看硬扇区}

前面说过，直接查看硬盘的扇区，只要执行如下的指令：
\begin{code}
hexdump /dev/sda
\end{code}

想屏幕不要快速滚动的话，并不需要修改 hexdump 程序添加滚屏功能。这个功能只需要交给一个专门为\textbf{滚屏}而开发的程序: less。

只要执行这样的命令就能实现一次查看一个屏幕的内容。还可以向上回滚。
\begin{code}
hexdump /dev/sda | less
\end{code}

less 的功能就是将自己的输入以一个屏幕的内容显示，超过屏幕能显示范围的内容要等用户使用滚屏命令（PageUp PageDown 空格键和回车键）让less滚动到用户想要观察的位置。

如果我不太喜欢 less 提供的功能，我还有more呢！
\begin{code}
hexdump /dev/sda | more
\end{code}

more和less在功能上大同小异。

而彻头彻尾的反UNIX，就需要给所有有需要的程序添加滚动屏幕的支持。

\end{example}

UNIX鼓励程序之间通过管道或者其他IPC（Inter-Process Communication 进程间通信）进行协作。这样一个程序就可以专注于本质工作，不需要为了“多功能”而开发庞大复杂的软件。这就引出了下一个我要讲的UNIX哲学。

\section{一个程序只做一件事情并把它做好}

UNIX鼓励程序间的协作，一个程序只需要专注于本职的工作，并做到最好。UNIX下有各种简单的工具。但是这些简单的工具却将自己的本质工作做到了最好。
所以UNIX下通常不会有功能繁多，大而全式的软件。但是你有非常丰富的功能单一却很强大的小工具，并拥有将工具进行组合的能力。

而彻头彻尾的反UNIX，让每个软件都倾向于包含你可能用到的一切功能，试图提供一个“家长式”的程序。

\begin{example}{下载工具wget}

wget 是一个命令行下的下载工具。wget功能非常明确，http/ftp 下载。使用起来也非常简单
\begin{code}
wget [url]
\end{code}
但是wget做到了一件事——下载——并将它做最好。
但是，如果给你的是一个下载文件列表，wget可不会去支持它。这是和下载无关的功能。但是，你能通过组合命令实现：
\begin{code}
cat urllist | xargs wget
\end{code}
在这里，我们又利用了一个名字叫xargs的程序，xargs的程序功能很简单，就是接受标准输入，为每个输入的字符串作为最后一个参数调用一次指定的命令。
cat 是个功能非常简单的程序，将文件打印到标准输出。这个标准输出被\underline{\textbf{管道}}重定向给了xargs做为标准输入。

这个命令组合后的结果就是：为urllist里列出的每个url调用一次wget进行下载。自然也就是为wget实现了“下载文件列表里的url”的功能了。
\end{example}

UNIX就是因为提供了管道这种强大到底协作工具，所以得以鼓励开发各种功能单一的精湛的小程序。而功能单一的程序大大简化了软件的开发，也使得UNIX下的软件质量非常高。

\section{使用文本流，因为这个是通用的协议}

如果说，UNIX鼓励编写功能简单的程序，必定是因为它提供了程序间协作的机制，而要利用这样的机制，程序间唯有使用统一的协议才能实现正确的协作。
这个统一的协议就是文本流。

UNIX反对使用专有的二进制格式。UNIX天然的支持流格式\footnote{一个接着一个的字节}，连文件都被看成是无格式的字节流。
因为输出不仅可以被管道送给另一个程序处理，更有可能会直接打印到终端。
所以对于输入输出，UNIX更是鼓励文本字节流，也就是只使用可打印的\footnote{26个大小写字母，0到9阿拉伯数字，标点符号，空格和换行}文本字母。并且将这种文本用于进程间的通信。

\begin{example}{文本协议HTTP}
目前广泛使用的HTTP协议就是一个文本协议的例子。

比如你访问 \url{http://www.example.com/example.html} ， 浏览器连接到 www.example.com 主机的80端口，发出一个
\begin{code}
GET /example.html HTTP/1.1
\end{code}
请求。服务器收到后，如果找到了example.html文件，就返回
\begin{code}
HTTP/1.1 200 OK
\end{code}
并空1行后紧接着输出example.html文件的内容。

要模拟浏览器的请求，可以使用\textbf{telnet}这个程序。
\begin{code}
\#telnet  www.example.com 80\\
Trying \st{***.***.***.***}...\\
Connected to www.example.com.\\
Escape character is '\textasciicircum'.{ <--  \it 以上为telnet输出 }\\
GET /example.html HTTP/1.1 { <--  \it 自己输入的，输入后敲两下回车 }

\\

HTTP/1.1 200 OK\\
Date: Wed, 19 Sep 2012 15:41:40 GMT\\
Content-Length: 31\\
Content-Type: text/html; {  <-- \it 下面有一行空行}

\\

<html>hello example.com</html>

Connection closed by foreign host. <-- \it telnet输出
\end{code}

可以看到，HTTP协议使用文本模式进行通信。服务器的回应也是文本流。而且是行模式，没条信息存放一行。如果有多个信息，可以多行存放。HTTP协议没有规HTTP头的大小，HTTP头和传输的内容之间使用空行隔开\footnote{这就要求HTTP头本身没有空行。}。

\end{example}

除了HTTP，互联网上常用的协议，比如FTP、SMTP\footnote{发送邮件用的}、POP3\footnote{用于客户端从服务器接收邮件}都是基于文本的协议。
HTTP这种只有HTTP头是文本，后续发送的文件内容（尤其是二进制文件来说）是字节流。但是SMTP全程连接使用的都是文本。对于发送不可打印的字符（比如以一张图片作为附件），SMTP需要将二进制字节流转化为文本格式。这是文本协议的一个缺点。

但是瑕不掩玉，文本协议的好处有很多，比如可以无限扩展。

还是拿 HTTP协议来说（方便起见，我没有设计HTTP请求的二进制版本。）。刚刚访问 www.example.com获了example.html。该文件有31个字节长度，HTTP头中的信息Content-Length: 31也告诉了我们文件大小。如果是二进制协议，一般会设计使用一个32bit的整数代表返回的文件大小。如果需要处理很大的文件，协议恐怕需要使用64bit长度的整数。但是对于64bit都无法表示的文件怎么办呢？ 二进制协议始终有扩展性不佳的问题。如果是HTTP协议，不管文件多大，只要这个数字还能表示出来，就没有问题。

我们可以看到， HTTP 返回的除了文件大小，还有文件类型等信息，如果是二进制的协议，大概会如图 \ref{fig:binhttp} 这么设计，其中每个方块代表4个字节。要传输的文件紧挨着HTTP头的后面。

\chatu[width=0.2\textwidth]{binhttp}{二进制的HTTP协议，服务器返回部分}

每个类型的信息都分配了固定的字段。解析起来非常快，似乎够用了

等等，我还要添加个信息，表示这个文件该不该被缓存。如果这个文件是临时文件，我大概不希望浏览器将它缓存，而是每次都到服务器上获取文件内容。
好吧，我再添加个字段。

\chatu[width=0.2\textwidth]{binhttp2}{二进制的HTTP协议，服务器返回部分，版本2}

等等，已经运行了的大批服务器和浏览器怎么办？由于文件紧跟着HTTP头，使用新的二进制HTTP协议的服务器碰上老版本的浏览器，缓存属性不仅是被忽略了，更被当做文件内容的一部分了。难道为了一个小修改需要为新的协议修改所有的浏览器和服务器么？

能无限的扩展并保持极佳的兼容性和人类可读性\footnote{测试问题的时候不需要特殊的工具去解析二进制流的各个字段，只需要打印出文本就可以了。}，是文本协议的最大优点。

\section{懒惰原则}

UNIX认为人的时间比机器的时间要宝贵的多。如果有什么事情是机器能代劳的，就绝对不要浪费人的时间。

这是 \textit{The Art of Unix Programming} 的《附录D》收录的无名师的传记，说明懒惰的人写脚本来解放自己的时间。我想没有比这个故事更能表达懒惰原则的含义了。

\begin{insertnote}
\subsection*{无名师与shell脚本}

无名师曾对来访的程序员说：“Unix传统上认为，一行 shell脚本胜过万行C程序。" 

这个程序员自以为对C极其精通，说：“这不可能。Unix内核正是用C实现的。” 

无名师回道：“确实如此。不过，Unix传统上认为，一行shell脚本胜过万行C程序。" 

程序员颇为沮丧：“但是在C中我们可领会到尊者Ritchie的智慧。我们与操作系统和机器合而为一，可以获取无与伦比的性能。“ 

无名师回道：“诚如你言。不过，Unix传统上认为，一行shell脚本胜过万行C程序。” 

程序员冷笑着想悲愤离去。无名师向学生Nabi颌首示意，Nubi在黑板上写下一行shell脚本，问道：“尊敬的程序员，看看这行管道。用纯C实现，是 不是要一万行C代码？“ 

程序员沉吟念诵。最终他承认如此。 

“你需要多长时间来实现和调试那个C程序?"Nubi问道。 

“很长”，来访程序员承认。“但傻子才会干这个而不去完成更有价值的任务。” 

“那么谁更了解Unix传统？”无名师问道。“是写一万行代码的，还是看到任务的无谓而不去编码的？” 

听到此，程序员眼中一亮。
\end{insertnote}

%这个原则我们将在 \ref{section:pkgmgr} \nameref{section:pkgmgr} 一节中讲解autotools的时候体会到。
无名师告诉我们，能用脚本完成就不编写程序。这是懒惰的原则，这是“宁花机器一分不花程序员一秒”的原则。这条原则对非程序员也适用的，就是\textbf{尽量编写脚本将自己的工作自动化。}

%而彻头彻尾的反UNIX，如果让每个软件都倾向于包含你可能用到的一切功能，试图提供一个“家长式”的程序。

\section{UNIX和非UNIX}
UNIX设计哲学并非只能在UNIX身上找到。只是有的系统只学了个表面。更有反UNIX而行之的。

UNIX管道自发明后，已经被各个操作系统借用，包括DOS和Windows都实现了管道。Windows/DOS依旧借鉴了使用|作为管道的办法。
\par\begin{notice}
事实上DOS是作为运行于8086芯片上的蹩脚UNIX开发的。树形目录结构（第二版开始支持）、命令行操作、管道，这些都带有深刻的UNIX影子。
DOS没学到的（受限于8086的能力也无法实现）：多用户多任务，丰富的IPC接口。
\end{notice}

%但是Windows下管道是如此的难用，以至于

UNIX“一切都是文件” 的思想也在许多的操作系统上实现。只是学的并不好。Windows下硬盘实际对应文件为 \texttt{\textbackslash\textbackslash.\textbackslash{}PhysicalDrive1} 第二块硬盘最后一个数字为2。但是这样的文件是无法在文件管理器里看到的。
而且也不能作为文件名使用一般的程序打开。

UNIX使用轻量级进程，进程的创建开销非常小。鼓励开发多个小程序并使用IPC相互协作。
其他系统也实现了多进程能力，但是进程的创建开销（相对UNIX来说）非常大，因而总倾向于使用（便宜的）进程内通信------将当个的程序做的非常大，使用复杂的API进行内部通信。而这些都是BUG的温床。

UNIX鼓励使用文本作为协议。就连配置文件都是（带格式的）文本文件。而有些系统使用专有的二进制格式数据文件保存配置。一旦配置文件损坏，系统就无法使用简单的文本工具进行修复。甚至因为系统本身无法启动而不能进行修复。
