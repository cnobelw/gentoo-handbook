% !TeX spellcheck = <none>

\newcommand{\compileall}{def}


\documentclass[amstex,twoside]{ctexbook}


\usepackage{marginnote}

% 16开本
\usepackage[
		paperwidth=195mm,
		paperheight=271mm,
		%装订线宽10mm,页边距 28mm
		inner = 38mm,
		outer = 28mm,
		tmargin = 36mm,
		bmargin = 30mm,
		marginparwidth=2cm
	]{geometry}

\usepackage{needspace}
\usepackage{wrapfig}
\usepackage[below,section]{placeins}
\usepackage{color}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{soul}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{xltxtra}
% always load hyperref as last packages
\usepackage[colorlinks,linkcolor=black]{hyperref}
%\usepackage{todonotes}


%\input{draftcopy}

%=====================================================================================
% font setting
%=====================================================================================
\input{setfonts}

%=====================================================================================
% define new command and environment 
%=====================================================================================
\renewcommand*{\marginfont}{\color{red}\scriptsize}
\newcommand*{\todo}[1]{\marginnote[%
\color{blue}\footnotesize%
TODO:#1%
]{%
\color{blue}\footnotesize%
TODO:#1}
}

\definecolor{gray}{cmyk}{0,0,0,0.2}

%=====================================================================================
% define new command and environment 
%=====================================================================================
\newenvironment{notice}{\tt}{}
\newenvironment{insertnote}{ \ttfamily\CJKfamily{KaiTi} }{\vskip 0.5cm }
\newenvironment{code}{\small\tt\begin{longtable}{p{0.8\textwidth}}}{\end{longtable}}

\newcommand{\RTLpar}{% right-to-left paragraph alignment
  \leftskip=0pt plus .5fil%
  \rightskip=0pt plus -.5fil%
  \parfillskip=0pt plus .5fil%
}

\newenvironment{quotes}[2][0.55]{\pushQED{#2}%
\begin{flushright}%
\begin{minipage}{#1\textwidth}\begin{flushright}\noindent\it\RTLpar}{%
 \\------\popQED{}\end{flushright}\end{minipage}\end{flushright}\vskip 8mm }%

\newenvironment{filecontent}[1]{

\addtolength{\linewidth}{-\parindent}
\begin{minipage}{\linewidth}

\vskip 1ex

文件: #1

\vskip -2ex
\rule{\textwidth}{0.02pt}
\vskip -1ex

%\hline

}{	\end{minipage}}




\newcounter{lizi}[chapter]

\newenvironment{example}[1]{ \addtocounter{lizi}{1} \vskip 2.5ex \bf 例\hskip -0.05em\arabic{chapter}.\arabic{lizi}： #1%
\par %
 \tt\small\CJKfamily{zhfs}}{ \vskip 2.5ex  }

\newcommand{\theexample}{\arabic{chapter}.\arabic{lizi}}

\makeatletter\newcommand{\chatu}{\@ifstar%
                     \chatuStar%
                     \chatuNoStar%
}\makeatother

\newcommand{\chatuNoStar}[3][scale=0.35]{%
\begin{figure}[htb]%
\noindent\centering%
\includegraphics[#1]{pics/#2}%
\caption{#3\label{fig:#2}}%
\end{figure}%
}


\newcommand{\chatuStar}[3][scale=0.35]{%
\begin{figure*}[!h]%
\noindent\centering%
\includegraphics[#1]{pics/#2}%
\label{fig:#2}%
\end{figure*}%
}


\newcommand{\faqref}[1]{~附录 \ref{chap:FAQ}.\nameref{chap:FAQ}~“\nameref{#1}”}
\newcommand{\secref}[1]{ { \it节\ref{#1}~\nameref{#1}} }

\newcommand{\chapref}[1]{ { \it第\ref{#1}章~\nameref{#1}} }


\newcounter{faqs}

\makeatletter
\newcommand\@publisher{}
\newcommand{\publisher}[1]{
\renewcommand\@publisher{#1}
}

\newcommand\@company{}
\newcommand{\company}[1]{
\renewcommand\@company{#1}
}
\makeatother


%=====================================================================================
% style settings
%=====================================================================================

% 阿拉伯数字章节
\setcounter{chapter}{-1}
\CTEXsetup[number={\arabic{chapter}}]{chapter}
% 对齐设置
\tolerance=4500
\punctstyle{hangmobanjiao}
\CJKecglue{}
\CJKsetecglue{} %{\hskip 0.1em plus 0.05em minus 0.05em}

%=====================================================================================
% book info
\input{bookinfo}
%=====================================================================================


\begin{document}

%=========================================================
% 首页
%=========================================================
{

\include{coverpage}
\include{thanks}
}

%=========================================================
%目录
%=========================================================
\tableofcontents

%=========================================================
% 序言
%=========================================================
\ifdefined\compileall
	\include{preface}
\else
	\addtocounter{chapter}{1}
\fi


%=========================================================
% 正文开始
%=========================================================

\ifdefined\compileall
\include{chp_unix}
\else
\addtocounter{chapter}{1}
\fi 

\ifdefined\compileall
\include{chp_hackerandlinux}
\else
\addtocounter{chapter}{1}
\fi 


\chapter{初识Linux}

\begin{quotes}[0.63]{The Gospel of Tux}
Now may you code in the power of the Source; may the Kernel, the Libraries and the Utilities be with you, throughout all Distributions, until the end of the Epoch. Amen. 
\end{quotes}

Linus发布他的内核的时候，Linux就只是一个内核而已。一个操作系统不当当依靠一个内核就能工作。还需要各种程序供用户使用。最少的，用户需要一个shell进行人机交互。
用户需要管理磁盘，管理他的文件。等等操作都需要依靠各种各样的程序进行。如果用户只是将Linux内核运行起来，那他将什么都做不了。所以用户需要的，是一个Linux内核和一套工具软件。这样的组合才能构成用户操作机器的环境——也就是说，一个操作系统。于是人们有时候简单的称呼这样的操作系统为Linux。但是我们得知道，这只是泛称，Linux的实际含义就是Linus和其他黑客开发的一个内核，并不是一个完整的操作系统。

由于Linux只是一个内核，所以用户需要的工具软件就需要向别的地方寻找了。所幸RMS宣誓的GNU已经开发的差不多了，就只差个名字叫GNU Hurd的内核。等等，我们不是有Linux内核了么？

没错！只要我们将GNU的系列软件和Linux内核搭配起来，不就有一个完整的操作系统了么？我们需要一个shell, GNU bash就是我们要找的。我们需要各种命令行工具， GNU coreutils就是我们要找的，我们需要编辑器，GNU emacs就行。我们需要开发工具编写自己的程序，GCC GDB GNU make等等就是我们需要的。 我们要的各种构成UNIX系统的要素GNU通通提供了。额，除了内核。所以RMS提议使用Linux内核+GNU userland\footnote{
前文提到过，UNIX需要CPU提供特权和非特权两个代码级别。内核的代码运行在特权级别。用户的程序运行在非特权级别。故而用户程序统称userland。}的操作系统应该叫做GNU/Linux。

那还等什么，赶紧到GNU的网站上下载吧！

\subsection{使用Linux内核的操作系统——发行版}
且慢！我还未拥有一个UNIX环境，GNU网站上提供的都是源代码，Linux也是源代码，我如何使用他们？编译？
那么我首先需要一个UNIX系统，并有一个能工作的编译器，才能编译这些软件吧！

这是一个先有鸡还是先有蛋的问题。

再说，就算我已经安装了一个Minix或者BSD系统，想编译出一个使用Linux内核的完整操作系统，也是一个巨大的工程吧！

俗话说，有需求的地方就会有市场。

于是有那么些人开始将Linux内核以及各种软件搜集到一起，预先从源码编译成二进制的可执行程序然后打包放到光盘上出售。并编写了方便的安装程序。只要把光盘塞入PC的光驱，跟着光盘里安装程序的提示一步一步做下去就能安装好一个完整的系统。

这种以Linux为内核的操作系统和其他的软件一起打包组合而成的套装就是发行版。


\section{发行版的意义}
当然，发行版的意义并不是简单的将软件打包和降低初学者的门槛哦\textasciitilde

第一：通过将大量的程序打包到统一的仓库，使得很多默默无闻的软件被显示到可安装软件列表上。增加了这些低调的软件开发者的潜在用户。虽然说用户多了开发者不一定有好处，但是光是想到有那么多人会用自己开发的软件，想想都觉得来劲不是么？

第二：许多软件特定版本的\emph{组合}可能会导致一些潜在bug。这些是软件开发者无从测试的。一个特定版本的发行版将基础软件的版本全部确定下来。只要保证这些版本的配合不会产生bug就可以了。由于用户使用发行版提供的软件，就减少了各种没有预料到的组合。所以在生产环境，随机的升级某个软件是非常忌讳的哦\textasciitilde。

第三：许多软件开发商形容Linux是活动的靶子。每过6个月\footnote{Ubuntu每6个月发行新的版本。}，系统各个软件都版本大换血。原先测试好的软件活不过6个月——下一个版本出来就出各种问题了。但是开源软件因为是发行版负责打包编译，所以可以避免这儿个问题。发行版维护者会及时发行某些软件因为另一些软件的升级而不工作了，通常简单的问题维护者自己就可以将错误修正——同时将修改回馈上游。开源软件可以放心的躲过每6个月一次的劫数——除了拒绝开源的。

第四：第三条提过，发行版积极的向上游回馈修改\footnote{咳咳，并不是每个发行版都那么好心。Ubuntu就曾经因为回馈不足引发舌战过。}。
有时候发行版回馈的补丁不仅是躲过6月劫数那么简单。一些发行版直接参与上游软件的开发，特别是和发行版结合紧密的软件。Fedora是RedHat赞助的社区发行版，默认使用GNOME桌面，而GNOME有相当一部分开发者就是RedHat雇员。


\section{包管理和软件仓库}

是什么东西促使一堆软件的集合变成了一个发行版呢？答案是包管理机制和围绕它建立的一个软件仓库。

\subsection{包管理}

人要用电脑，就免不了要安装软件。浏览器，办公软件，游戏等等。软件安装了，免不了要升级和卸载。
%人发行版需要

所有的程序都带上升级卸载程序，是个不错的主意，也是个愚蠢的主意。不符合UNIX的KISS原则。

符合KISS原则:
\begin{itemize}
\item 安装程序应该只有一份。
\item 所有的软件使用统一的方式安装，不能区别对待

\item 使用方便。提供直观间接的命令行或者图形界面。

\item 干净卸载。卸载不能留下任何不该留下的东西。所谓燕过不留痕。

\item 解决依赖问题。一个软件或多或少的会依赖其他的软件。最明显的例子，如果系统里没有安装libc，所有的软件都不可能运行。一个软件要想正常工作，它依赖的软件必定也要安装。　包管理要最终软件之间的相互依赖关系。安装一个软件的时候能将它依赖的软件也安装，卸载软件的时候能将依赖的软件（如果没有其他的软件也依赖它的话）一并删除。

\item 打包方便，不能方便了最终用户而是发行版维护人员痛苦不堪。

\end{itemize}

各个发行版使出浑身解数，开发了各种软件包格式和对于包管理器。比较流行的也就只有两个而已：RPM和deb。

\subsection*{RPM}

RPM是Redhat Package Manager的缩写，不过后来RPM被Redhat以外的发行版采用的，似乎RPM成了另一种缩写：Rpm Package Manager\footnote{吐槽吧，学的GNU啊。递归缩写}。

RPM格式的扩展名是.rpm，分源码包和二进制包。源码包将rpm规格说明文件（.spec）和程序源码打包为一个.src.rpm包（或者.srpm） 。源码包可以用来构建二进制rpm包。
要安装rpm包，使用rpm命令进行。具体使用请参考man手册。比较常规的用法我会在
%\secref{软件管理}　介绍。
第\ref{软件管理}章~\nameref{软件管理}介绍。

\begin{insertnote}
\vskip 0.5cm
man手册的用法很简单啦，打man后面跟个要帮助的命令，rpm就是
\begin{code}
\$man rpm
\end{code}
按q退出查看。PgUp和PgDown可以翻页。
\end{insertnote}

RPM被广泛使用，包括RHEL、Fedora、OpenSuSe、RedFlag都是使用的rpm包格式。

\subsection*{deb}

包管理世界的另一大流派是deb。deb因其所使用的软件包扩展名为.deb而得名。实质上是Debian的缩写。因为它是Debian专用软件包格式。
因为Ubuntu是Debian修改而来，自然也采用了deb包管理。

和RPM一样，deb也有源码包和二进制包。从源码包可以编译得到二进制包。要安装deb包，使用dpkg命令进行。具体使用请参考man手册。比较常规的用法我会在第\ref{chap:软件管理}章~\nameref{chap:软件管理}介绍。

\subsection*{ebuild}

Gentoo的ebuild严格来说并不是软件包格式。rpm deb之类的，可以直接安装对应的二进制包。包管理器检查包的依赖，依赖检查后将包里的文件解压安装到系统里就可以了。

Gentoo的ebuild却并不是这样的。ebuild大致是一个BASH脚本（不能直接执行，只能由包管理器调用）。Gentoo的包管理器通过执行ebuild完成“自动下载源码，解压，编译，安装”这样的操作。

%TODO
\todo{更多ebuild介绍}

\subsection{软件仓库}

发行版搜集了各种软件，并编译成二进制包。通常发行版收集的软件包数量以万计。这么多包是不可能一次性全部装到一张光盘上的。也完全没有那种必要。用户拿到光盘的那一刻开始软件就已经过时了。

如果将所有的包都集中存放到服务器上，用户要安装的时候直接到服务器上获取就可以了。用户获得的软件总能保证是最新的。只需要比较本地安装的软件版本和服务器上存储的最新版本就可以知道是否有更新了。

这样在服务器上集中存储的软件包就集合成了一个仓库。发行版的工作就是维护这个仓库，时不时的向仓库更新软件。

软件仓库可是个伟大的发明。乔帮主从Linux社区学到了软件仓库创立了App Store赚了大发。微软也开始学软件仓库的思想，据说Windows 8打算使用软件仓库。

限于仓库的格式问题，不同的发行版有不同的工具让用户访问软件仓库。

RPM系的发行版，使用yum\footnote{不要和rpm混淆哦！一个是安装软件包的，一个是访问软件仓库的。}访问仓库。用户可以下载　XXX.rpm 然后使用　rpm -i XXX.rpm 安装这个包，但是更便捷的做法是直接使用 {\tt yum install XXX} 安装名为XXX的软件。yum会到仓库里搜索XXX软件并将对应的rpm文件下载下来，如果有未安装的依赖，将依赖的软件也下载下来。然后调用rpm安装。

\begin{example}{Fedora下安装手写输入法}
手写，handwrite，搜索
\begin{code}
\#yum search handwrite
\end{code}

在结果页面，有个叫　ibus-handwrite的软件。ibus是一个输入法框架，自然ibus-handwrite就是手写输入法了。
开始安装（注意需要使用root帐号运行，参考\faqref{FAQ:su}）
\begin{code}
\#yum install ibus-handwrite
\end{code}
回答yes后ibus-handwrite就被安装到系统上了。
当然，前提是保证网络连接：）
\end{example}

要删除软件，使用 yum remove XXX.

对deb系的发行版，使用apt-get（俗称超级牛力）哦。基本用法和yum一致。apt-get install 安装软件，apt-get remove 卸载软件。
区别就是，yum是在线搜索，apt-get是离线搜索。你需要每天使用apt-get update（也不需要每天啦！
长久没用apg-get的时候先执行一下apt-get update就行了。）刷新缓存，
之后apt-get就使用本地缓存的软件包信息而不用每次都连接到服务器进行搜索。

另外，更新系统yum使用的操作是　yum update，而apt-get同样的操作用来更新本地软件包信息缓存了，故而更新系统在apt-get下使用的命令是apt-get upgrade。

而Gentoo这样的系统嘛，也有非常强大的工具：{\bf emerge}。emerge　XXX就可以安装名为XXX的软件。

\begin{example}{Gentoo下安装vim}
要安装vim非常简单，emerge就可以了
\begin{code}
\#emerge　vim
\end{code}
emerge会忠实的到vim的网站上下载vim的代码，解压，编译，然后安装。如果vim依赖的软件还未被安装的话，emerge会首先安装它们。

\end{example}

\subsection*{在仓库中搜索}

虽然仓库很好用，但是在用的时候大家都会有一个疑问：怎么知道一个软件对应的包的名字？

这就需要到仓库中搜索需要的软件了。搜索条件一般为软件的名字。通常软件包的名字和软件本身的名字一致。但也有例外。就拿glibc来说，在deb系里，它的包名是libc6。
这些问题都有历史渊源，说来话长，咱就不废话了。总之记住：软件包的名字并不总是和软件本身的名字一致。所以有时候需要搜索后才能安装。另外一个问题是，有时候我们只是希望安装一个“类型”的软件，比如想安装个画图软件，但是恰巧并不知道任何一款画图软件的名字。

针对这2个问题有两个办法。

第一个问题，属于特定发行版下的“软件包改名”问题。一般使用发行版的软件管理工具的搜索命令。以软件本身的名字作为关键词搜索即可。比如　yum search vim、apt-cache search sudo、emerge -s vnc。

第二个问题，命令行下无解。如果使用图形工具可以方便的浏览仓库中所有的软件。还是分门别类的哦！当然，最快的办法莫过于祭出伟大的Google。

\chapter{安装 Linux}

\begin{quotes}[0.5]{insomnia}
It only takes three commands to install Gentoo!
\end{quotes}

Linux介绍了那么多，是时候将它安装到我们的电脑上了。接下来要边安装边学习哦。要安装一个Linux系统，我们总是选择一个发行版来安装。那么到底选择什么样的发行版呢? 理想的发行版通常是这样的一个发行版：它非常第容易安装，非常的容易适用；软件仓库里的软件非常丰富，我可以用包管理安装一切软件而不需要自己手动安装；对于一些软件我希望能容易的进行定制；快，非常快。在对各个发行版做里权衡后，我选择Gentoo作为本书中介绍Linux知识所使用的平台。


\begin{notice}
 注意：Gentoo只是我们选择的众多发行版中的一个，我并不打算把本书变成一个Gentoo入门教程。如果这样，读者还不如选择阅读Gentoo官网上的手册。我尽量将所涉及到第知识通用化。如果这样的知识点只适用于Gentoo, 我会进行说明并辅之以其他发行版的等位操作\footnote{不同发行版达到同样的目的采取的不同操作。}。
\end{notice}

本书并不打算引起发行版之争\footnote{指不同的人使用不同的发行版，并常常在网上争论自己使用的发行版要比别人的优秀}，
但是又必须解释为什么使用了Gentoo这个非常罕见的发行版而不是同其他书本那样采用最流行的发行版，比如Ubuntu或者Red Hat系。

最直接的原因也许就是作者本身使用的就是Gentoo，以自己最熟悉的发行版写作，可以避免不熟悉系统进行错误的讲解\footnote{这确实是一个理由，但是Gentoo必定有比其他的发行版更值得作为本书的平台。}。
当然，如果仅仅这一个理由未免太牵强。
{ \it Gentoo可以让读者将精力放到学习Linux本身，而不需要关注发行版的细节，这就是我采用Gentoo的原因。}
另一个能做到这种效果的发行版为LFS\footnote{严格来说，LFS 算不上发行版，只是一个教你如何手工编译出一个能用的系统的手册。}（Linux From Scratch）。
但是LFS太繁琐，恐怕还没有学习到Linux的知识就已经中途放弃了。


\section{安装准备}

当然是准备一台电脑啦！Gentoo虽然号称为本机编译优化，但是编译本身非常耗费系统资源，所以一台主流配置的电脑是必不可少的！
\footnote{Gentoo支持的硬件架构非常多，不是一定要用个人电脑的。
但是作为初学者，我们就用最常见的个人电脑，不折腾各种稀奇古怪的电脑，最重要的是，Gentoo对x86体系也是支持的最好的（这不废话么，用户量摆那里么）。}


除了一台电脑，还要准备个Fedora或者Ubuntu的LiveCD\footnote{参考附录A. FAQ 的“什么是LiveCD”。
}，这里不推荐Gentoo自己的LiveDVD\footnote{同LiveCD。}，因为前者更容易获取和使用。

当然，还有网络。Gentoo虽然可以脱离网络进行安装，但是需要将所可能需要用到的源码提前下载，这是非常麻烦的。所以最好准备一个安装的时候可以访问的网络，也就是说LiveCD 环境里必须能使用网络。Fedora 或者Ubuntu那样的LiveCD 通常提供了完整的桌面环境，使用这些桌面环境的网络设置，让LiveCD 能访问互联网就可以了。你可能需要使用 NetworkManager 提供的图形客户端进行配置，通常是在桌面右上角的系统通知区域。要使用 NetworkManager 配置网络，请参考第6章的内容。

嗯嗯，不过就算是x86还分为x86\_32（ 没有特殊指明的情况下x86特指x86\_32） 和x86\_64\footnote{因为历史原因，AMD率先推出支持64位运算的x86CPU，所以Gentoo管x86\_64叫amd64，这和x86又被称呼为 i386 是一样的原因。}呢。
由于x86\_64是在x86的基础上发展起来的，所以x86\_64向下兼容x86。 也就是说，64位的CPU可以运行32位的软件。但是反过来就不行了。

既然存在两种x86，选择起来就费脑筋了。怎么知道自己的CPU是x86\_64的还是x86\_32 的呢？答案是，现在生产的CPU都是x86\_64了。当然如果你想准确的知道CPU到底支持不支持64位指令，在Window下你可以选择执行CPU-Z 软件获得CPU信息，如果是Linux就简单的多，在终端下执行lscpu命令就可以了。

（1）  Linux下使用lscpu：

在终端下执行lscpu，该命令的第一行输出就是CPU的体系结构。在我的电脑上，其输出为：

\begin{code}%
Architecture:        x86\_64\\
CPUop-mode(s):        32-bit, 64-bit\\
Byte Order:            Little Endian\\
CPU(s):                8\\
On-lineCPU(s) list:   0-7\\
Thread(s) per core:    2\\
Core(s) per socket:    4\\
Socket(s):             1\\
Vendor ID:             GenuineIntel\\
CPUfamily:            6\\
Model:                 42\\
Stepping:              7\\
CPUMHz:               1600.000\footnote{如果CPU支持动态降频，这里显示的是当前频率而不是CPU的标称频率。}\\
BogoMIPS:              6420.96\\
Virtualization:        VT-x\\
L1d cache:             32K\\
L1i cache:             32K\\
L2 cache:              256K\\
L3 cache:              8192K\\
\end{code}

第一行的Architecture:        x86\_64就表明此CPU的结构是x86\_64。


\vskip 1em
（2）  Windows 下使用CPU-Z：

\chatu{cpuz}{cpuz截图}
如图\thefigure所示。我红圈标注的EM64T表示CPU支持64位指令。对于AMD系的CPU，您大可放心，全部支持64位指令。


\begin{insertnote}
\subsection*{小插曲  64位 vs 32位}

如果是x86\_64的CPU，应该选择amd64\footnote{AMD64 就是x86\_64。}
的Gentoo还是x86的呢？既然现在的CPU都支持 64位指令的，为何还有那么多人使用 32 位的系统？

x86\_64虽然能执行x86代码，但并不是没有代价的。Windows下大部分现有的程序都是32位的，如果安装的64位Windows，32位软件并不能100\%兼容。而且所有的64位软件同时有32位的版本，所以Windows用户非但没有迫切的升级到64位系统的意愿，放而有为了兼容性考虑不得不安装32位系统的处境。

64位系统如果不执行64的程序，那性能还不如直接使用32位的系统和32位的程序。所以在 Windows 统治的世界里，64 位CPU的地位非常尴尬。32位CPU通过PAE\footnote{Physical Address Extension，物理地址扩展。允许32位CPU使用36位地址从而突破4G内存限制。}同样能获得 >4G 内存的支持（非服务器版Windows人为阉割32位版本的PAE支持，故而32位桌面版Windows不能支持超过4G内存。）。

大概也就是因为这个原因，所以不明真相的群众就以为64位除了支持大内存外一无是处。继续固守32位。64Bit vs 32bit的战斗因此打响。

x86\_64对x86的提升不仅仅是更大的内存，同时增加的有

(1)  更大的寄存器 64位CPU自然拥有64位宽度的寄存器。

(2)  更多的寄存器x86\_64相比x86增加了8个通用寄存器,增加8个MMX寄存器。

(3)  默认支持SSE\footnote{SSE指令是Intel为x86添加的扩展，加快了浮点运算的速度。}指令集。

(4)  更有效的指令编码。

这些都无形中增加了x86\_64指令编译的软件的运行速度。所以，如果你的CPU支持x86\_64，请必定选择x86\_64。
Linux上没有Windows上遇到的问题。
Gentoo下几乎所有软件都是本机编译的，自然不存在兼容性问题。
而个别非开源软件也多数拥有 64位版本，更不需要操心兼容性问题。
\end{insertnote}

好，我们列一个清单：


\begin{itemize}
\item[ \checked] 一台电脑
\item[ \checked] 一张LiveCD
\item[ \checked] Internet
\item[ \checked] 本书或者Gentoo 安装手册。
\item[ \checked] 耐心，很多很多的耐心
\end{itemize}

你准备好了么？

准备好的话，将LiveCD塞入光驱，开始一步步安装属于你的Gentoo吧。有关如何使用LiveCD请参考\faqref{FAQ:UseLiveCD}。
启动LiveCD，首先配置好网络环境，有关网络环境的配置请参考 \secref{sec:ifconfig}。


\section{shell 快速入门}\label{sec:quickbash}

由于安装Gentoo需要执行shell命令，所以我需要讲解一下最基本的shell命令。高级的shell操作讲解要到

机器只能接受二进制指令，可是人需要工作在更高一层。人希望直接提供文本形式的指令由机器执行。shell 是操作系统提供给用户的解释器。shell把来自用户的命令转化为机器指令并执行。

命令虽然是文本，但也不是自由格式的。计算机是死的，自然不能接受人类的语言，只能是比较固定的几个格式。

一条shell命令的最常用格式为:

\begin{code}
命令 [选项] [目标]
\end{code}

选项是可选的，可以有一个或多个；多个选项间用空格隔开；有些命令没有选项；目标通常是一个文件的文件名，或者目录名。
一行可以写多个命令，多个命令用“;”隔开。一个命令也可以跨行，在最后行尾使用  “\textbackslash”  即可在下一行继续写。


请看一个命令做为例子： 

\begin{code}
root@gentoo \textasciitilde \# ls -l --all /  
\end{code}
在这里：

\begin{itemize}
\item root@gentoo \textasciitilde \# 是shell提示符。\#是root账户，普通账户是\$。root@gentoo 表示当前登录用户为root,当前登录机器是gentoo,后面的 \textasciitilde{}　表示当前目录为　\textasciitilde{}，　\textasciitilde{}　在shell中表示用户主目录，也就是　\$HOME。root的主目录为 /root,　普通用户为/home/用户名。
\item -l 是一个短选项。短选项 “-”开头，后面跟单个字母。在这里 -l 表示以“长格式”列出。所谓“长格式”就是相对与一般格式，除了要列出文件名，好要列出文件所有者，权限模式，文件大小
\item -{}-all 是一个长选项。长选项使用两个“-” 开头，后面跟一个单词。在这里 -{}-all 表示列出所有 文件，包括隐藏文件。
\item / 在这里为操作对象参数，在这里是一个目录。表示要列出 / 下的文件。
\item ls 的所有参数都是可选的，如果不使用任何参数，ls 列出当前目录下的文件。

\end{itemize}

shell命令分两种，一种是内部命令，另一直是外部命令。内部命令是由shell直接执行的\footnote{最常用的内部命令是cd。}。
外部命令则是独立的程序。比如ls就是独立程序，它的路径为/bin/ls。shell使用一个PATH环境变量\footnote{参考附录A FAQ“什么是环境变量”。}来查找外部命令。

现在我们只需要知道shell最常用的命令形式就可以了。在以后的学习过程中，我会像大家介绍 shell 的其他命令格式，包括各种循环和函数使用。现在还要一个比知道更多的shell命令更重要的知识需要知道：
\begin{center}\em
shell字符串扩展
\end{center}

还是 ls 这个命令作为例子，假设当前目录下有“a.txt”“ab.txt”两个文件。执行下面的命令：

\begin{code}
root@gentoo \textasciitilde \# ls *.txt
\end{code}

结果就是列出 a.txt ab.txt 两个文件。

在这里：
\begin{itemize}
\item *.txt 会被扩展成 a.txt ab.txt
\item a.txt 和 ab.txt 被作为2个参数传递给ls。
\item “*”是通配符，表示匹配任意多个字符；“?”表示匹配任意的一个字符。

\begin{insertnote}
注意：shell的字符串扩展不仅仅支持*和?这样的通配符，更高级的用法将在后续章节将到。
\end{insertnote}


\end{itemize}


比如你执行的是下面这个指令：

\begin{code}
root@gentoo \textasciitilde \# ls ?.txt
\end{code}

结果就只显示a.txt文件。要取消shell字符串扩展，加引号即可，如下面这条命令：

\begin{code}
root@gentoo \textasciitilde \# ls "*.txt"
\end{code}

执行结果为：

\begin{code}
ls: 无法访问*.txt: 没有那个文件或目录
\end{code}


我们知道，ls *.txt 相当于 ls a.txt ab.txt，可是如果执行下面的命令

\begin{code}
root@gentoo \textasciitilde \# ls "a.txt ab.txt" 

ls: 无法访问a.txt ab.txt: 没有那个文件或目录 

root@gentoo \textasciitilde \# 
\end{code}

shell将“a.txt ab.txt”整体（不包含引号）作为了一个参数传递给ls了。

要理解shell的这种行为，首先要明白shell是如何传递参数给程序的。

\begin{insertnote}
\subsection*{shell如何传递参数给命令}

编写过C程序的同学都知道，C程序的入口点在main，main的原型为

\begin{code}
int main(int argc, char * argv[]);
\end{code}

argc为参数列表中参数的个数，argv是个参数列表。argv[0]是程序自己，argv[1]为第一个参数，依次类推。
参数是直接由启动该程序的操作系统传递进来的，不需要还调用什么函数来获得参数列表
\footnote{Windows下确实是调用GetCommandLine()获得参数列表的，由C语言启动函数（真正的入口点）负责获得参数列表然后调用main()。}。
操作系统知道调用该程序的参数列表是因为程序是由execv()系统调用加载的。原型：
\begin{code}
int execv(const char *path, char *const argv[]);
\end{code}
path就是要执行的程序。
argv的最后一个由NULL结尾，故而内核会知道有几个参数，转化为main里的argc。

\end{insertnote}

在本例中，
shell
启动ls程序的参数应该是这样的
\begin{code}
argv[0]="ls";\\
argv[1]="a.txt ab.txt";\\
argv[2]=NULL;

execv("/bin/ls",argv);
\end{code}

所以ls会把"a.txt ab.txt"（不包含引号）作为一个参数。也就是说，参数和参数之间的分隔是由shell完成的\footnote{Windows下的程序，参数和参数之间的分隔是C库的启动函数完成的。GetCommandLine()后分割命令行参数再调用main()}。


那么，shell进行字符串扩展和命令行参数分割的时候遵循的规则是这样的：

\begin{itemize}
\item shell进行字符串扩展的时候，只对游离的*和?进行扩展。如果*和？处于引号之内则不进行扩展。
\item shell以空格为参数分割的界限。但是对于使用*和?扩展出来的字符串，以文件名为界限。比如文件名内的空格不会成为分割的界限。
\end{itemize}


如果执行的是下面的命令
\begin{code}
root@gentoo \textasciitilde \#ls　*.txt c.txt
\end{code}

shell对命令解析的步骤是：

首先进行命令行字符串扩展，*.txt 扩展为　a.txt ab.txt；接着进行参数分割，这样就是3个参数: a.txt ab.txt c.txt；最后将这3个参数传递给ls。也就是执行下面的操作

\begin{code}
argv[0]="ls";\\
argv[1]="a.txt";
argv[2]="ab.txt";\\
argv[3]=NULL;

execv("/bin/ls",argv);
\end{code}

\subsection*{转义序列}

既然说过，空格作为参数分格符。如果用引号将带有空格的字符串引起来，则两个引号之间的所有内容都作为一个字符串。也就是说，那之间的空格就失去了分割参数的功能。
引号还可以用于避免字符串展开。功能如此强大，结果就是字符串本身如果就打算使用引号怎么办？shell将搞不清楚引号到底是代表这是一个字符串还是引号本身是字符串的一部分。

shell引入了转义操作。使用在字符串内部使用{\textbackslash\tt{}"}就可以表示这是一个引号。

\begin{example}{显示带 引号的字符串}
\begin{code}
root@gentoo \textasciitilde \# echo "你好引号{\textbackslash\tt{}"}"

你好引号"

root@gentoo \textasciitilde \#
\end{code}
\end{example}

\subsection*{本节回顾}

目前shell知识讲解仅限于能让读者小小入门，并顺利完成Gentoo的安装。现在小结一下shell的简单用法。

\begin{itemize}
\item shell以文本模式命令行作为用户界面。
\item 命令行的规则是　命令+参数，以回车键代表输入完成，请立即执行命令。
\item 参数之间以空格隔开。
\item 文件名参数可以用通配符，shell会自动扩展后作为参数传递给要执行的命令。扩展后的文件名是每个文件名一个参数而不管文件名本身是不是包含空格。
\item 如果需要避免shell对通配符进行shell扩展，加引号。
\item 避免空格成为参数之间的分割的办法也是将带有空格的参数用引号引起来。
\end{itemize}

掌握这些shell知识应该用于完成安装Gentoo足够了。


\section{引导管理器}\label{sec:grub}
Linux的启动过程是一个令人着迷的过程，首先是硬件的初始化——也就是固件初始化——接着是固件加载并执行引导程序。
引导程序负责将内核启动起来。然后内核执行第一个程序/sbin/init，后续的启动就交给init完成了。

引导程序自身是如何实现的我们不必关心，倒是引导程序如何被固件找到载，以及引导程序如何找到内核是个重点话题。

IBM创造PC的时候给PC开发了一个名字叫BIOS（Basic Input Output System）的固件。该固件被存储在一个ROM\footnote{只读存储器，断电后内容不会消失，存储内容生产的时候固化，无法修改}上。 BIOS提供了基本的输入输出功能，负责机器的上电自检（POST，Power On Self Test）和操作系统加载（其实是加载MBR。MBR再加载DOS。）。操作系统运行后BIOS作为基本输入输出设备的驱动程序存在\footnote{Windows、Linux这样的操作系统使用自己的驱动，并不依赖BIOS提供的驱动。}。

也就是说，固件初始化完成后，就读取硬盘的第一个扇区（MBR）并执行这一小段程序。那么，固件并不关心你用的是什么操作系统，用的是什么引导程序，它只是遵照约定，执行MBR而已。

微软的操作系统，不管是DOS还是Windows，其MBR都是一样的。就是查找活动分区\footnote{分区的一个额外属性。活动或者非活动。值得一提的是DOS无法访问非活动主分区。}并执行分区的第一个扇区（PBR）。所以微软操作系统的真正引导程序在系统安装分区（C：）的第一个扇区里，也称呼为分区引导扇区，Partition Boot Record。这是GRUB所以能支持引导Windows的关键原因哦。我们下文马上会介绍到。

Linux下普遍使用的引导程序——或者说是事实标准——是GRUB（GRand Unified Bootloader）。其大名是如醍醐灌顶，如雷贯耳，谁人不知，谁人不晓啊。

BIOS这种固件使用简单的伎俩查找引导程序。不过MBR只有区区512个字节，还要留64个字节给分区表，用于引导程序就只有448个字节了。想要做功能多点的引导程序都不行啊！空间问题。

GRUB使用的办法就是接力加载。存在MBR上的那份代码只是完整GRUB的加载器。因为完成的GRUB需要支持ext2/ext3/ext4/fat/iso9660等等各种文件系统，以便读取存储在磁盘上的内核，还要支持配置文件，还要有命令行模式，故而GRUB的代码不可能少于448个字节。

GRUB完整启动后，读取配置 /grub/grub.conf\footnote{注意，此/非Linux启动后的/，而是安装了GRUB的那个分区。如果没有/grub.conf 会查找 /boot/grub/grub.conf。所以在Linux环境下配置文件路径就是/boot/grub/grub.conf而不管/boot分区是不是独立的。}，显示操作系统选择列表。

Linux下第一个硬盘的第一个分区是/dev/sda1，但是GRUB下却是从0开始的，(hd0,0)。这点需要注意。grub.conf的引导项配置以title开始，例如

\begin{code}
title Gentoo\\
kernel /vmlinuz ro root=LABEL=GENTOO\\
initrd /initrd.img
\end{code}

这里的 /　指的是GRUB安装分区。如果GRUB被安装到/boot分区，那么grub下的/对应的Linux下的路径就是/boot。
kernel　命令指示后面加载一个Linux内核，内核文件后面跟随的字符串将成为内核参数。好多参数可以控制内核的行为。参数的介绍参考　\faqref{FAQ：kernelparamter}

如果 vmlinuz不在 /boot分区，比如想在命令行模式启动其他内核的时候，可以用　root (hdX,Y) 的格式指定一个GRUB根。如下面的

\begin{code}
title Test-kernel\\
root (hd0,1)\\
kernel /usr/src/linux/arch/x86/boot/bzImage ro root=/dev/sda2
\end{code}

kernel用来加载一个内核，initrd 用来加载initramfs。对启动Linux来说，initrd并不是必须的。initrd的详细解释可以参考　\faqref{FAQ:initramfs}。

不过，这样的GRUB可是对UEFI无效的哦~。

\subsubsection{UEFI}

IBM发明PC的时候远见不足，BIOS的历史局限性逐渐显现。BIOS最大的禁锢就是运行于16位模式。在连32位都要过时的年代，BIOS却还是16位的。

彻底的革新，就是要从固件开始就让CPU处于64位模式运行，固件的代码再也不用遇到16位模式下的限制了。固件能集成更多的功能，甚至能直接访问文件系统，集成功能强大的引导程序。

UEFI就是Intel提出的新的BIOS。和BIOS相比，UEFI对于操作系统来说区别就是：
\begin{itemize}
\item 纯64位启动。从UEFI到GRUB（并不是必须的存在，UEFI可以直接启动Linux）到Linux，中间没有16位代码。
\item UEFI使用GPT分区表，支持访问FAT文件系统。
\item 引导程序是EFI系统分区（标记EFI系统分区属性，文件系统为FAT）里的文件，扩展名为.efi。
\item Linux可以由　grub.efi　引导，也可以将自身直接作为　vmlinuz.efi 被UEFI直接引导。
\item 在操作系统环境下可以直接控制UEFI的引导选项。BIOS下必须进入BIOS设置程序才能设置。
\end{itemize}

要使用UEFI启动，需要两个要素：
\begin{itemize}
\item 一个UEFI能识别的分区，里面存放引导程序。UEFI使用GPT分区表，支持访问FAT文件系统。需要将一个FAT分区的分区类型设置为EF00。
\item 告诉UEFI从哪个引导程序\footnote{扩展名.efi，也就是EFI可执行程序。}引导。可以在UEFI的设置界面设置，也可以使用efibootmgr命令行实用工具设置。
\end{itemize}

能用于UEFI的引导程序并是上文所提到的grub。您有三个选择：一是使用打了EFI补丁的GRUB；二是去使用GRUB2；三是使用内核自己\footnote{没错，编译好后的内核文件本身也是一个合法的EFI可执行文件！当然，前提是打开EFU stub选项。}。GRUB2的语法比较晦涩难懂，暂时没什么必要的话还是继续使用GRUB比较好。我会在后面的章节再次详解GRUB和GRUB2的配置文件语法，如果将来想换到GRUB2进行引导的话还是可以修炼的哦。

打过补丁的GRUB可以从Fedora\footnote{Fedora从18开始BOOTX64.EFI不再是GRUB了。默哀。追Fedora还真难。没准等读者买到我的书的时候，Fedora 18已经成了落后的过去式了。}的LiveCD上提取。光盘根目录下的 /EFI/Boot/BOOTX64.EFI 就是EFI版的GRUB。如果没有Fedora光盘，其他的支持EFI启动的LiveCD上也有。通常在光盘根目录的EFI子目录里。

也可以上网找grub的rpm包
\footnote{%\begin{longtable}{p{\textwidth}}  
http://mirrors.163.com/fedora/releases/17/Everything/x86\_64/os/Packages/g/grub-efi-0.97-93.fc17.x86\_64.rpm
%\end{longtable}
}
然后提取 grub.efi。

获得grub.efi（BOOTX64.EFI）后，将grub.efi拷贝到EFI分区。\footnote{其实我比较推荐直接将EFI系统分区挂载为/boot，但是有的人更喜欢的做法是将EFI系统分区挂载到/boot/efi/。}

拷贝完成后执行efibootmgr将其添加到UEFI的引导程序列表中。

\section{init 系统选择}

Linux内核被引导后，会自动加载 /sbin/init 程序，之后系统的启动就完全交给了init程序。由于init是第一个启动的程序，所以他的PID\footnote{Linux用一个数字代表一个进程。需要对进程操作的地方可以使用该数字。比如向进程发送信号，就是用PID标识发送的目标的。}是1。\footnote{PID 0是个特殊进程（或者是根本就不是进程吧），每当系统空闲下来的时候PID　0才会执行，PID 0只做一个事情，就是让CPU进入节能模式。而且PID　0的个数就是CPU的个数。每个CPU都有一个属于自己的PID 0。所以系统真正的进程号是从1开始的。}

\begin{insertnote}
\subsection*{Linux启动过程}
计算机的启动步骤为 固件初始化 \textrightarrow 引导程序　\textrightarrow　内核加载并初始化　\textrightarrow　执行首个程序负责剩余的初始化　\textrightarrow　检查并挂载文件系统　\textrightarrow　启动后台服务　\textrightarrow　开启登录　\textrightarrow　（用户登录或者自动登录）　\textrightarrow　执行shell\footnote{Linux下命令行的shell就是bash。但是图形界面也可以算是一个shell哦，Desktop Shell是也。}。

PID 1 的任务就是操作系统启动过程中的{\em 最后一英里（last mile）}。

其实PID本身也不做什么操作，它只是依次启动其他服务：

启动磁盘检查服务，启动文件系统挂载服务（这些都死一次性服务，系统启动过程中一次性执行）；

启动udev服务，启动Dbus服务，启动电源管理服务等等（持续性服务，系统运行过程中一直执行的）；

最后启动登录服务。

命令行登录服务为 agetty 。在文本终端上显示登录提示接受用户登录。通常开启六个。tty1-tty6。使用组合键Ctrl+Alt+(F1-F6)访问。
图形登录服务（显示管理器，Display Manager）为　GDM或者KDM或者XDM .... 好多，就看用户的选择了。通常发行版有一个默认的。一般和使用的默认桌面有关。
默认使用Gnome桌面的发行版默认的显示管理器是GDM，默认使用KDE桌面的发行版默认使用的显示管理器就是KDM。也可以使用简洁的XDM。各有特点，但是功能都是一样的，可以随意互换。GDM一样能启动KDE桌面，KDM启动GNOME也没问题。

\end{insertnote}

简单的来说，启动操作系统过程中PID　1的任务就是bring up userspace。此外，PID 1还减负者收养孤儿的重任。

\begin{insertnote}
UNIX进程有父子关系。比如说你在shell下执行了一个程序，执行这个程序的进程就成为shell的子进程。子进程还可以有子进程的子进程。形成一个树形的进程关系。
\end{insertnote}

如果已经进程在子进程退出前就退出，那这个子进程就会成为没有父进程的“孤儿”。UNIX同时又规定一个进程必须有父进程，所以孤儿就被 PID 1收养成为PID 1 的子进程。


\subsubsection{sysvinit+openrc}

多数Linux发行版使用传统的sysvinit作为PID　1。　
sysvinit有一个运行级别概念。每个级别用一个数字表示。预定义的运行级别如下：

\begin{longtable}{|l|p{0.7\textwidth}|}\hline
0　& 关机\\\hline
1 & 单用户（救援）模式　\\\hline
2 & 无网络模式　\\\hline
3 & 多用户模式　\\\hline
5 & 图形模式　\\\hline
6 & 重启　\\\hline
\end{longtable}

不同的运行级别对sysvinit本身并没有特殊含义。只是人为这样的运行级别设定而已。
sysvinit使用配置文件/etc/inittab决定启动过程。其中有一行
\begin{code}
id:3:initdefault:
\end{code}
决定默认进入运行级别3。3替换改为5就可以默认进入运行级别5。

/etc/inittab告诉了sysvinit每个运行级别下应该执行什么程序。例如inittab通常包含这么6行：
\begin{code}
c1:12345:respawn:/sbin/agetty 38400 tty1 linux\\
c2:2345:respawn:/sbin/agetty 38400 tty2 linux\\
c3:2345:respawn:/sbin/agetty 38400 tty3 linux\\
c4:2345:respawn:/sbin/agetty 38400 tty4 linux\\
c5:2345:respawn:/sbin/agetty 38400 tty5 linux\\
c6:2345:respawn:/sbin/agetty 38400 tty6 linux
\end{code}

表示：在运行级别1 2 3 4 5下，启动c1，启动c1所需要执行的命令为/sbin/agetty 38400 tty1 linux, respawn表示服务退出后立即重新开启。
c2 c3 c4 c5 c6 在运行级别 2 3 4 5下启动，　1 下不启动。因为1是单用户模式嘛。

图形登录界面是由下面的设置控制的（以早期Fedora为例，现在的Fedora不使用Sysvinit）
\begin{code}
x:5:once:/etc/X11/prefdm 
\end{code}
/etc/X11/prefdm 查找用户偏好的DM\footnote{一般是GDM或者KDM。}并启动之。
可以看出图形管理器是在运行级别5开启的。


{\tt c1:12345:respawn:/sbin/agetty 38400 tty1 linux} 这一行的上面还包含了一些配置用于启动　/etc/init.d/ 下的服务程序。各个发行版的做法都不一样。没有借鉴意义。

总之最后的结果是是\textbf{按循序}启动 /etc/init.d/　下的脚本
（因为运行级别的关系不是每个脚本都会被执行。通常如果运行于级别5的话，所有服务都开启，也就是都会被执行。）。

我在这里强调了一个次序。因为服务和服务之间是有明显的依赖关系的。举些例子吧：提供HTTP服务的服务apache必须于mysql之后启动。因为php页面需要和mysql数据库交互；NetworkManager依赖DBus,因为它需要和DBus提供通信功能；NetworkManger同时也依赖wpa\_suplicant，因为它需要wpa\_suplicant实现wifi加密认证；等等等等。

维护各种服务之间的依赖关系保证正确的启动次序是一个系统管理员非常非常重要的工作。
但是也不必过于担心，发行版通常已经将这种重要的工作做的相当好了。

对于Gentoo，/etc/init.d/　下的脚本并非bash脚本，而是openrc脚本。openrc主要的作用是“解析和缓存依赖关系”。
每个脚本都包含　depend() 函数，openrc执行该函数获得依赖关系以决定脚本的执行次序。

而对于Fedora/RHEL这样的系统（老Fedora，Fedora 从版本16开始不再使用sysvinit）， /etc/rc?.d/ （?为运行级别数字）下面有　S??XX K??XX 这样的符号链接到　/etc/init.d/XX 脚本。 %话说这也是Gentoo的启动脚本名为openrc的由来。
S表示　Start，?? 是一个两位数的数字，代表启动的次序。
S表示　Kill，?? 是一个两位数的数字，代表停止的次序（停止的次序和启动次序一样重要）。\footnote{
我表示我已经被Fedora这种模式弄晕了，Gentoo的openrc好歹是设置依赖关系自动决定启动次序的。这也是Fedora后来果断废除sysvinit的原因吧。}Fedora的 /etc/init.d/下是实实在在的shell脚本。没有依赖关系。引入Gentoo的openrc不如彻底革新到自动确定依靠关系或者是根本不需要依赖关系的新服务管理系统。

\subsubsection{SystemD}
sysvinit大量依靠脚本（/etc/init.d/* ）实现系统启动过程。脚本的一大特点就是慢。
另一个诟病的地方就是服务之间的关系复杂，很难搞懂。而且各个发行版并没有统一这些脚本。有的发行版为脚本加入了依赖关系，有的要依靠手工设置（是发行版打包的时候确定的）启动次序。管理上非常复杂。

那么，针对sysvinit的问题：慢、管理复杂，Redhat的一个牛人开发了SystemD做为PID 1以克服sysvinit的缺陷。

那么SystemD到底有哪些好处呢？

\begin{itemize}
\item 极度并行化启动。
		SystemD开发者说过，要系统启动更快的，第一条需要做到的是单位时间内启动更多服务。不像sysvinit那样串行启动，SystemD是高度并行的。SystemD同时启动多个服务。

\item 无脚本启动。SystemD开发者说过，要系统启动更快，你还需要做到的是整个系统启动过程启动更少的程序。SystemD实现不依靠一行shell脚本启动完整的系统。

\item	按需启动。SystemD开发者说过，要系统启动更快，按需启动是必不可少的。按需启动功能更进一步的使整个系统启动过程启动更少的程序。

\item	无需配置依赖性。
		按需启动还使得服务之间的依赖关系成了过去式。你不需要直接指定服务之间的依赖关系——只要一个服务用到了另一个服务，另一个服务会被按需启动，\em 就好像它本来就已经被启动了一样。

\end{itemize}

SystemD能实现按需启动和避开依赖性配置，原因就是实现了socket activation。

\begin{insertnote}
\subsection*{Socket Activation解释}
如果所有的服务可以同时启动而不考虑依赖性，服务就可以最大化的并行启动了。如果不考虑依赖性，管理员也可以大大的轻松。
那么服务和服务之间为何会相互依赖呢？答案是依赖它创建的Socket。{ \it Apache要在mysql之后启动，是因为网页需要数据库，需要mysql提供的数据库服务。它只所以需要这个服务，是因为它需要连接到mysql创建的socket。NetworkManager需要DBus服务，是因为NetworkManager需要连接到DBus，其实是连接到DBus创建的那个socket。}

如果，如果所有的Socket一开始就已经全部创建完成，所有的服务就可以同时启动了。因为他们连接到对方的时候不会再遇到“连接拒绝：地址不存在”错误。

如果没有Socket Activation, 同时启动NetworkManager和DBus的后果是，如果NetworkManager试图连接到DBus的时候，DBus还为创建它的socket,NetworkManager将出现连接错误而是服务启动失败。

有了Socket Activation, NetworkManager和DBus不再需要串行化启动，同时启动即可。NetworkManager总能连接上需要的Socket，因为它已经在那里了。
甚至DBus自身都不用启动，NetworkManager也能正常开启直到NetworkManager向这个socket发送了一些数据——这个时候DBus必须开起以便处理这个数据。这就是“安需启动”的实现方式。

Socket Activation 将创建socket的任务交给了SystemD——利用了UNIX父进程可以向子进程遗传文件描述符\footnote{socket也是文件。也是使用的文件描述符标识的。}的特性——由SystemD创建后再由其启动的服务继承。
\end{insertnote}

除了Socket Activation，还有类似的Path Activation，DBus Activation。 

DBus Activation好理解，有的服务提供的并不是Socket，而是在DBus下的一个名称接口。服务使用者并不连接到该服务，而是直接连接到DBus，然后向DBus发送请求，由DBus转发给对应的服务。这是一种RPC\footnote{远程过程调用。}实现的说。如果该服务不存在（比如还未启动），DBus会返回错误。DBus Activation将未启动的服务的接口提前标记为“可用”，等该服务真的被用到的时候再将对应的服务启动。

Path　Activation原理类似。比如邮件投递服务，只要在 /var/spool/mail 下有文件，该服务就应该进行邮件投递，将成功投递的邮件删除。Path Activation将监视该文件夹的任务交给了SystemD，文件存在后SystemD激活邮件投递服务。

那么，决定使用sysvinit还是SystemD了么？话说Gentoo给的不就是选择么？
%如果决定使用sysvinit什么都不用做，stage3里已经带上sysvinit了。如果决定用SystemD就继续哦，话说现在还不着急安装，内核代码下好了么？下好的话可以回到上面编译内核去了的说哦。


\section{分区规划}
任何系统都是安装到硬盘使用的
\footnote{好吧，先忽略掉LiveCD 和  WinPE 这类不需要安装的系统，咱讨论的是一般用途的桌面操作系统。}，
安装到硬盘之前，必须先划好家。在介绍如何分区前，首先得知道什么是分区，然后参考
FHS\footnote{FHS 是文件系统目录结构的一个标准。规定了根分区下各个子目录的名称和用途。}
指示结合自己的实际情况规划好分区。

\subsection{分区基础知识}
最初，计算机使用软盘，软盘是没有分区的。后来蓝色巨人IBM发明了硬盘。硬盘的容量一下子比软盘大出好多倍。当时的MS-DOS所使用的FAT12文件系统无法管理那么大的硬盘。于是西雅图的巨人和蓝色巨人想出来把硬盘划成逻辑上的几个区域，每个区域大小都在MS-DOS能管理的范围之内——这样的逻辑区域就是分区。人们发现将硬盘划分为逻辑上的几个区域后，更容易组织硬盘上的数据了；而且一个文件系统错误只会影响到一个分区的数据，其他分区不受影响，数据的安全性也得到的提升。因而后来的DOS虽然将FAT12进化到了FAT16，能管理当时的大容量硬盘了，但是分区这个功能却保留了下来\footnote{虽然是MS-DOS的发明，但是Linux可不会拒绝这样的发明。Linux还支持 BSD 发明的分区格式，总之，Linux决定支持越多的分区表格式越好，这极大的方便了用户，不是么？}。

既然用户划了分区，操作系统总得知道用户到底怎么划分的，描述分区的数据被称作分区表。既有分区表，必须有个地方存储，也必须知道到哪里去读取分区表。MS-DOS的把分区表和引导程序放入硬盘的第一个扇区\footnote{扇区是硬盘最小寻址单位。参考附录A. FAQ里的条目“什么是扇区”。}。

硬盘的第一个扇区又被称呼为MBR\footnote{MBR是硬盘的第一个扇区，具体解释请参考附录A. FAQ 里的条目“什么是 MBR”。}。
MBR既要存储引导程序，又要储存分区表，是个寸土寸金的地方，分区表大小受限，只有4个表项。也就是说，一个 MBR分区表最多只能有4个分区。要是只有四个，似乎并不够用。

MS-DOS将其中一个分区作为扩展分区，然后再扩展分区里再建分区表。扩展分区里面的分区就是逻辑分区，MBR 上的分区表就是主分区表。主分区表里划分的分区自然就是主分区了。所以一个MBR格式分区表最多允许3个主分区和1个扩展分区，或者4个主分区。扩展分区里再创建逻辑分区，没有数量限制。
\chatu{logicalpart}{链式逻辑分区表}

\begin{notice}
注意：扩展分区里的逻辑分区并不是表格形式存储的，而是“链式”存储。如图\thefigure所示。每个逻辑分区包含查找下一个逻辑分区的信息。因而一个逻辑分区的破坏有可能造成链式效应，将所有的逻辑分区全部摧毁。
\end{notice}

由于近来UEFI\footnote{参考附录A “UEFI 和 BIOS”。}  的兴起，
UEFI指定的分区表格式GPT也流行开来了。
和MBR不同的是UEFI不需要专门的引导扇区，引导程序由UEFI直接从文件系统上加载。所以GPT只是分区表，不需要和引导程序共存。

MBR 的分区表只有64个字节大小，只能包含最多4个分区的信息。
GPT包含128个分区表项，最多允许一个硬盘划分成128个分区，足够了。
能表示更多的分区并不是GPT唯一的优点，MBR分区表只能管理2.2TB
\footnote{MBR使用4个字节表示分区起始位置的偏移量。
偏移量以扇区为单位，一个扇区为512字节，那么MBR分区表能管理的最大硬盘大小为$2^{31}*512Byte = 2TB$。
又因为硬盘厂家以1000为进制而不是1024，故而大约为2.2TB。}%
以下大小的硬盘，GPT却可以管理容量超过9ZB\footnote{1ZB=1024PB 1PB=1024TB. 硬盘厂家的计算是 1ZB=1000PB 1PB=1000TB。}的硬盘。
在大容量硬盘越来越普遍的今天，MBR显得越来越力不从心。GPT正好接替MBR成为今后PC硬盘的主流分区表格式。

如果你电脑的固件是UEFI，不管硬盘实际是否大于2TB，建议最好使用GPT分区表。

在UNIX操作系统下，一个文件系统是要挂载到某个目录下才能访问其中的文件的。Windows和DOS下，操作系统会分配一个“盘符”，但在UNIX下，使用挂载命令将文件系统挂到一个目录下。被挂载的目录就成了那个挂载的文件系统的根目录，也称为挂载点。实现这个挂载操作的命令就是\textbf{mount}。mount将一个分区“挂载”到一个目录下，命令格式为

\begin{code}
mount 磁盘设备  挂载目录 [-t 文件系统] [选项]
\end{code}

选项是可选的，文件系统类型没有给出的话，mount会进行自动探测，所以一般也不需要给出。

\begin{notice}
注意：mount只有root用户才能运行。
\end{notice}

\begin{example}{挂载U盘}
\it 通常大家只有一个硬盘。按照第一个硬盘为/dev/sda，第二个硬盘为/dev/sdb这样的编号，通常U盘就是/dev/sdb（U盘也是硬盘的一种）。所以我这里假设用户插入的U盘被识别为/dev/sdb。U盘一般只有一个分区，所以正确的表示U盘的设备文件就是 /dev/sdb1了。

\normalfont

建立一个/media/usbdisk目录用于挂载，然后执行mount将U盘挂载到/media/usbdisk。

\begin{code}
mkdir -p /media/usbdisk

mount /dev/sdb1 /media/usbdisk
\end{code}

执行成功后，跑到（cd命令进去） /media/usbdisk目录下看看（ls命令列出），是不是U盘上的文件都跑到这个目录下了呢！

\end{example}


有mount操作自然也有撤销的操作。撤销mount的操作由命令unmount完成。试试看执行unmount /media/usbdisk，等等！命令未找到？

是的，UNIX就是这么矫情。看似应该使用unmount的地方，UNIX使用的却是umount命令。umount命令的语法不用说都猜到了：
\begin{code}
umount 磁盘设备
\end{code}
或者
\begin{code}
umount 挂载目录
\end{code}

用哪个形式都可以。要卸载一个文件系统，必须那个文件系统里所有的文件都被关闭。如果还有程序在使用上面的文件就无法卸载。可以使用 lsof 命令查看打开的文件。比如
\begin{code}
lsof /media/usbdisk
\end{code}
就可以查看/media/usbdisk目录下所有被打开的文件以及是哪个程序打开的。确保lsof的输出为空即可安全卸载了。

\begin{example}{卸载U盘}
U盘用完后直接拔出是不正确的\footnote{尽管这是个美好的传说。}。操作系统可能还有未来得及写入U盘的数据，直接拔出会导致数据丢失。所以在拔出U盘前必须先卸载U盘。
执行：
\begin{code}
umount /media/usbdisk
\end{code}

然后就可以拔出U盘了。如果卸载失败，可以用lsof查看是否还有正在使用的文件。

\end{example}

\subsection{为磁盘分区}

\chatu{gparted-gui}{gparted界面}

\normalfont

有很多种工具可以对硬盘进行分区。今天的主角是 gparted , 这个是一个非常简单易用的分区管理软件，带图形界面的哦~~

要打开gparted，在终端执行sudo gparted。如果 Fedora 的LiveCD提示没有这个命令，则用命令sudo yum install gparted或者apt-get install gparted进行安装。gparted界面如图\thefigure所示。

在gparted里所做的一切操作都不是立即执行的，只有应用操作后才被一次性执行。所以未应用前撤销操作是来得及的。
下面我把为硬盘分区所需要的几个主要操作图解一下。请读者根据此处的图示熟悉操作流程，并在学习下一个小节后自行分区。

\chatu{gparted-apply}{gparted应用操作}
\noindent要应用操作：\\\indent
1. 单击“编辑”|“应用全部操作”菜单。如图\thefigure所示。\\\indent
2. 在弹出的警告对话框中选择“是”。

\chatu{gparted-newpart-boot}{gparted新建分区}

\noindent建立一个分区：\\\indent
1. 选择磁盘的空白区域，右击后在菜单里选择“新建”。\\\indent
2. 在弹出的对话框里指定一个大小、分区类型和文件系统，如图\thefigure所示。\\\indent
\hskip 4em %
\begin{notice} %
  注意：分区表为GPT格式的只能选择主分区。
\end{notice} \\\indent
3. 单击“添加”按钮，新建的分区就编排在了任务列队里了\\\indent

\chatu{gparted-delpart}{gparted删除分区}
\noindent删除一个分区:\\\indent
1. 右击要删除的分区在菜单里选择“删除”。如图\thefigure所示。 %\\\indent

\chatu[scale=0.2]{gparted-newpt1.png}{新建分区表}

\noindent新建一个分区表：\\\indent
1. 单击“设备”｜“创建分区表”菜单，如图\thefigure所示。

\chatu[scale=0.2]{gparted-newpt2.png}{新建分区表}

\indent2.在打开的对话框里点“高级”前面的箭头，选择一个分区表类型。默认为MS-DOS分区表，也就是MBR分区表。
我需要在这里我选择gpt分区表。如图\thefigure所示。

好了，gparted的基本操作就完成了，接下来学习一下文件系统的结构后按照自己的意愿为自己的系统分区吧。

\FloatBarrier

\subsubsection*{UEFI模式注意}

值得注意的是，如果使用GPT分区表，必须有一个200M左右大小的FAT分区并设置为EFI系统分区，如图\ref{fig:EFI-part}所示，为该分区打上boot 标记即可（操作：右击分区选择“管理标志(A)”）。

EFI系统分区一般挂载到 /boot/efi下，但是个人喜欢EFI系统分区和/boot共用。自由选择的说。为了日后少麻烦，请务必让EFI系统分区为第一个分区。虽然说不一定非得是第一个分区，但是第一个分区是eifbootmgr的默认假定，嫌麻烦的研究手册的话，还是以第一个分区作为EFI系统分区为佳。

\chatu{EFI-part}{为分区设置EFI启动属性}

\FloatBarrier

\subsection{文件系统结构标准（FHS）}

Linux继承自UNIX树形目录。每个目录各司其职，并被FHS（Filesystem Hierarchy Standard）标准化。表3.1所列是一个不怎么完整的FHS标准，但是对于读者决定如何为他自己的电脑分区已经足够了。

\begin{longtable}{|l|p{0.7\textwidth}|}\hline
\caption{FHS标准参考}\\
\hline
/ & 根目录 \\\hline
/bin & 基本系统程序。如 ls cat grep \\\hline
/sbin & 只供管理员使用的基本系统程序 \\\hline
/boot & 内核和引导程序，通常为独立分区\\\hline
/dev & 设备文件目录 \\\hline
/etc & 存放系统配置文件。不允许存放为独立分区\\\hline
/home & 存放非root用户的家目录。 
比如foo用户的家目录就是/home/foo
一般用来存在个人文件和个人设置。
通常强烈建议独立为一个分区。\\\hline
/lib & 系统基本库，被 /bin /sbin 里的程序依赖的库 \\\hline
/media & 可移动媒体的挂载目录。比如cdrom和u盘。被/run/media代替\\\hline
/mnt & 临时挂载目录\\\hline
/opt & 通常用于安装非开源软件，如Adobe Reader \\\hline
/proc & 虚拟的文件系统，用来获得内核和运行中的程序的信息\\\hline
/root & root用户的家目录\\\hline
/srv & 做服务器使用的时候 ，用来存储服务的数据。如一个git服务器通常将仓库存放于/srv/git\\\hline
/tmp & 临时目录。其中文件关机丢失。建议挂载为tmpfs虚拟文件系统，对于tmpfs的介绍可以参考第7章。 \\\hline
/usr & 非基本系统程序根目录，下面的结构和 / 差不多 \\\hline
/usr/bin & 同 /bin。只是非基本程序。如xeye  elinks . \\\hline
/usr/sbin & 同 /sbin。只是非基本程序。如system-config-firewall \\\hline
/usr/include & 头文件目录。\\\hline
/usr/lib & 同 /lib。只是其包含的库是不被/sbin、/bin使用的。\\\hline
/usr/share &  保存架构无关的共享数据。如图标\\\hline
/var & 系统运行中会不停变化的文件。比如各种log，包管理器的数据库，等等。通常在服务器上是独立分区，个人电脑可以不独立划分。\\\hline
/var/cache & 缓存。该目录下的文件可以安全删除，要求使用它的程序必须能重建它。比如fontconfig的缓存。\\\hline
/run 和 /var/run & 临时目录。包含本次系统运行时的信息。\\\hline
/var/log & 存放各种日志文件。\\\hline
/var/tmp & 临时文件，可能重启后还在。注意和/tmp的区别。\\\hline
\end{longtable}


知道了系统各个目录的作用，就好为目录进行分区了。通常我们使用4个分区 /boot、/、/home 和一个交换分区。

\begin{notice}
注意：我在使用“/home分区”这个术语的时候，我指的是为“/home”分一个单独的分区，并且将这个分区挂载到“/home”目录下。我通常不使用“挂载到/home目录的分区”而直接简述为“/home分区”。同样的，“/分区”（或者根分区）指的就是挂载到根目录的分区。
\end{notice}

/boot独立为一个分区的好处是防止根文件系统的错误蔓延导致/boot/*文件破坏无法正常启动。另一个好处是 /分区可以使用引导程序（如GRUB）不支持的文件系统格式。例如GRUB不支持XFS文件系统格式，但是你可以让/boot分区使用ext2格式从而使 /分区可以使用XFS格式。如果/boot没有独立出一个分区。那 /分区就只能使用引导程序所支持的文件系统了。

/home独立一个分区的好处就是将用户数据彻底和系统数据分离。由于/home目录通常频繁读取写入，和 /分区隔离可以避免 /分区被碎片化。

提示：其他目录，比如“/var”，可以独立一个分区也可以不独立。就看你系统的用处了。作为桌面用途，完全没必要。如果是服务器，“/var/log”可能会很大。邮件服务器的“/var/mail”就可能会非常大，所以非常有必要使用独立分区。

\subsection{文件系统选择}


Linux支持的文件系统非常多，有自家系列 ext2/ext3/ext4、甲骨文公司开发的btrfs，来自硅谷图像的XFS等等等等。

不过选一个文件系统没那么纠结的。对于根分区\footnote{根目录所在分区}，既然大部分发行版默认使用ext4，那就ext4吧。

为了引导程序的兼容性，/boot分区仍旧使用ext2或者ext3。

对于/tmp这样的目录，强烈建议使用tmpfs\footnote{参考第7章“文件系统”。}。tmpfs是一种内存文件系统，所有tmpfs上创建的文件都是在内存里的，关机后就会消失。非常适合用作/tmp的文件系统。既能加快系统速度，又能保护硬盘。

对于/home目录，如果是个BT爱好者，会有很多大文件，我推荐使用XFS文件系统。其他情况下还是ext4各方面性能比较平衡。

如果希望为自己选择最佳的分区格式，请参考第7章“文件系统”的内容。

\section{开始安装}

废话了那么多，介绍了一些安装前需要知道的基础知识，现在终于要进入正题了，安装Gentoo。
Gentoo的安装非常简单，首先是分区。这个前面已经介绍过了。我现在假定读者已经在LiveCD 环境中完成分区了。下面开始真正的安装。


\subsection{正式开始安装过程}

现在，Gentoo的安装可以正式开始了！现在再检查一下

\begin{itemize}
\item	使用LiveCD启动，处于LiveCD环境中。
\item	LiveCD里已经配置好网络，能访问Internet。
\item	完成分区规划。已经为将要安装的Gentoo规划并划分好分区。
\item	现在处于LiveCD的命令提示符下。
\end{itemize}

一切准备就绪，可以开始安装了。

首先要做的事情就是创建一个　gentoo　目录。这个将要用来安装Gentoo的分区就暂时挂载到这个目录下。如不特殊说明，我使用 \#　代表命令提示符， \#后的命令表示需要手工输入并敲回车执行。

\begin{code}
\#mkdir　/gentoo\\
\#mount /dev/sdXX /gentoo
\end{code}

这里　/dev/sdXX　是读者为Gentoo划分的根目录。

系统目录准备好了，接下来下载Gentoo的stage3。打开　\url{http://mirrors.163.com/gentoo/releases/amd64/current-stage3/} 或者如果打算使用x86就打开\url{http://mirrors.163.com/gentoo/releases/x86/current-stage3/}下载以最近的日期结尾的 stage3 压缩包。

然后解压到 /gentoo
\begin{code}
\#tar stage3-*.tar.bz2 -C /gentoo 
\end{code}

接着下载　portage 快照
\begin{code}
\#wget http://mirrors.163.com/gentoo/snapshots/portage-latest.tar.bz2\\
\#tar portage-latest.tar.bz2 -C /gentoo/usr/portage
\end{code}

解压完成后，复制dns配置　
\begin{code}
\#cp /etc/resolv.conf /gentoo/etc/resolv.conf
\end{code}

如果还有划分了其他目录，也要一并挂载进来

挂载home分区，boot分区等（如果有划分独立分区的话）
\begin{code}
\#mount /dev/sdXX /gentoo/boot\\
\#mount /dev/sdXX /gentoo/home
\end{code}

各使用读者划分好的分区代替命令中的　/dev/sdXX。

下面是挂载/dev/ /proc /sys的。这里使用宿主系统的/dev /proc 和 /sys　目录。
\begin{code}
\#mount --rbind /dev/ /gentoo/dev\\
\#mount --rbind /sys /gentoo/sys\\
\#mount --rbind /proc /gentoo/proc
\end{code}

好了，最好这些操作，Gentoo最小环境（能用但是不能启动）的基本环境就搭建完毕了。
执行

\begin{code}
\#chroot /gentoo　/bin/bash
\end{code}
或者如果你喜欢简洁的操作
\begin{code}
\#chroot /gentoo
\end{code}

\begin{insertnote}
\subsection*{chroot命令解释}

chroot 命令能将某个目录变成根目录并在新的根目录里执行shell或者命令行第二个参数指定的程序。

执行 chroot /gentoo 后，chroot 将自己的根目录（不影响系统其他进程的根目录）切换到新的目录，然后执行新的根目录里的 \$SHELL（通常是/bin/bash）。
这样获得的新shell就继承了chroot的根目录设定，也就是 /gentoo。 试试在里面执行　mkdir /test。然后开个新的终端检查看看　/gentoo/test 目录是不是在了。
\end{insertnote}


好了，现在就已经进入Gentoo的环境了。

\subsection{emerge用法}

说到Gentoo不得不提portage和emerge。portage是Gentoo的软件包管理器，emerge是portage的命令行工具。能使用portage的不止emerge一个，这个是有官方背景的工具，所谓正统是也。

emerge的用法非常简单，假设你要安装pidgin，执行下面的命令就可以了:
\begin{code}
emerge pidgin
\end{code}

很简单，是不是？emerge会自动的下载pidgin然后编译安装，全程不需要人工干预。如果pidgin依赖的一些包没有安装，emerge会先下载这些包然后安装。再一次，全程自动化。不需要手工干预。

如果认为emerge只是自动下载编译脚本你就大错特错了。执行
\begin{code}
\# -p参数表示不实际执行安装操作，只显示需要执行的操作

\#-v表示输出详细信息。

emerge -pv pidgin
\end{code}

看到什么了？

\begin{code}
[ebuild   N    ] net-im/pidgin-2.10.6 USE="dbus gnutls gstreamer gtk ncurses networkmanager nls xscreensaver (-aqua) -debug -doc -eds -gadu -groupwise -idn -meanwhile -perl -prediction -python -sasl -silc -spell -tcl -tk -zephyr -zeroconf"
\end{code}

注意看输出，ebuild 后面有个 N 代表新安装，如果是 R 表示重新安装，U表示升级。D表示降级（不常发生，但是出现新版本有重大错误，Gentoo会紧急撤销新版本，这样已经按照的人会降级）
之后为包名，带版本号。有时候会出现NS，表示安装新版本和老版本共存。然后就是USE=$\cdots$ 了。USE=表示该包所有可选的USE参数。-xx 的表示关闭对应的功能， xx表示打开对应的功能。这些功能都是编译期选项。编译的时候就确定下来的。没有被编译进的功能软件运行时就好像这个功能本来就不存在一样。从源头上禁用了。
有的功能会在外围打上括号，表示该功能对于本平台是强制启用或者禁用的。

那怎么调节USE参数呢？ 3个办法。

\begin{itemize}
\item 使用USE环境变量。比如{ \tt  USE="-networkmanager -dbus sasl" emerge -v pidgin} 。 这个设置只影响本次编译的pidgin。
\item 到 make.conf 设置 USE=。 比如在 /etc/portage/make.conf 文件中加入 {\tt USE="gtk networkmanager -dbus"}（USE变量要用引号。）。这里的设置会是全局设置，影响到所有后续编译的软件。
\item 到 /etc/portage/package.use 文件中写一行“ { \tt  net-im/pidgin dbus gtk -ncurses -nls } ”（不包括引号）。 这个设置只影响pidgin，但是所有后续安装pidgin都会使用这个设置。
\end{itemize}

\subsection{配置make.conf}

话说emerge虽然很智能，编译下载全自动，但不代表就不需要配置了。portage的主配置文件就是 /etc/portage/make.conf。

make.conf 里最重要的设置莫过于CFLAGS和CXXFLAGS了。 
CFLAGS 和 CXXFLAGS 设置 C 和 C++ 的编译参数。
emerge所编译的所有程序都会使用这里的编译参数设置。

要配置make.conf需要编辑器，请参考\secref{sec:nano}和\secref{sec:editors}
的内容。

CFLAGS是C编译器参数。在这里设置的参数会被所有软件作为C编译器参数。CXXFLAGS是c++编译器参数。通常两者设置为相同即可。

推荐的设置是 CFLAGS="-O2 -march=native -pipe"。
（CXXFLAGS 同 CFLAGS。）

\begin{itemize}
\item -pipe 表示使用管道代替临时文件把编译后的汇编文件交给汇编器。
\item -O2 表示优化级别为2。gcc 有5个优化级别， -O0 -O1 -Os -O2 -O3。-O0 表示不优化。-O1 到 -O3，数字越大，优化级别越高，生成的代码也越快。之所以不推荐使用 -O3 乃是保守。-O3 优化太激进，可能会导致一些软件错误。-Os是一个特殊的优化级别，表示按照大小优化而不是速度。
\item -march=native 指示编译器按照本地CPU的指令集优化。编译生成的二进制程序将不能在和本机CPU型号（比仅仅是CPU牌子比一致，代数比一致也不行。比如在i7上编译的到奔腾上将无法执行。）不一致的机器上使用。这不正是使用Gentoo的一个原因么？
\end{itemize}


GENTOO\_MIRRORS 指示emerge下载源代码的时候使用的镜像。ebuild里虽然给出了软件的原始下载链接，但通常只作为后备资源。emerge会优先从Gentoo镜像服务器下载同名文件。
Gentoo全球镜像站点非常多，所以需要设置离自己最近的镜像以加快下载速度。目前速度不错的两个国内镜像站点分别是搜狐和网易。\url{http://mirrors.sohu.com/gentoo/} \url{http://mirrors.163.com/gentoo/}。可以到 \url{http://www.gentoo.org/main/en/mirrors2.xml} 查看全部的镜像站点。

SYNC %="rsync://mirrors.163.com/gentoo-portage"
设置的是 portage 目录的更新源。emerge 依赖 /usr/portage 目录下的 ebuild 文件获得编译和依赖信息。所以及时的更新这个目录是很重要的。使用 emerge --sync 
即可更新此目录。同样的，更新这样的目录也要选择一个快点的镜像。到Gentoo的网站查询镜像列表后选择一个填入。\footnote{网易提供的 \url{rsync://mirrors.163.com/gentoo-portage} 在大陆有不错的速度。}~ 由于 portage 树是用 rsync 进行增量更新的，所以将算不设置一个镜像也可以。因为如果每天更新的话，rsync的传输量并不大。所以可以不设置，使用默认的。

ACCEPT\_KEYWORDS%="~amd64 amd64"
指示emerge接受指定关键字的ebuild。关键字为 ARCH 和 \textasciitilde{}ARCH , ARCH为处理器架构名，如x86、amd64。设置了{\tt ACCEPT\_KEYWORDS="amd64"} （当然，这在amd64平台是默认设置）后，emerge只接受标记了amd64关键字的ebuild。
这样就把没有标记此关键字的ebuild过滤掉了。这样的做法是因为有的软件只有某个平台可以用。而 \textasciitilde{}ARCH 则表示“不稳定的包”。
比如一个ebuild如果标记为 \textasciitilde{}amd64 就表示在 amd64平台可用，但是不稳定。如果标记为 \textasciitilde{}x86就表示在32位x86平台可用，但不稳定。
其实这个稳定是从服务器的角度说的。如果做桌面使用，\textasciitilde{}ARCH都是太稳定了的说。
通常桌面使用会设置{\tt ACCEPT\_KEYWORDS="\textasciitilde{}amd64 amd64"} ， 如果是32位的则使用ACCEPT\_KEYWORDS="\textasciitilde{}x86 x86"。 这样标记为不稳定的包也能使用。通常一个软件发布新版本后，portage中出现的都是 \textasciitilde{}ARCH 版的ebuild，被测试充分稳定后才会进入 ARCH 。
使用 \textasciitilde{}ARCH 是推荐设置。想尝新的朋友其实Gentoo有更不稳定的包，就是 masked 包。
\url{/usr/portage/profiles/package.mask} 文件描述了portage树中所有被 masked 的包，被 masked 的包不论 KEYWORDS设置成什么，都会被过滤无法安装。除非手工解除屏蔽状态，具体的办法参考 \secref{sec:emerge}

MAKEOPTS%="-j8"
通常的设置为 -jN，其中 N 为cpu的数目。\begin{notice}
注意，超线程被认为是2个CPU。比如双核超线程的i3，逻辑CPU数目就是4个。
\end{notice} 这个设置被 make 使用，表示同时开启的编译数目。比如 make -j8，则 make 会尽可能的同时开启8个编译器进行编译。


\subsection*{处理循环依赖}
软件之间相互依赖并不是很罕见的事情。既然要从头进行编译安装，过程中必然会出现“A依赖B，B依赖A”这样的循环依赖。
有时候循环依赖还是间接的：“A依赖B，B依赖C，C依赖A”。可以把C想象成多个软件。
最典型的循环依赖就是工具链了：要编译任何软件都需要GCC和GLIBC，但是编译GLIBC自己也需要GCC，编译GCC自己也需要GCC和GLIBC。正因为这样会发生循环依赖，
所以完全从头编译一个Linux环境是非常麻烦的。如果非要这么做，参考LFS。

我们下载的是Gentoo提供的stage3。这里必要提一下何为stage3，有stage3必然有stage2、stage1咯。所谓stage1就是只包含一个bootstrap.sh脚本和配置文件的压缩包。
如果从stage1开始安装，就是执行bootstrap脚本。这个脚本的做法就是和LFS一样，从0开始构筑stage2。stage2则意味着包含了一个最小的“工具链”环境。
这个环境有编译器，链接器，bash，必要的命令行工具。也就是stage2就是个能编译自己的“最小”环境。从stage2开始继续bootstrap就能获得stage3。stage3包含了一个能编译自己的最小“Gentoo”环境——包含了emerge程序。因为emerge是python编写的，故而不能放入stage2。

也就是说，stage1/2/3 就是处理循环依赖，每次将基础扩大。到stage3开始，基本就可以避免循环依赖了。但是并没有绝对避免。是否会遇到循环依赖取决于用户的配置和需要安装的软件。
这也就是Gentoo已经很久不再提倡从stage1开始安装Gentoo的原因：解决循环依赖是噩梦。

stage3开始，已经没有硬循环依赖了。这个时候的循环依赖通常是这样的“A依赖B，但是B有个可选的选项导致会依赖A”。这样只要将那个可选的选项关闭，编译好B，然后再编译A，如果那个功能用户需要的话，重新打开后再次编译B。

\begin{example}{Dbus和SystemD相互依赖}

直接使用 emerge systemd 的时候，系统会提示dbus开了[systemd]选项后依赖systemd，而systemd也依赖dbus。同时systemd编译的时候并不依赖开启systemd选项的dbus，但是运行的时候却依赖。

直接的后果就是emerge出现错误提示后退出。emerge的关键提示信息为 systemd depends on by dbus, dbus depends on systemd, systemd depends on dbus.
随后提示Note that circular dependencies can often be avoided by temporarily disabling USE flags that trigger optional dependencies.

较高版本的portage还会提示关闭可能避开循环依赖需要关闭的USE选项。而低版本做法则为进一布提示：systemd依赖dbus, dbus[systemd]依赖systemd。注意dbus后面加了个[systemd]，说明USE包含systemd后dbus才依赖systemd。

\end{example}


接下来要做的就是编译一个可启动的内核，编译一些引导必备软件，安装一个引导程序Gentoo就能启动了。


\subsection{内核编译}
编译内核，对初学者来说是个艰巨的任务。不过这是通往资深用户和熟练管理员的必经之路。该做的迟早要做，不如现在就做个了断吧。

首先获取一个内核代码。推荐使用git获得内核的代码而不是下载tar压缩包。因为更新到下一个版本的时候git只会下载差异部分而不会重新下载。
git的具体用法请参考　\secref{sec:git}。

必须把内核代码放到　/usr/src/linux　哦，这样依赖内核头文件的软件才能找到所需的内核代码（仅限Gentoo设定）。

{
\bf\noindent 提示：
}{
\em shell　下一行太长可以在后面输入$\backslash$并在下一行输入剩余的命令。shell会在下一行自动出现提示符 $>$　。
}


\begin{code}
\#cd /usr/src\\
\#git clone \textbackslash \\
>~ git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
\end{code}

内核代码非常大，这一步操作会比较费时。可以先放一边，重新打开个新的终端然后chroot /gentoo，进行下一节的操作。等内核的代码克隆完成了再回到这里继续。

Mark一下。

\subsubsection{initrd}\label{sec:initrd}

\subsubsection{新手使用 genkernel}

编译内核最难的地方就是配置内核了。 make menuconfig|xconfig|gconfig 最终的目的就是获得一个.config文件。其实后面的编译步骤都不难，难的就是一个能正常工作的 .config 配置文件。
似乎某些重要配置不能随意回答Yes或No，对于没有多少经验的人来说，还是有不小的难度么。

Gentoo开发者似乎注意到了不会自行编译内核的しんまい%ざこ%ばか
\footnote{内核对你来说和这个词是一样的。}%
，所以特意开发了しんまい的内核编译助手：genkernel。虽然genkernel能直接编译出一个工作内核，
但是以genkernel获得一个能工作的.config文件并在此基础上修改定制才是修炼之道。

这里就教大家用genkernel获得一个能启动的内核的.config配置文件好了。


\subsection{系统初步配置—重启前配置}
在chroot环境中我们需要做的就是进行必备系统的安装，配置好基本系统然后重启进入Gentoo环境中进行后续的安装。所以这里基础系统的配置非常关键，他关系到你第一次能否成功地进入Gentoo系统。


\subsubsection{nano 编辑器快速入门}\label{sec:nano}
现在才讲nano我都觉得有点罪过。由于Gentoo的stage3里并没有包含vim，所以一开始必须使用nano进行系统配置，直到portage配置好后emerge了vim才能使用vim。
在此之前还是得用nano。

nano 编辑器的使用非常简单，打开一个文件用“ nano 要编辑的文件” 这种简单的指令就可以了。编辑也非常简单，支持
\textuparrow \textdownarrow \textleftarrow \textrightarrow 上下左右移动。退出按Ctrl-X，提示是否保存，回答yes就可以了。


\subsubsection{时区设置}

类UNIX系统下，系统内核并不使用本地时间。内核使用的是被称为UTC\footnote{英文Coordinated Universal Time, 法文Temps Universel Coordonné。为了协调英文和法文用户，缩写为 UTC。}的时钟：文件系统上保存的文件最后修改时间即UTC时间而不是本地时间。
需要设置时区才能正确从UTC转换到本地时间。

同时，系统硬件存储的通常是本地时间——为了和Windows兼容，以及发挥定时开机等功能——内核启动的时候也需要将本地时间转化为UTC。
所以时区信息分2个，第一，硬件时间是UTC还是本地时间，第二，本地时区。
系统在启动过程中会使用 /etc/adjtime 的信息确定是否为本地时间。

\begin{filecontent}{/etc/adjtime}
0.0 0.0 0.0\\
0\\
LOCAL
\end{filecontent}

前两行忽略，后最后一行 LOCAL 即向系统传达硬件时钟为本地时间这个信息。如果不存在这个文件，就默认为UTC时间。赶快拿起编辑器生成这个文件吧。呵呵。

时区信息保存在/etc/localtime，但是这个文件不要手工编辑。在系统的 /usr/share/zoneinfo/ 下保存有各个时区的 localtime 文件。拷贝为 /etc/localtime 就可以了。
比如大陆使用东八区，城市为上海\footnote{居然不是北京的说}，所以拷贝 /usr/share/zoneinfo/Asia/Shanghai 为 /etc/localtime 就完成时区设置了。

系统启动的时候，会读取硬件时间，然后转化为 UTC 时间设置为内核时间，该操作由hwclock程序完成。systemd的做法是由内核直接读取硬件时间（配置内核的时候选上 “Set system time from RTC on startup and resume”）， 到systemd启动的时候，按照本地时间和UTC的差拨快或拨慢内核时间即可。

使用 date 命令打印的时间是从内核获得的 UTC 时间然后依据时区设置转化为本地时间再显示。

\subsubsection{fstab配置}
安装Gentoo，可以说，最重要的配置莫过于fstab了。fstab配置文件是Linux文件系统树的根基。正是fstab指明了文件系统的建筑结构。

fstab 每行配置一个文件系统。语法是:
\begin{small}
\tt 
\begin{longtable}{cccccc}
文件系统设备	& 挂载点 & 文件系统类型 & 挂载选项 & dump & pass
\end{longtable}
\end{small}

文件系统设备可以直接使用 /dev/sdXX 这样的设备，也可以使用 UUID= LABEL= 这样的形式。
挂载选项每个文件系统都有特定的选项。如果没有特殊的需要使用 defaults 即可。dump 位如果设置为 1 表示如果检查失败就不能继续启动系统。通常设置为 1。
pass 对于 / 设置为 1, 其他都设置为 2 。

下面给出的是挂载 / 的例子。
\begin{small}
\tt 
\begin{longtable}{cccccc}
/dev/sda2	& /	 & ext4	& defaults & 1 & 1
\end{longtable}
\end{small}

使用 LABEL也可以，假设 / 分区的 LABEL 是 Gentoo

\begin{small}
\tt 
\begin{longtable}{cccccc}
LABEL=Gentoo	& /	 & ext4	& defaults & 1 & 1
\end{longtable}
\end{small}

值得注意的是，swap分区也是在这里设置的。只不过， 挂载点设置为 none，文件系统类型为 swap , dump 和 pass 设置为 0 

\begin{small}
\tt 
\begin{longtable}{cccccc}
LABEL=SWAP	& none	 & swap	& defaults & 0 & 0
\end{longtable}
\end{small}

实际上Gentoo带的stage3已经提供了一个 fstab的模板，只要将自己的/boot分区、/分区、/home分区对应的设备写进去，调节一下文件系统类型就可以了。呵呵。


\subsubsection{配置帐号，设置密码}

我安装Gentoo的时候常常忘记为Gentoo设置root密码，结果重启后发现无法使用root登录。无密码和空密码不是一回事。Linux不允许登录无密码帐号。所以这个时候要做的事情就是设置一个root密码。

\begin{code}
\#passwd\\
New UNIX password: *输入密码，注意这里不回显*\\
Retype new UNIX password: *再次输入密码*\\
passwd: password updated successfully
\end{code}

这样就设置好root帐号的密码了。

\subsubsection{语言设置}\label{sec:lang}
%TODO
很多程序都有本地化语言支持。支持本地化的程序，通过检查环境变量LANG的内容决定使用何种语言。

\subsection{安装基础系统}

除了内核，引导程序，和init程序，还有一些必须的基础程序需要安装。主要是：开机fsck需要用到的各种文件系统的辅助工具和网络工具。

\subsubsection{安装网络工具}

网络工具的具体用法请参考\chapref{chap:network}。

这里作为一个快速安装的指南，算是一个占位符吧。告诉你，现在就得把网络工具安装了，否则待会重启进的了系统却用不了网络，无法继续安装哦！

安装何种工具就看你使用的是何种网络环境了。
一般如果是静态网络，安装 net-tools 即可。它提供了ifconfig。
但是强烈的推荐使用 NetworkManager 这样的成熟的动态配置工具，尤其是还有好用的GUI可用。NetworkManager依赖较多，如果你的网络可以用 ifconfig 配置下来，可以等重启后再安装。

不过如果使用了无线网络，最好还是现在就把NetworkManager装了，免得重启后无法继续安装系统。

如果使用 PPPoE 进行拨号的（ADSL接入，在电脑上进行拨号。），除了安装NetworkManager还得安装 rp-pppoe。这样 NetworkManager就可以进行拨号了。
具体用法请参考 \chapref{chap:network}

因为 networkmanager会引入 bluetooth 依赖，现在还用不到，可以关闭。之后可以重新编译。

\begin{code}
\#emerge rp-pppoe\\
\#USE=-bluetooth emerge networkmanager
\end{code}

\subsubsection{文件系统工具}

众所周知，不正常的关机会导致磁盘数据丢失。所以每次linux开机都会进行一次磁盘检查。如果上次是正常关机，通常检查会很快结束，网络词语叫秒杀。
如果上次经历了非正常关机，就需要花比较长的时间进行检查。至于检查嘛，自然是使用各种文件系统检查工具了。init系统会统一调用 /sbin/fsck 来检查文件系统，不过 fsck 只做一件事情（UNIX哲学嘛）：检查文件系统类型，调用 fsck.??? 进行检查。而fsck.??? 自然就是属于各个文件系统专用工具集合里的了。

\begin{code}
\#emerge e2fsprogs	\#安装 ext2/ext3/ext4 系列的文件系统工具\\
\#emerge xfsprogs	\#安装 xfs 文件系统工具\\
\#emerge reiserfsprogs	\#安装 reiserfs 文件系统工具\\
\#emerge btrfs-progs	\#安装 btrfs 文件系统工具\\
\end{code}

\subsubsection{安装内核}

去去去，查看一下内核编译完成了没。内核编译完成后，就剩下安装了。

\begin{code}
\#cd /usr/src/linux\\
\#make install modules\_install
\end{code}

\subsubsection{安装引导程序}

引导程序前面已经介绍过了，现在我们要做的就是安装一个。对于BIOS机器，执行下面的命令安装的老版本的grub:

\begin{code}
\#emerge grub-static
\end{code}

这个时候　grub　会被安装到 /sbin/grub，　16位模式的GRUB模块会被安装到/usr/lib/grub。拷贝/usr/lib/grub/一份到 /boot/grub。

\begin{code}
\#cp -a /usr/lib/grub /boot/
\end{code}

/sbin/grub 这个命令可以在Linux环境下执行，除了不能启动Linux内核，GRUB能用的其他命令可以在这个命令行下使用。
执行：
\begin{code}
\#grub
\end{code}

会出现grub的交互式命令行模式，这个和BIOS启动GRUB，按C进入的命令行模式是一样的。唯一的区别就是这个模式不能真正的启动Linux。
现在我们要做的就是执行　root (hdX,Y)命令定位到 /boot　分区（如果/boot分区列位有划分独立的分区的话，否则就是定位到/分区。），然后执行{\tt setup (hd0)} (或者 hd1,看你要安装到哪个硬盘的MBR上。)。
这么做的意思就是将 grub 的“接头人”装到MBR上，由这份接头人性质的代码加载 /boot/grub/stage2实现GRUB的启动。

也可以不进入grub命令行模式，直接使用 grub-install 命令进行安装。但是熟悉grub交互式命令行模式对以后使用grub修复受损的MBR也是非常有用的。所以推荐使用grub的交互式命令行模式。

如果是UEFI的机器，则需要安装 EFI 版本的grub。不过linux内核本身也是可以直接被UEFI启动的。但是使用引导程序提供了一些灵活性，还是值得的。
grub-efi 在 gentoo-zh overlay里。介绍和使用overlay请参考 \secref{sec:overlay}

\begin{code}
\#emerge grub-efi
\end{code}

如果还没添加 gentoo-zh overlay 将找不到对应的包，可以使用下面的命令添加 gentoo-zh overlay。具体请务必查阅\secref{sec:overlay}。

\begin{code}
\#USE=git emerge layman \#管理 overlay 的工具\\

\#layman -a gentoo-zh \# 添加 gentoo-zh overlay，如果还没添加的话 

\#echo~source~/var/lib/layman/make.conf~>>~/etc/portage/make.conf
\end{code}

按照提示，拷贝 /usr/lib/grub/grub.efi 到 EFI 分区。

\subsubsection*{使用efibootmgr将grub.efi加入引导}

上文提到过UEFI支持在操作系统环境下管理启动选项。这个管理操作由efibootmgr工具实现。当然，前提是系统是由EFI模式启动的。目前大部分EFI主板都提供了BIOS模拟，所以很有可能您的LiveCD是用BIOS模拟模式启动的，这样就会失去EFI管理能力。所以确保您是用EFI模式启动的LiveCD，可以参考　\faqref{FAQ:UseLiveCD}。

当然第一件事情是安装它。
\begin{code}
\#emerge efibootmgr
\end{code}

首先显示出现有的引导选项
\begin{code}
\#efibootmgr
\end{code}

添加GRUB引导选项，将　\textbackslash{}grub.efi 添加到引导选项中去。
\begin{code}
\#efibootmgr　-c -L GRUB -l '\textbackslash{}grub.efi'
\end{code}

确认结果
\begin{code}
\#efibootmgr
\end{code}

记住　Boot????*GRUB　那4个问号代表的数字，表示新添加的GRUB处于何种次序。将GRUB设为第一引导次序，也就是默认引导项，如下文的命令。????就是刚刚找到的新添加的GRUB引导项的数字。

\begin{code}
\#efibootmgr　-o ????
\end{code}

这样就可以了。重启后系统会自动运行 grub.efi　进入grub模式，grub就可以将内核加载了。

\subsection{配置引导程序}

grub 的配置文件就是 grub.conf。 UEFI 模式下，是和 grub.efi 在同一个目录下。 BIOS模式下，是在 /boot/grub/grub.conf。（果把grub安装到boot分区的话）

在 \secref{sec:grub} 我们已经大概熟悉了一下grub.conf文件的语法。
这里要做的就是将内核加入 grub 的引导选项了。

\begin{code}
title Gentoo\\
kernel /vmlinuz ro root=LABEL=GENTOO\\
\end{code}

主要，这里的 /vmlinuz 是按照 grub 的路径来算的。比如 grub 安装到/boot分区，而内核文件（通过 make install 安装）通常为 /boot/vmlinuz-内核版本。相对 grub 的路径就是 /vmlinuz-内核版本。如果 grub 安装到 /boot/efi/ (/boot/efi 为独立的 EFI 分区) ，则必须使用 root (hdX,Y) 这样的语句选择 /boot 分区或者 / 分区（如果/boot不是独立分区的话）。
然后再使用 /vmlinuz-内核版本 或者 /boot/vmlinuz-内核版本 （/boot不是独立分区的时候） 这样的路径。

如果使用了 initrd 的话（强烈的不推荐Gentoo系统使用initrd），还需要加上 initrd 命令加载 initrd文件。initrd文件可以由dracut程序生成。参考 \secref{sec:initrd}

\section{重启后安装}

前面的安装都是在liveCD环境下进行的。现在要进行重启并进入Gentoo自己的环境中进行后续安装。这次重启万一失败就得重新进入liveCD进行修缮。
通常失败无外忽 grub 没有正确安装，或者内核没有配置正确。

好了，退出 liveCD 下的那么多 shell , 重启电脑吧。

运气好的话，大概你的电脑已经出现登录提示了。以 root 登录进行安装。既然一个基本的Gentoo已经能自我启动了（不一定进入可用状态），Gentoo的自我救赎式的安装就已经完成了。
剩下的无非就是按照自己的需求将一些用到的软件进行安装以让系统进入可用状态。让我们随着使用Linux的过程中随着安装缺失软件吧！


\chapter{Linux的日常}

\begin{quotes}{Empire of the Sun}
Yeah. You know, regular stuff
\end{quotes}

其实很重要的一个问题：我们为什么要学习Linux？须要意识到操作系统只是一个工具，而要使用工具是必须经过学习的。越是强大的工具越是需要学习后方能使用。
得心应手的工具，必定经历常年累月的使用。Linux不仅仅是一个用来学习的系统，还是一个可以经年累月的使用的系统。否则，一个不能使用的系统，也没有存在的价值。

我们需要一个称心如意的系统，必定是需要悉心调教和了解的系统。

\section{某日常的man-pages}

UNIX命令繁多，载籍浩瀚。一个一个介绍纯属不可能之任务。所以一个随时可以借用的手册（manual）是比不可少的。
不过且不论manual是怎么被缩写成man的，man已经成了UNIX管理员的必备工具了。正所谓有问题，man 一下。

要使用man手册请首先按照它：
\begin{code}
\#emerge man man-pages man-pages-zh\_CN
\end{code}

man-pages-zh\_CN带来了部分man手册的中文汉化，按照后有部分手册会使用中文页面。当然，前提是安装支持UTF-8编码的groff-utf8并配置man程序使用groff-utf8替代groff。具体做法请参阅 \faqref{FAQ:zhman}。

上千条命令和系统API的帮助页面被收集起来，形成了man pages，需要查阅的时候只需要使用 ~man + 命令名/API名称~即可方便调阅。


实战演练：
\begin{code}
\$man man
\end{code}

进入阅读模式后，可以使用上下方向键翻动。按“Q”键退出。按“/”键，终端底行会由行数显示改为显示一个/,然后键入字符串，按回车即可查找该字符串。
man本质上是调用的less进行最终的显示。所以其实这里使用的就是less的命令。使用参数 -P 还可以制定其他的分页器。

man pages将系统手册分成8个类别。
\begin{enumerate}
       \item      命令行命令
       \item      系统调用
       \item      标准C库和POSIX定义的API
       \item      设备文件
       \item      文件格式
       \item      游戏
       \item      杂项
       \item      系统管理工具和后台服务
\end{enumerate}

遇到有重名的时候就可以指定一个数字表示显示指定类别的手册。否则显示序号最小的那个类别的手册。

\begin{example}{printf}
shell提供了printf命令用于打印格式化的字符串，同时printf()也是标准C库的组成部分。

直接使用 \texttt{\$man printf} 得到的就是printf命令的手册。要显示 printf() 函数的手册， 必须使用 \texttt{\$man 3 printf}。
\end{example}

%由于man手册为手册划分了类别，所以我们提到参阅某某某的时候，后面都会打上括号，指出是哪个类别。比如会有“参考man手册 printf(3)”这样的说法，指的就是参考第3类目的手册，也就是说，使用 \texttt{ \$man 3 printf } 查看。有时也会省略“man手册”，直接使用“参考printf(3)”这样的用法。

{
\bf 
由于man手册为手册划分了类别，所以我们提到参阅某某某的时候，后面都会打上括号，指出是哪个类别。比如会有“参考man手册 printf(3)”这样的说法，指的就是参考第3类目的手册，也就是说，使用 \texttt{ \$man 3 printf } 查看。有时也会省略“man手册”，直接使用“参考printf(3)”这样的用法。
也就是说，“参考XXX(1-8之间的数字) ” 已经成为“让读者使用man命令参考相应内容，并指出该内容隶属于哪个类别”的固定句式。英文里，通常是 “see printf(3)” 这样的用法。

\it 
%由于man手册为手册划分了类别，所以我们提到参阅某某某的时候，后面都会打上括号，指出是哪个类别。比如会有“参考man手册 printf(3)”这样的说法，指的就是参考第3类目的手册，也就是说，使用 \texttt{ \$man 3 printf } 查看。有时也会省略“man手册”，直接使用“参考printf(3)”这样的用法。

}


\section{UNIX权限基础}

UNIX是一个多用户系统，意味着UNIX支持同时登录多个帐号互不干扰的操作。要实现这一点就需要对帐号进行权限隔离。良好的权限设计也是杜绝恶意软件的基石。

什么是权限呢？说到底，权限就是一种信任。权限越高的程序，必然也是越受用户信任的程序。受用户信任的程序能从用户获得越多的权限。同时用户本身相互直接也有信任度问题，其中，管理员权限最大，因为他是系统的“拥有者”。管理员觉得用户（的程序）有“夺权”倾向，所以要对普通帐号进行限制。用户觉得自己执行的程序也有可能作出意想不到的行为，除非程序是自己编写的，他不太容易信任第三方程序。所以用户也会想到限制已经帐号下执行的程序的权限。权限是一种谨慎的信任。

最高一级的权限自然是系统所有者，也就是管理员。其次才是内核，然后是系统程序，应用程序，权限依次递减。
很多从非UNIX系统上过来的人都不能理解管理员的权限为何比系统本身要高。对于Windows这样的系统，最高权限是System，其次才是Administrator，有些操作连管理员都是被禁止的。
可是UNIX系统下，管理员的权限凌驾于系统之上。

为什么管理员的权限要凌驾于系统之上呢？ 因为操作系统是“被管理员授权来管理计算机”的。所以，UNIX系统本身严格遵循“不做管理员没有授权的事情”，和“不阻止管理员做任何事情”。
哪怕管理员要 \texttt{"rm -rf /"} UNIX都不会阻止管理员做这件事情。如果哪个系统阻止管理员做危险的事情，已经是“仆人成了主人”——本末倒置了。

\subsection{用户和组}\label{sec:usersandgroups}

UNIX权限是按照用户和组进行组织的。权限最高的是root用户，也称特权帐号，非root用户被称为普通用户。
在内核中，每个用户都对应一个UID，每个组也对应一个GID。root用户即UID=0,GID=0。
每个程序都会继承父进程的UID和GID。也就是说，登录哪个用户，执行的程序就是以哪个用户的权限执行的。登录程序通过改变自己的UID从而影响它启动的shell的UID，不过
只有UID=0的进程才有权更改自己的UID\footnote{使用setuid()系统调用}，这就避免了非特权进程将自己改为特权进程。

只有以root用户执行的进程才能进行的操作有
\begin{enumerate}
\item TCP/IP网络程序，允许绑定 < 1024 的端口。非特权进程无法绑定<1024的端口。
\item 修改ip地址。
\item 加载内核模块。
\item 挂载文件系统。
\item 使用chroot。
\item 执行关机、挂起操作。
\item 更改iptables。
\item 向任意进程发送信号。非特权进程只能向相同用户的进程发送信号。
\item 创建原始套接字。用于网络抓包和发送原始数据包。

等等。
\end{enumerate}

这些都是在系统调用层面进行UID检查保证的。内核对 UID=0 和 UID>0 做了区别对待。

\subsubsection{su和sudo}

有时候我们需要临时的切换到root帐号，而不用退出当前shell并重新登录。这个时候你就需要祭出sudo/su了。

在任何命令前加sudo即可让命令以root账户执行。

\begin{example}{普通用户显示/root目录内容}
\$ls /root 

ls: 无法打开目录/root: 权限不够

\$sudo ls /root

密码： (输入当前用户的密码，不显示星号)

ab.txt  a.txt  Desktop
\end{example}

当然，使用 sudo 的前提是将自己加入到 /etc/sudoers 。 通常 /etc/sudoers 会包含 \texttt{\%wheel ALL=(ALL) ALL} 这一行\footnote{如果被注释了，就解除注释状态。什么？不会，删除前面的 \# 就好了}。意味着将用户加入wheel组即可使用sudo命令。

su 命令用户开启一个新的shell，默认运行于 root 账户下。注：需要输入 root 密码。

su 命令也可用于切换到非root账户。比如 \texttt{su - smith} 就可以切换到 smith 账户。加 - 参数让 su 不要继承当前shell的一些环境变量，并且新开的shell切换到家目录而不是保持在当前目录。


记住：sudo 输入当前帐号的密码，su 输入目标帐号的密码。

\subsection{文件操作权限}

虽然在系统调用这一层面，由UID是不是0而确定不同的权限\footnote{Linux引入了新的机制，被称呼为capabilities。将原先root拥有全部特权和非root没有任何特权的二值判定改为细分的多个capabilities判断。比如进程拥有 CAP\_NET 权限就可以绑定<1024的端口而不必要求root权限。}。看上去似乎UID不为0就是普通权限了，那样还不如用个 bool 标记呢。用户和用户组的概念自然有其存在的必要。
那就是对文件的权限控制。

UNIX下，所有的文件（包括设备文件）都有所有者。文件被一个用户和组所拥有。
文件的所有者模式通常以 “用户名：组名” 的形式表示。
然后定义了文件的3种操作模式：读、写和执行\footnote{UNIX下一个文件是否可执行并不是看它的扩展名，而是看对要执行的用户来说是不是有可执行权限。}。对于目录，执行权限意味者可以切换到该目录作为工作目录\footnote{简单的说，就是可以 cd 进去}。
文件的权限很好理解，这里着重介绍一下目录的权限。
只读的目录意味着不能在目录下创建和删除文件——但是可以修改该目录下所存储的文件——只要拥有对改文件的写权限即可。没有读取权限的目录意味着无法列出目录内容。但是目录的权限并不会递归传递给子目录。子目录需要为自己设置权限。
\begin{example}{~}
所以虽然john对于/home目录是只读的，但是对/home/john是可写的。因为/home目录对john的权限并不能传递到子目录/home/john。
\end{example}

权限的设置是对3类用户设置的：
\begin{enumerate}
\item 拥有者。文件的所有者的权限。读、写和执行。
\item 所属组。文件的所属组的权限。也就是同组的其他用户的权限。因为UNIX下一个用户可以里加入多个组。读、写和执行。
\item 其他。即不是文件所有者，也不是同组的用户的权限。读、写和执行。
\end{enumerate}

系统其他方面的权限都是以组来奠定的。比如声音设备，设备的所有者是root,组是audio。对其他的权限是无。对audio组的权限是读写。那么只要将用户加入到audio组，就获得了声卡的访问权限。
因而系统并不需要在声卡方面添加新的系统调用进行权限验证。

通常一个桌面用户至少要加入的组有：users,video,audio,cdrom,cdrw,usb,plugdev。加入video组获得显卡的直接渲染支持，加入cdrom组以便访问光驱，如果有刻录机的话，加入cdrw组以便使用刻录机，等等。这些权限都是在文件权限上实施的。原理就是让对应的设备文件所有者设置为相应的用户和组
\footnote{内核自然没有UID,GID和账户对照表，默认创建的设备文件都是属于root:root的，文件所属权是由udev负责修改的。}。

文件权限的表示采用的是八进制表示法。

\begin{example}{一个 0664 权限模式的文件解析}

\end{example}

\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline \multicolumn{3}{|c}{所有者}&\multicolumn{3}{|c|}{组所有者}&\multicolumn{3}{c|}{其他}\\ 
\hline 读 & 写 & 执行 & 读 & 写 & 执行 & 读 & 写 & 执行 \\ 
\hline 1 & 1 & 0 & 1 & 1 & 0 & 1 & 0 & 0 \\ 
\hline 
\end{tabular} 

将 $ (110110100)_2 $ 使用八进制表示就是 $(0667)_8$。

\section{Shell 日常应用}

平常说学习shell神码的，其实是一个统称，实际上包括了一个shell和若干个shell能调用的工具。这些工具主要集中在 coreutils 和 linux-utils 包中。也就是说，学习shell不光是学个shell命令的语法格式，还包括一些常用工具的用法。没有这些工具的存在，shell能做到的事情是非常有限的。

shell是操纵电脑的接口。一切对电脑下达的指令都是shell代为执行的。要浏览网页？需要浏览器吧？可是浏览器不会自己动起来。需要下达执行浏览器的指令。shell理解了，然后执行了。
需要删除文件？可是文件不会自己消失。需要下达删除文件的指令。shell理解了，然后执行了。$\cdots$

shell的地位如此重要，以至于有人说，shell就是UNIX\footnote{Cygwin 提供了完整的UNIX命令，但并没有全部实现POSIX。尽管如此，cygwin虽然是一套Windows程序，还是被称呼为UNIX环境。}。

\subsection{bash名称的道听途说}


Bash是多数Linux发行版默认的shell。当然Gentoo也是不落俗套的默认为Bash了。Bash这个名字来源于\textbf{Bourne-Again SHell}。为什么说“又”（Again）呢？因为贝尔实验室发布的第七版UNIX——Unix Version 7搭载的正是\textbf{ Bourne SHell}， 这个shell由\textit{Stephen Bourne}编写。
FSF发扬自己借用UNIX名称的传统美德，给自己的shell起名为Bourne-Again SHell。

名字是借用的Bourne SHell，不过，如果认为它开发出来是为了替代Bourne SHell那就错了，bash诞生最初是为了替代 \textbf{Mashey shell 或者说 PWB shell} —— 这也是 Bourne SHell 所要替代的 。

\subsection{shell的字符串展开}

虽然已经在前面的 \secref{sec:quickbash} 介绍过，
不得不再次在这里重申，shell对字符串会进行分割后将其作为参数字符串数组传递给被调用者。而对于特殊的字符串会执行展开操作，更重要的是，展开操作是发生在字符串切分\textbf{之前}的。避免字符串展开的办法是加引号。同时引号也可以用于避免引号所包含的空格被用于字符串切割开。

会被执行字符串展开的除了带 * 和 ? 的通配符，还有 [] 和 \{\} 。 提醒一下，如果展开的时候没有匹配到适合的文件名，会自动取消展开而保留原字符串。

\subsubsection*{[ ] 的展开}

[~] 的用法是：[字母列表]。字母列表还可以使用a-z这样的简写形式表示连续的a-z而避免写全26个字母。

[~] 只展开为一个字符。

\begin{example}{~}

假设当前目录下有如下的文件:\\
a1 a2 a3 a4 a5 a6 a7 a8 a9 b1 b2 b3 b4 b5 b6 b7 b8 c1 c2 e1 e2

现在使用 ls [ab]1 这样的命令。[abef]1 会被扩展为 a1 b1 e1 三个文件名。

也就是说，传给 ls 的文件名参数有3个， a1 b1 e1。至于 f1 , 因为文件名不存在，也就不会扩展到。

如果使用的是 ls [gh]1 则会提示没有 [gh]1 这个文件。因为没有符合的文件名，所以表达式也就无从展开，以原样传给ls。

\end{example}

总而言之，可以认为 [~] 是一个过滤器，将符合表达式的文件过滤出来。如果没有一个文件名符合表达式的要求，则传递表达式本身。

\subsubsection*{ \{\}  的展开}

\{~ \} 的用法是：{字符串1,字符串2,字符串3,...} 空字符串也是可以接受的。但是连空字符串在内至少要包含两个字符串，否则不展开。

\begin{example}{~}

假设当前目录下有如下的文件:\\

m.c m.cpp m.o m.s m.h

现在使用 ls m.{c,cpp,h,lll} 这样的命令。m.{c,cpp,h,lll} 会被扩展为 m.c m.cpp m.h m.lll 四个文件名。

也就是说，即使文件名不存在，也会扩展到。因此除了显示m.c m.cpp m.h这3个文件信息外，还会提示 m.lll 没有这个文件。

如果使用的是 ls [gh]1 则会提示没有 [gh]1 这个文件。因为没有符合的文件名，所以表达式也就无从展开，以原样传给ls。

\end{example}

\subsection{shell变量和环境变量}
环境变量和shell变量都是字符串变量。使用的时候都通过 \$变量名 引用。shell会使用变量具体的值替换掉引用对象。
环境变量和shell变量在使用的时候没有区别。唯一的区别是环境变量会被子进程继承，而一般的shell变量只限在该shell中使用。
变量的赋值使用=号，不能两边有空格。

\begin{example}{变量展示}

下面的命令，将字符串“linuxbook”赋值给变量mybook,然后通过 \$mybook引用。shell会将\$mybook替换为“linuxbook”。

\begin{code}
mybook="linuxbook"
xelatex \$mybook.tex
xpdf	\$mybook.pdf
\end{code}
\end{example}

可是如果我已经有一个变量叫 my ， 则 my 和 mybook 两个变量会发生混淆：我实际想使用的是  \$my然后在后面接上book。但是shell会按照mybook变量来替换。

 取消这种混淆的办法是使用 \$\{变量名\} 进行引用。

\begin{example}{变量展示 -ver 2}

下面的命令，将字符串“linuxbook”赋值给变量texfile,然后通过 \$texfile引用。
将字符串"xelatex"赋值给变量tex,然后用 \$\{tex\}引用。

\begin{code}
\$~tex="xelatex" \\
\$~texfile="linuxbook" \\
\$~\$\{tex\} \$\{tex\}book.tex \\
\$~\$tex	\$texbook.tex
\end{code}


这里，“\$\{tex\} \$\{tex\}book.tex”时间上被替换后是执行的“xelatex xelatexbook.tex”。

可以把变量理解为一个宏，shell处理的时候会将\$和变量名本身 替换成变量的内容。

\end{example}

shell的变量不需要声明，给一个新变量赋值就是声明了。
一个变量使用 export 导出后就变成环境变量了，会被子进程继承。

比如这样设置环境变量USE给emerge：

\begin{code}
\$~ export USE=go  \\
\$~ emerge gcc
\end{code}

后续启动的任何子进程都将继承到USE环境变量。如果只想让本次的emerge继承到这个变量，可以用下面的形式。

\begin{code}
\$~ USE=go emerge gcc
\end{code}

这种情况下，USE会变成子进程 emerge 的环境变量，emerge结束后，USE变量就撤销了。

有关变量的另一个注意事项是，变量是在字符串展开之前替换的，也就是说，变量展开后，会继续对展开后的字符串再次进行字符串展开功能。使用单引号会禁止变量替换。

\begin{example}{字符串展开和shell变量}

\begin{code}
\$~ anyfile='*' \\
\$~ echo '\$anyfile'\\
\$~ echo "\$anyfile"\\
\$~ ls "\$anyfile"\\
\$~ echo \$anyfile\\
\$~ ls -d \$anyfile\\
\$~ ls \$anyfile\\
\end{code}

解释：
\begin{enumerate}
\item echo '\$anyfile' 变量没进行替换，所以显示结果为 \$anyfile

\item  echo "\$anyfile" , 变量被替换为 * , 所以显示的结果就是 * 
\item ls "\$anyfile" , 由上一条命令证实，变量被替换为 * ,显示结果却是 “ls: 无法访问*: 没有那个文件或目录”，表明引号禁止了字符串展开。
\item echo \$anyfile ，变量首先被替换为 * , 然后执行字符串展开，所以显示了当前文件夹的内容。
\item ls -d \$anyfile ， 变量首先被替换为 * , 然后执行字符串展开，所以执行结果和 ls -d * 一致。所以显示了当前文件夹的内容。不显示子文件夹内容，由 -d 参数保证\footnote{参考ls(1)}。
\item ls \$anyfile ， 变量首先被替换为 * , 然后执行字符串展开，所以执行结果和 ls * 一致。显示当前文件夹的文件和当前文件夹的子文件夹的文件。
\end{enumerate}


\end{example}



\subsection{shell和文件管理}

在任何系统下，用户都免不了要和“文件”打交到。印象中不需要和文件打交道的操作系统除了“Jarvis\footnote{Tony Stock的AI管家。也是钢铁侠衣服的辅助系统}”就不存在了。
以至于，有个操作系统认为操作系统的任务就是文件管理，把自己称之为磁盘操作系统（Disk Operating System）。

文件管理包括文件和文件夹的创建、重命名、删除和移动。多数情况下文件夹和文件是使用同样的命令进行操作，除了创建。

创建一个文件夹使用 mkdir 命令。

\subsubsection*{mkdir}

mkdir 是 make directiroy 的缩写。DOS/Windows 下的缩写为MD。

mkdir 接受一个或多个目录名作为参数。如果目录已经存在，mkdir会失败。加 -p 参数可以忽略已经存在的文件夹。

如果要想一次创建多个层次的目录，可以加 -p 参数。如 \texttt{mkdir -p a/b/c/d/e/f/g}。
文件夹创建后的访问模式默认为 0775。

mkdir的具体用法请参考mkdir(1)。


~ \newline

相比之下，创建文件的方法就多了去了。通常用户文件是由编辑器\footnote{不要光理解为文本编辑器啊，绘图软件也是图像文件的编辑器不是么。}创建。
另外创建空白文件的办法是使用touch命令。

\subsubsection*{touch}

touch 可不光是用来创建文件，还可以修改文件的最后修改时间——如果文件已经存在的话。

touch 的用法很简单，以文件名作为参数即可新建空白文件或者更新文件的最后修改时间。如果指定了 -d 或者 -t 还可以使用指定的时间作为文件的最后修改时间，默认使用当前时间。
-d 参数使用的格式同 date 命令的输出， -t 参数使用的格式为 [[CC]YY]MMDDhhmm[.ss]\footnote{[~] 表示可选。}。 
如:

\begin{code}
\noindent touch linuxbook.tex -d "2012-10-29 13:37:20"\\
\indent \quad 或者 \\
\noindent touch linuxbook.tex -t "201210291337.20"
\end{code}
touch的具体用法请参考touch(1)。


重命名文件和移动文件（夹）是同样的操作。使用的都是 mv 命令。

mv乃move的缩写，命令很简单：\texttt{mv OLDNAME NEWNAME}。具体用法请参考mv(1)。

复制的英文单词是copy，考虑到UNIX的神缩写传统，你一定不指望UNIX会使用copy作为复制文件的命令名称。没错，复制文件的命令名称也被缩写了，非常精简的cp。

直接使用cp的话并不能进行文件夹的复制。文件夹有子文件夹，子又有子，子又有孙，子子孙孙无穷尽。要拷贝一个文件夹，必然是一个递归的操作。所以拷贝文件夹需要添加 -R 参数。
至于符号链接\footnote{见 \faqref{faq:symlink}}，一般拷贝文件夹希望拷贝的是符号链接本身而不是符号链接指向的文件，所以加 -d 参数表示保留符号链接。这样拷贝文件夹通常使用法为“cp -dR 源文件夹 目标文件夹\footnote{-d -R 可以使用 -dR 这样的形式。对多数GNU软件适用。}”, 可以用 -a 代替 -dR 。

拷贝文件的时候提到了递归，提一下，删除文件也得递归。因为删除目录的系统调用rmdir(2)必须用在空目录上。所以对于一个非空的目录是不能删除的。
要删除一个非空文件夹，首先删除其下的所有文件和文件夹。对于非空的子文件夹，先删除子文件夹下的文件和文件夹。这就是一个递归操作了。
删除文件和文件夹使用rm(1)命令，rm默认不进行递归，所以对非空文件夹执行rm会失败。使用-r参数能让rm执行递归操作。


\subsection{管道和重定向}

UNIX管道在进程间架起了看不见的桥梁，联通了二者之间的输入和输出。而使用进程间的管道简单到只需要用“|”隔开两条命令。前一条命令的输出自动的就成为后一条命令的输入。

\begin{example}{统计portage拥有的软件包数目 - ver 1}
%ls /usr/portage/*-*/* -d | while read f ; do [ -d $f ] &&  ls -d $f  ; done | wc -l
\begin{code}
\$ls /usr/portage/*-*/* -d -1 | wc -l
\end{code}

通过前面的portage介绍可以知道，portage树的结构是  “分类名/包名/包名-版本.ebuild” 这样的2层目录。而“分类名”也是 “大类别-小类别” 这样的结构。
所以 “*-*”就可以匹配到类名而将 profiles eclass  licenses metadata scripts 这样的目录和 “header.txt skel.ChangeLog” 这样的文件排除掉了。连 virtual 目录都排除了。这样获得的文件夹的数目就是portage包含的包的数目。

等等，好像分类目录下，并不只是软件包名命名的目录。有的分类目录下有一个顶层的metadata.xml。描述一个分类里所有软件的公共信息。比如 \url{/usr/portage/games-fps/metadata.xml}。 这条命令似乎会把这样的 metadata.xml 算成一个目录而进入统计。
\end{example}


\begin{example}{统计portage拥有的软件包数目 - ver 2}

让我们进行改进，将第一次 ls 输出的文件名中，把非目录过滤掉：

\begin{code}
\$ls /usr/portage/*-*/* -d -1 | while read filename ;  \textbackslash \\
	\qquad do [ -d \$filename ] \&\&  ls -d -1 \$filename  ; done | wc -l
\end{code}

通过中间引入一层过滤层，把非目录过滤，这样 wc 获得的行数才是真正的包的数目。while这样的用法是shell循环语句，在下一个小节会详细介绍。

\end{example}

通过这2个例子相信已经能体会到管道的魅力了。

其实一个程序的输出何止是可以作为另一个程序的输入，本身也可以直接打印到文件中的嘛。在UNIX“一切都是文件”的哲学下，控制台对程序来说也是文件。既然都是文件，那么程序的输出除了可以输出到控制台或者通过管道输出给其他程序，自然也可以直接输出到文件中去。

不需要对程序进行任何修改，只要在shell里使用简单的技巧就能做到了。越是强大的功能用起来越是简单直接。重定向输出居然只是简单的使用 “>”就能做到了。

\begin{code}
\$ls /usr/portage/*-*/* -d -1 > portage\_ls
\end{code}

打开 portage\_ls 文件，看是不是输出被直接写入这个文件了？
多执行几次，你会发现文件并没有变大。因为shell在使用重定向的时候，会将原来的文件内容清空。使用 “>>” 即告诉shell使用追加模式。不清空原有文件内容，向文件末端追加。

既然输出可以重定向，那么输入也可以。否则怎么体现UNIX的灵活强大呢！

\begin{code}
\$ ( while read filename ; \textbackslash \\
	\qquad do [ -d \$filename ] \&\&  ls -d -1 \$filename  ; \textbackslash \\
	\qquad done ) <  portage\_ls > portage\_lsdironly
\end{code}

打开 portage\_lsdironly 文件，非目录是不是已经被过滤了？

最后一条命令：

\begin{code}
wc -l portage\_lsdironly
\end{code}

就获得了统计结果了。

这就不使用管道，完全使用重定向完成了同样的功能。不过多了一些中间文件，对吧？


\subsection{bash是门编程语言}

Bash作为一个shell是尽职的。有了各种实用小工具\footnote{已经在system集合里，默认安装，自行安装使用\#emerge coreutils）} 和管道的配合，shell能发挥出非常强大的作用。

不过，要想完全发挥shell的作用，就需要将shell作为一门编程语言，使用shell提供的判断和循环语句。

\subsubsection{条件判断}

shell之条件判断分两种，一种基于 if-then-else-fi ， 另一种是 cmd1 \&\& cmd2 和 cmd1 || cmd2。

我们首先介绍 cmd1 \&\& cmd2 这种形式的命令。

写过 "hello world" 程序的人都知道，main() 函数的最后都要有一个 “return 0;”。 这个返回值到底放回给了谁？答案是调用它的父进程。如果是shell调用的，就是返回给shell咯。
执行过一条命令后，通过 \$? 变量就能获得刚刚执行过的命令的返回值。

做个测试吧：

\begin{code}
\$ ls \\
\$ echo \$?
\$ ls /root \\
\$ echo \$? \\
\end{code}

第一次调用 ls 显示当前目录的内容，返回值很明显是 0 。第二次显示 /root ，很明显没有权限，返回值是 2 。

shell有时候必须知道一条命令执行成功还是执行失败，shell就是通过查看命令退出的时候的返回值判断命令是否成功执行的。像“ls /root”这样的命令如果不是以root权限执行的话，一定会因为没有权限而失败。 shell规定了，一条命令执行后返回0表示成功，非0表示失败。

这个成功和失败就用在了 cmd1 \&\& cmd2 和 cmd1 || cmd2 语法上。
简单的说，“cmd1 \&\& cmd2” 表示cmd1命令执行成功就执行cmd2。而“cmd1 || cmd2”表示cmd1命令执行失败就执行cmd2。

拿先前的例子来说，我在while循环里使用了一个判断 
\begin{code}
  [ -d \$filename ] \&\&  ls -d -1 \$filename
\end{code}

意思是，如果“ [ -d \$filename ]” 成功，执行“ls -d -1 \$filename”。

在shell中， “ [~] ” 的意思就是执行条件判断。
如“\texttt{ [ "a" = "b" ] }” 就表示判断字符串 "a" 和 "b" 是否相等。
 [] 对于表达式成立会退出码0,不成立为1。再依据shell对退出码所采取的行为，就能使用 [] 编写表达式是否成立的条件而执行的命令了。
 
在本利中， [ -d \$filename ] 的意思是判断 \$filename 是否为存在且为目录。
事实上。 [] 是 test 的别名。“test -d \$filename” 等价于 “ [ -d \$filename ]” 。 所以想知道 [] 的详细用法可以查看man手册 test(1) 。

\subsubsection{while循环}

例子中还有一个用到的shell功能就是循环。 bash shell支持while循环和for循环。

while循环的语法为 
\begin{code}

while cmd of condition ; do \\
	cmd1\\
	cmd2\\
	...\\
done\\

\end{code}

命令可以和 do 写在一行上也可以不写在一行上。
do如果不和while写在同一行，while后面的那个命令的“ ;” 就可以不写。

如果“cmd of condition”执行成功就执行 do 和 done 之间的命令。重复执行直到命令执行失败。也就是返回值不为0。


\subsubsection{until循环}

until循环和while循环语法一致，不过是用until替换while。


\begin{code}

until cmd of condition ; do \\
	cmd1\\
	cmd2\\
	...\\
done\\

\end{code}

不一样的是，until循环是条件不成立才执行的循环。而while循环是条件成立时执行。


\subsubsection{for循环}

while循环用户知道循环条件的地方，for循环用于知道循环的内容的地方。

for的语法为：

\begin{code}

for var in array ; do \\
cmd1 \\
cmd2 \\
... \\
done 

\end{code}


array 是一个字符串的集合。比如 “/usr/portage/*-*/*” 会导致 shell 将其扩展为数万个文件名的集合。for为集合中的每个元素运行一次循环。
每次循环，都可以用“\$var”引用集合中的一个元素。


例中命令使用 for 循环可以修改成这样，于是出现版本3：

\begin{example}{统计portage拥有的软件包数目 - ver 3}

\begin{code}
for f in /usr/portage/*-*/* ; do  \textbackslash \\
	\qquad [ -d \$f ] \&\&  ls -d \$f ; done | wc -l
\end{code}
\end{example}

除了用通配符制造的文件名，for 循环还可以使用数组。数组将在下面的章节中节介绍。


\subsubsection{字符串}

字符串是shell的基本数据类型。有多种方式可以进行字符串的操作。所以到现在才介绍，是因为日常使用很少需要用到字符串操作。

\begin{enumerate}
\item 合并字符串	

合并两个字符串的办法很简单，就是将连个变量“贴”到一起，如变量 A 和 B ， 获得 A 和 B 连接在一起的字符串的办法就是 {\tt "\$A\$B"}。

\item 字符串替换

\$\{var/查找字符/替换字符\}

	这个操作中除了第一个参数是变量外其它两个都是字符;还有一点就是这个操作并不是把变量“var”中的字符替换了，而是返回一个替换后的字符串。原字符串并没有被替换。
这个查找是正向查找，就是从左到右执行查找，把找到的第一个字符串替换到。执行反向查找使用的是这个语句：


\$\{var/\%查找字符/替换字符\}

上面两个查找替换都是找到第一个匹配的字符串进行替换，而下面这个可以执行全部替换。

\$\{var//查找字符/替换字符\}

以上所有的操作都不会修改原始变量var而是返回一个新的字符串。如果要修改原始变量可以把新的字符串重新赋值给var嘛！

\item 取子字符串

从一个字符串变量获取子字符串的语法

\$\{var:位置\}

从“位置”开始取子串到最后。默认是从左边开始，如果“位置”为负数，则是从右边的第“位置”个字符开始，并且第一个位置为0。 %
如果不取到结尾而是限定一个长度，可以使用下面的语法：
%例：
%str1=abcABCabc123ABC
%echo ${str1:(-3)}#会输出ABC

\$\{var:开始位置:结束位置\}


%\$\{字串\#匹配字串\}

%（说明一下，这个是从左边第一个开始匹配，剥去最短“匹配字串”） %
%例：
%str1=abcABCabc123
%echo ${str1#a*c}#输出ABCabc123
%(2)${字串##匹配字串}
%（说明一下，这个是从左边第一个开始匹配，剥去最长“匹配字串”）
%str1=abcABCabc123
%echo ${str1#a*c}#输出123
%echo ${str1#b*c}#输出abcABCabc123，因为没有从第一个开始匹配
%(3)${字串%匹配字串}
%(4)${字串%%匹配字串}
%（说明一下，这与上面的（1）（2）是正好相反的，是从最后一个开始匹配的）

\item  字符串长度

\$\{\#字串\} %

例： str=abcdefg

echo \$\{\#str\} 输出7

\end{enumerate}






\subsubsection{数组}

shell支持字符串数组。 %不过好像日常使用没什么大的用处。在编写shell程序的时候会用到。所以还是有必要知道一下。
数组的语法有三种

\begin{code}

(1) array=(var1 var2 var3 ... varN) \\
(2) array=([0]=var1 [1]=var2 [2]=var3 ... [n]=varN) \\
(3) array[0]=var1 \\
\leftskip=2em
    arrya[1]=var2 
    
    ... 
    
    array[n]=varN 
\end{code}

计算数组元素个数：
\begin{code}
\$\{array[@]\}  或者  \$\{array[*]\}
\end{code}

引用数组的语法是 （n为下标）：
\begin{code}
 \$\{array[n]\}
\end{code}

可以使用 for 循环来遍历数组。

\begin{example}{统计portage拥有的软件包数目 - ver 4}

\begin{code}
dirlist=/usr/portage/*-*/*

for f in \$dirlis  ; do  \textbackslash \\
	\qquad [ -d \$f ] \&\&  ls -d \$f ; done | wc -l
\end{code}

顺便一提，其实shell进行字符串扩展的时候生成的就是数组，数组再就地展开为命令参数。所以{}“dirlist=/usr/portage/*-*/*”{}这样的用法即让dirlist变量变成数组。


\end{example}

\subsubsection{读取输入}
在 \textbf{统计portage拥有的软件包数目} 例子中看到过 \texttt{while read f} 这样的用法。读者猜想这是读取输入到变量f的意思。
没错，正是这个意思。
准确的说， read 的与否是这样的：

\begin{code}
read var1 var2 var3 ...
\end{code}

read 从标准输入读取一行，并将一行中的字符串分别赋值给 var1 var2 var3 等等变量。字符串的拆分规则和命令行一样，使用空格分隔。如果拆分出来的字符串个数比命令行提供的变量多，最后一个变量将包含余下的所有字符串。

如果读取输入的时候遇到文件结束（在例子中，管道的输出方结束输出），退出状态就是非0，导致例子中while循环终止。

要读取文件可以使用重定向，比如
\begin{code}

读一行

read line < sometextfile.txt

或者读整个文件

while read line ; do

...

done < somefile.txt
\end{code}


\section{文件编辑器}\label{sec:editors}

日常使用Linux的过程中，无法避免的一件事就是要编辑文本。可以说，计算机除了“计算”之外的一大用途就是“编辑\footnote{不论是编辑文本还是编辑视频，通通都是编辑的说。}”。
Linux世界有好多非常优秀的文本编辑器。由于现在还未安装X服务，所以只能使用命令行模式的编辑器。在开源界，有两大编辑器派系。一个是vi和之后的改进版vim，被称为编辑器之神；
另一个是被称作神之编辑器的emacs。


\subsection{编辑器之神vim}

vim是vi的改进，全称是\textbf{Vi IMproved}。	%
%
\newcommand{\keyboradparty}[1]{
#1是最好的编辑器，没有之一。


对于键盘党\footnote{对惯用键盘操作电脑，提倡抛弃鼠标的人的称呼。}来说，让双手离开键盘是一种罪恶。
没有比让双手保持在键盘上更能发挥打字的速度了。不仅仅如此，#1 还罪恶的提出，双手不仅不能离开键盘，甚至连主键盘区都不能离开。
对光标位置的操纵，明明有直观的四个箭头按键， #1 还是采用的定义主键盘区的快捷方式来控制。双手不离开主键盘区是  #1 的设计宗旨之一。

#1 被初学者说成复杂的原因大概也缘于此吧！ 毕竟使用鼠标直接定位是最直观方便的操作方式了。再不济用键盘上的方向键也顶用多了。好在 #1 仍然支持使用方向键，只不过不推荐用户这么做。

“除了#1，其他编辑器神码的都弱爆炸了”，资深#1用户如是说，“这个世界上只有两种人，一种人使用#1,另一种使用其他。” 这大概就是{}#1{}在用户心目中的评价吧。

先安装#1

\begin{code}
\# emerge #1 -av \footnote{在安装任何软件之前，使用“-av”这样的参数让emerge先打印将要进行的操作，然后回答yes/no继续安装永远都是一个好习惯。}
\end{code}

}
%
\keyboradparty{vim}

%\marginpar{
可能依赖很多，不过可以去掉{}X{}，这样vim就不会引入X相关的依赖。
%}
%可能依赖很多，不过可以去掉X，这样vim就不会引入X相关的依赖。

\begin{code}
\# USE=-X emerge vim -av
\end{code}

耐心的等待片刻，新鲜出炉的vim就准备好了。

vim为了支持前面提到的“纯键盘”操作，把编辑器设定成两种工作模式：命令模式和输入模式。在命令模式下，按键盘的结果是每个按键都被解释成相应的命令。
输入模式下，按下键盘按钮会在当前输入位置（光标所处位置）输入对应的字符。\footnote{这里还是要废话一下，以免误导大家。只有能显示的字符才能输入。比如即便是输入模式下，按{\tt "Del"}键的结果也是删除字符而不是输入“Del”字符。因为“Del”并不是能显示的字符。还有方向键在任何模式下都是移动光标位置。能输入的，只有英文字母大小写A-Z和数字0-9以及0-9上方的字符，还有标点符号。}

命令模式下按“i”进入输入模式。

任何时候按“Esc”键都可以退出输入模式转到命令模式下。

在命令模式下，先输入“:”，会开启命令行模式，终端最下一行出现“:”提示并开始回显输入的命令。命令行模式下，输入完整的一条命令然后按回车，vim就会执行该命令。
比如保存并关闭文件的命令为 “:wq”。意思就是先退出到命令模式，然后输入“：”进入命令行模式，接着依次输入‘w’、‘q’并按回车。

在命令行模式下，按N次某命令，和先用数字输入次数然后再按下某个命令字符，效果是一样的。
比如：按10次‘j’向下移动10行，和依次按‘1’、‘0’、‘j’的效果是一样的\footnote{马上下文就讲到光标移动了}。

特別提示︰在浏览本教程時，不要強行记忆。记住一点︰在使用中学习。\footnote{如果用不到，就不用学了。:）}

\subsubsection{打开关闭和保存文件}


打开文件的办法有两个，一是在命令行上给出文件名，就像这样

\begin{code}
\$ vim 文件名
\end{code}

二是先打开vim然后使用命令模式 “:o 文件名” 打开文件。

保存文件使用命令“:w”

退出使用命令：“:q”。如果文件已经修改，vim会提示文件被修改，不能退出。使用“:q!”命令忽略修改强制退出，或者使用“:wq”保持并退出。



\subsubsection{移动光标}

除了使用键盘上的方向键，还可以使用 ‘h’、‘j’、‘k’、‘l’
这4个键代替。

{
\vspace{-3ex}
\begin{wrapfigure}{l}{0.4\textwidth}

 \tt \mbox{

\begin{tabular}{ccccccc}
 &  &  & \UParrow  &  &  &  \\ 
 &  &  & k &  &  &  \\ 
 &  &  &  &  &  &  \\ 
\LEFTarrow & h &  &  &  & l & \RIGHTarrow \\ 
 &  &  &  &  &  &  \\ 
 &  &  & j &  &  &  \\ 
 &  &  & \DOWNarrow &  &  & 
\end{tabular} 
}
\end{wrapfigure}{
%
~ \\
~ \\
\noindent
\leftskip=-2em
提示︰ \\
\leftskip=2em
		\hbox to 1em {h} 每次按下就会向左移动。\\
		\hbox to 1em {l} 每次按下就会向右移动。 \\
		\hbox to 1em {j} 每次按下就会向下移动。 \\
		\hbox to 1em {k} 每次按下就会向上移动。 \\
\vskip 3ex
}

}


\subsubsection{文本的编辑操作}

\begin{enumerate}
\item 删除:

	输入模式下，使用退格键和删除键删除光标前后的字符；命令模式下，使用x删除光标处的字符。“dd”（按两下d）删除光标所在行。
	“dw”（依次按下d和c键，下同）删除光标处的一个英文单词。“de”删除到行尾。

\item 插入：

	将光标定位到要插入的地方，按‘i’进入插入模式。按‘Esc’退出。\\
	将光标定位到要插入的地方，按‘a’进入光标后移动一个字符，插入模式。按‘Esc’退出。\\
	将光标定位到要插入的行，按‘A’就自动定位到行尾巴，并进入插入模式。按‘Esc’退出。

\item 区域选择：

	选择一个区块通常是“复制”和“剪切”操作的前奏。
	命令模式下，按‘v’就进入区块选择模式，并定义区块的起始位置。移动光标选择终止位置。被选中的文本会反白显示。

\item 复制：

	选择好区块后，按‘y’。选中的文本会被拷贝到vim自己的剪切板。

\item 剪切：

	选择好区块后，按‘d’。选中的文本会被剪切到vim自己的剪切板。
	
\item 粘贴：

	在命令模式下，按 p 就可以把vim自己的剪切板的内容粘贴到光标位置。vim不是X程序，不能使用X界面的剪切板哦。

\item 撤销：

	按‘u’撤消最後執行的命令，按‘U’來修正整行。

\end{enumerate}


\subsubsection{从vim那获得帮助}

由于本书定位是“入门”，所以高级的vim话题就不探讨了，有兴趣的同学可以参阅其他书籍。通过本小节的阅读，使用vim编辑配置文件之类的工作应该能胜任了。

惊愕的是，vim居然自带了教程！使用



\begin{code}
\$ vimtutor
\end{code}

就能打开这个教程了。默认会打开本地语言版本的教程！如果你的本地语言设置不是中文\footnote{到\secref{sec:lang}脑补。}，使用 

\begin{code}
\$ vimtutor zh
\end{code}

即可打开。虽然是繁体中文，不过阅读上并无大碍。



\subsection{神之编辑器emacs}

emacs是GNU出品的正牌编辑器，出自RMS大神之手。故称之为神之编辑器。
%
\keyboradparty{emacs}


可能依赖很多，不过可以去掉X和gtk，这样vim就不会引入X相关的依赖。

\marginnote{可能依赖很多，不过可以去掉{}X{}和{}gtk{}，这样vim就不会引入X相关的依赖。}

\begin{code}
\# USE="-X -gtk -gtk3" emerge emacs -av
\end{code}

耐心的等待片刻，新鲜出炉的emacs就准备好了。

和vim不一样，emacs并不使用命令模式和输入模式这样的区分\footnote{因为这意味着在码字的过程中要不停的按‘Esc’和‘i’切换模式。}。
emacs下所有的命令都是立即可用的，不会要求你时刻记住当前工作模式并随时准备切换。


%TODO
\todo{写更多的 emacs 入门}


~


\section{系统管理基础}

如果一个系统能自发的自我维护就好了。不过这种系统目前只存在于Tony Stock的家里。想好好的用Linux干活，一些基本系统的维护知识还是必要的\footnote{汗！用惯了Windows的小白表示从来不进行系统维护。定期重装或者安装个还原系统。一般品牌笔记本不都会带个系统恢复功能么？}。
它可以在让你永远不会遇到系统瘫痪而必须重装的问题，或者就算瘫痪了都能起死回生。


\subsection{进程管理}
\subsection{系统服务管理}

%\section{shell 进阶应用}


\chapter{软件管理}\label{软件管理}



\section{软件的分发}
\section{软件的编译}
\section{发行版的包管理}\label{section:pkgmgr}
\section{portage和emerge}\label{sec:emerge}

\section{什么是overlay，如何使用}\label{sec:overlay}

/usr/portage下存放了数万个ebuild文件，这些文件按照预定的格式组织，形成了Gentoo的软件仓库，又称portage树。
使用命令{\tt emerge --sync}可以方便的将本地的portage树与Gentoo官方发布的portage树进行增量同步。

portage里虽然有数万个\footnote{截至到本书写作的时候有32225个ebuild共计15731个软件。}ebuild，但是总有软件是游离在portage之外的。
总要有机制可以添加第三方仓库吧？这样有的特殊软件可以放到第三方仓库中，想要使用的人添加第三方仓库即可使用emerge安装这些软件。
用户还可以自己维护一个给自己用的仓库，编写自己用的ebuild，这样就有可以更强大的定制能力了。
Gentoo使用overlay来支持这种需求。

所谓overlay就是结构和portage一样的一个目录，该目录里存放的ebuild也会被emerge使用。如果overlay里的版本和portage里的一样高，则overlay里的ebuild有更高的优先级。
overlay通常包含portage没有的软件，或者相同版本但是打上不同的补丁以提供增强功能。只要在 make.conf 中设定 PORTDIR\_OVERLAY 为一个overlay的路径即可使用该overlay。
overlay可以有多个，亦即PORTDIR\_OVERLAY可以设定多个路径，以空白隔开（通常是每行写一个overlay，参考 /var/lib/layman/make.conf），相互之间的优先级看它在PORTDIR\_OVERLAY变量中出现的次序。后出现的优先级高。

\subsection{用layman管理overlay}

现成的overlay被gentoo官方收录到了一个xml文件中：

\url{http://www.gentoo.org/proj/en/overlays/repositories.xml}

使用layman(8)工具即可自动获取这些overlay。这些overlay使用版本控制工具\footnote{参考 \chapref{chap:VCS}}，用户也使用版本控制工具获得这些overlay。
所以layman依赖一些版本控制工具，可以用USE控制layman依赖的版本控制工具。

\begin{code}
\#USE="git subversion" emerge layman
\end{code}

这样会将 git 和 subversion （大部分overlay使用git和svn）作为 layman 的依赖而被自动安装（如果还没安装的话）。没有安装的版本控制工具将无法添加使用该工具管理的overlay。

在 make.conf\footnote{ /etc/portage/make.conf 别忘记哦！} 里最后加入一行 “{\tt source /var/lib/layman/make.conf}”（不包括引号）， 然后就可以使用 layman -a overlay名字 添加指定名字的overlay了。

\begin{insertnote}
注意：/var/lib/layman/make.conf只有在添加了第一个overlay后才会生成。所以可以在添加一个overlay后再加入对该文件的source操作。
\end{insertnote}

\begin{example}{添加 gentoo-zh overlay。}
\begin{code}
\#layman -f \\
\#layman -a gentoo-zh
\end{code}

第一次使用layman需要layman -f，这一步到gentoo.org下载repositories.xml文件。如果已经下载过可以跳过这条命令。

\end{example}

\subsubsection*{列出所有的overlay}

\begin{code}
\#layman -L
\end{code}

\subsubsection*{列出已经添加的overlay}

\begin{code}
\#layman -l
\end{code}

\subsubsection*{添加一个overlay}

\begin{code}
\#layman -a <overlay名字>
\end{code}

\subsubsection*{删除一个overlay}

\begin{code}
\#layman -d <overlay名字>
\end{code}

\subsubsection*{更新一个overlay}

\begin{code}
\#layman -s <overlay名字>
\end{code}

\subsubsection*{一次性升级所有overlay}

\begin{code}
\#layman -S
\end{code}


\chapter{图形界面}
对命令行是不是有点枯燥了？是时候来点新鲜的东西了 只所以现在才讲，因为图形实在是太复杂了。说Linux图形系统的复杂度已经超过所有其他子系统的总和都不为过。

所有的图形系统，都有一个“指点”设备。图形界面是一种“看得见”的界面，同时需要有种东西能模拟“摸得着”。模拟“摸得着”就需要“指点”设备。通常在桌面型电脑上是鼠标，而在平板电脑上则是触摸屏。“指点”设备告诉计算机，用户“指”的地方和“点”的地方。

除了“指点”设备，传统的键盘也是一个重要的组成部分\footnote{在平板上，键盘被取消了。取而代之使用屏幕键盘和手写输入法}。键盘和指点设备都是用户输入设备。

图形界面下，多个图形程序相互之间共享输入设备和输出设备。输出设备通常就是指的屏幕。

同控制台程序只能接收字符化的用户输入和输出字符串相比，图形程序能输出表意更直观的图像，接收的输入也更为复杂——有鼠标事件，有键盘事件，还有其他图形程序发来的消息，更有系统发送的重绘消息。

由于系统要进行多任务处理，输入和输出设备就不可避免的需要进行共享。完成这个共享的，就是操作系统的窗口系统。

\section{窗口和图形}

窗口是一块有属主并能联接到输入设备的屏幕区域（通常这个也是一块矩形区域）。这块有属主的区域可以为其所有者所控制，接受输入设备的输入并用来输出图形信息。

在操控系统控制的屏幕上有且只有一个窗口能接受键盘输入。接受键盘输入的窗口被称为当前窗口。用户敲击键盘所产生的输入事件被发送给当前窗口，并由该窗口的所有者接受输入事件。

用户可以移动和切换窗口。某个窗口变成当前窗口的操作称为激活。被激活了可以接受到键盘输入的窗口被称为拥有了键盘焦点。
键盘事件总是发送给拥有键盘焦点的窗口。
窗口之间可以相互遮挡，被称为窗口Z轴层级。
拥有焦点的窗口需要处在顶层，所以被激活的窗口总是自动被提升到顶层。
鼠标被移动的时候需要向鼠标经过的窗口发送移动事件。鼠标点击的时候向被点击的鼠标发送点击事件。

从上面的描述可以推测，操作系统的窗口系统的主要任务有：

\begin{enumerate}

\item	提供输入设备的共享。鼠标消息总是发送给鼠标所在的窗口。键盘消息总是发送给拥有键盘焦点的窗口。键盘焦点可以切换。

\item	维护窗口的位置、大小等属性。

\item	管理窗口父子关系。

\item	维护窗口层级。



\end{enumerate}

\section{X 的历史}

TODO： X 是一个窗口系统，那么X为什么采用了 C/S 结构呢？
\subsection{ 窗口管理}
\subsection{ 渲染库和静态链接}
\section{桌面环境}
\subsection{GNOME}
GNOME 是事实上的标准。各个主流发行版的默认桌面环境。
\subsection{ KDE XFCE 和其他}

\section{  办公和打印	}
\subsection{  LibreOffice	}
\subsection{使用CUPS 打印文档	}
\section{ 声音的那些事	}
\subsection{  声音的数字编码	}
\subsection{  逐渐被遗忘的OSS	声音架构}
\subsection{ ALSA 高级Linux声音架构}
\subsection{  PulseAudio 优秀的声音服务器	}
\subsection{  播放器	}
\section{  让游戏放松自己	}
\subsection{  OpenGL 和 Mesa	}
\subsection{  硬件加速	}
\section{  Wayland	}
\subsection{ X 的错误	}
\subsection{  直接渲染}

\chapter{网络}\label{chap:network}
\section{  网络基础知识}
\subsection{  通信基础}
\subsection{  IP地址和TCP/IP协议}
\subsection{  路由表和路由协议}
\subsection{ 以太网和WIFI}
\subsection*{  小插曲：永恒的以太网}

\section{网络配置\label{sec:ifconfig}}
\subsection{  图形环境下的工具	}
\subsection{ 命令行配置工具}
\subsection{ 网络自动配置和DHCP}
\section{  网络攻击和防火墙	}
\subsection{ 网络攻击类型和检测}
\subsection{  iptables防火墙}

\chapter{文件系统}
\section{  磁盘上的文件系统	}
\subsection{  块设备和磁盘}
\subsection{ 超级块和inode}
\subsection{  典型磁盘文件系统举例}
\section{  虚拟文件系统	}
\subsection{  /proc内核信息窗口}
\subsection{  /dev设备文件系统和udev}
\subsection{  虚拟内存盘tmpfs}
\section{  网络文件系统	}
\subsection{  NFS	}
\subsection{  Windows 网络邻居 CIFS	}
\section{  其他的文件系统	}
\subsection{  LiveCD的最爱——压缩文件系统squashfs}
\subsection{  为Flash芯片设计的文件系统}

\chapter{架设服务器}
\section{  搭建 HTTP 服务器}
\subsection{  apache 用的最多的服务器}
\subsection{ nginx 轻量级服务器}
\subsection{ lighttpd 超轻量级服务器}
\subsection{ squid 加速代理	}
\section{  数据库	}
\subsection{  最流行的开源数据库 MySQL}
\subsection{  最优秀的开源数据库 PostgreSQL 	}
\subsection{  商业霸主 OracleDB	}
\section{  加速 DNS ，在本机搭建 DNS	}
\section{  共享打印机	}
\subsection{ CUPS 打印服务	}
\subsection{ Samba 打印机共享	}


\chapter{压榨机器的性能}

这个世界上有许多人总是说，计算机处理能力已经过剩了。

不，从没有。计算机的处理能力从来就没有过剩过。如果说过剩，只能说，他从来就不需要计算机。计算机硬件的发展速度永远跟不上人对计算能力的爆发性增长的需求，
调和这个矛盾的唯一办法就是进行优化。所谓优化，就是不改变功能的前提下让程序执行的更快，占用的资源更少。

优化可以在好几个层面进行。从最底层的汇编优化再到最高的设计优化，每个层级都有优化的可能。

\begin{enumerate}
\item 设计优化	~	即使是同样功能的程序，也拥有不同的设计。不同的设计通常导致非常差异化的编码思路，从根本上影响到一个系统的效率。不同的设计导致关键逻辑上采取了不同的算法，很大完成同样功能的不同的算法有根本上的效率差距。

\item 代码优化	~	编写程序的时候，即便是相同的算法和设计，也有机会选择不同的代码描述形式。参数传递是采用指针还是对象？编写宏还是函数？等等。这些因素也会影响到最终代码的效率。
好的代码\footnote{那种一眼看上去就知道代码要做什么。}总是比写的烂的代码\footnote{让人看了半天没看明白，格式混乱，诸如此类的代码}更讨人喜欢。但是好的代码并不总是能生成优化的结果的代码。有时候为了最终编译后的程序的执行效率，会采取一些trick编写代码，一些trick能极大的提高代码的执行效率，但是大大降低了代码的可读性。现代程序普遍不再使用trick，只编写具有良好可读性的代码。把优化的工作交给优化编译器。

\item 构建优化	~	通常一个软件项目包含多个功能模块，每个模块使用多个编译单元\footnote{一个源代码文件就是一个编译单元}, 通过一套构建系统\footnote{autotools,cmake,qmake等等。}调用编译器生成最终结果。许多软件可以将其中一些功能列为可选，禁用的可选功能直接导致跳过编译对应的编译单元。
这被称为条件编译。条件编译也可以发生在编译单元内部\footnote{学过C语言的人都知道，\#ifdef ... \#endif 预处理指令就是干这个的}。
通过条件编译，使得一些用不到的功能代码被排除在最终可执行文件之外。减少了冗余代码，节约了程序运行时所占用的资源。

\item 编译优化	~	编译器能“读懂”源代码并将其转化为等价的二进制指令。在这个过程中，如果加入优化过程，编译器能删除\footnote{这里的删除并不是编译器将代码从源文件中删除，而是说是编译器并不将其转化为机器指令，而是直接丢弃。}冗余代码\footnote{源码中存在的但是实际上编译器发行并没有被调用的函数，会被删除。一些做无效操作的代码被删除。一些重复操作被编译器合并为一个操作.}，常量折叠\footnote{将相同的数据合并}，常量表达式\footnote{编译器在编译的时候发行一些表达式的值是固定可知的，而且在编译期就能求得，故在最终程序中使用一个常量代替直接计算表达式}优化，循环展开等等。

\item 特定CPU优化	~	其实这也是编译优化的一部分。这里单独列出来讲一下。在CISC\footnote{复杂指令计算机，参考 \faqref{FAQ:CISCandRISC}}指令的计算机上，由于指令繁多，编译器具有较大的选择余地。同时，一种指令在一款CPU上执行较快，而做另一款CPU上则执行的较慢。这使得编译器无法正确的作出最优的选择，因为对于某个型号的CPU的最优选择并不适用于另一个型号。汇编优化的意思就是指定为某个特定的CPU上选择生成对于该CPU而言最快的指令。例如同样是浮点操作，在x86平台可以使用x87指令集或者使用SSE指令。某些型号的处理器，x87指令的速度和SSE的速度不相上下，而x87的精度要比SSE高，就因该尽量使用x87指令进行浮点运算。而有的型号，x87速度比SSE指令慢好几个数量级，自然优先使用SSE指令\footnote{除非用户表明了使用双精度浮点数}。不仅仅为某个特定型号的CPU进行优化有可能再另一个CPU上起反效果，有些指令并不是所有的CPU都支持的。例如SSE指令只在奔腾3以上的CPU中才支持。avx指令更是只有在sandy bridge\footnote{intel 2011年发布的core2处理器的代号}中才支持。如果软件使用了 core2指令，放到非2011年前生产的CPU中可全部无法运行了。所有通常二进制发布程序都不为用户所使用的CPU进行专门优化，这也丧失了一大性能。

\end{enumerate}

使用Gentoo的时候，由于我们只是用户，并不是上游软件开发者，虽然无法在设计上改动上游的代码，但是我们手里能控制的还有编译优化和构建优化。将不需要的功能通过USE选项筛剪，并调节编译器的参数生成为本机的CPU优化的最优指令。这也是portage给我们的最强大的武器。

\section{最廉价的优化 – 编译优化}

%优化的理论依据是，
现代程序通常由高级语言编写，使用编译器将其编译为机器可执行的二进制指令。在这个转换的过程中，事实上存在无穷多个可能的结果
\footnote{从源程序获得最优化的结果是个NP完全问题。}。正所谓条条大路通罗马。
人们对编译器的期望是，它总能够选择其中执行速度最快的那个作为最终结果。所谓执行速度最快，通常是完成同样的功能使用最少的指令，或者指令序列总执行时间最短。
这也是编译器能对程序进行优化的依据。

\subsection{编译期优化}
前面提到过，生成最优结果对编译器来说是个NP完全问题\footnote{所谓NP完全问题，就是说在“有限”的时间内无法找到最优解的问题}。编译器必须能在有限的时间内给出编译结果。所以编译器提供了“优化级别”概念。

所谓优化级别，就是给出编译器执行优化过程的时候所尽的“努力”程度。最高级别的优化就是尽最大的努力生成编译结果。通常生成的结果运行速度最快，但也意味着最费时的编译。
最低级别的优化就是不优化，编译速度为最快，生成的结果程序的运行速度也是最慢的。

对GCC编译器来说，优化级别由参数 -Ox 指定。x是一个  0 到 3 之间的数字。数字越大，优化级别越高。0表示不优化,如果不给出优化级别，默认就是0。
对用户来说，只要知道使用“-Ox”参数开启指定级别的优化即可。

emerge{}使用的编译优化参数由 make.conf(5) 文件中的{ }CFLAGS{ }和{ }CXXFLAGS{ }指定。通常指定\texttt{"-O2 -march -pipe"}，其中的-O2即指定优化级别为2。这是Gentoo推荐
的设置。虽然说-O3有可能带来更好的性能。但是激进的优化措施有时候会带来意想不到的问题。为保守起见，Gentoo只推荐全局启用-O2级别的优化。

GCC支持另一个特殊的优化级别：-Os。‘s’在这里的含义是size，也就是为大小进行优化。

\begin{insertnote}
\subsubsection{什么是为大小优化？}

编译器进行优化的时候，有时候会碰到代码大小和执行速度的矛盾。有的代码可以优化为更少的指令，但是每条指令都更复杂，导致总执行时间更长；或者优化为更多的指令，但是每条指令更简单，而且在超标量处理器上能做到指令级的并行执行，总执行时间反而更短。
虽然说大部分情况下，更少的代码总是意味着更快的执行速度，但是遇到某些特殊情况时，编译器就必须作出代码大小和执行速度的权衡。
-Os{}优化级别就是告诉编译器，在遇到代码大小和执行速度两难的境地，优先考虑代码大小，使用让代码体积更小的优化措施。

\end{insertnote}

一些人认为，只有为内存受限的特定环境编写程序时才考虑-Os优化。但是Linus在一次邮件中鲜明的指出，至少在x86平台，-Os优化生成的结果总是最快的。下面列出邮件原文。

\begin{insertnote}

\subsubsection*{Linus讨论-Os和-O2的邮件}

\leftskip 2em
\rightskip 2em
\parindent 0pt

\colorbox{gray}{\hbox to 5em {Date} Thu, 6 Feb 2003 15:16:16 -0800 (PST)}

\colorbox{gray}{\hbox to 5em {From}	 Linus Torvalds <>   }

\colorbox{gray}{\hbox to 5em {Subject}	Re: gcc -O2 vs gcc -Os performance }

\footnotesize 

\parskip 4ex

\noindent{}On Thu, 6 Feb 2003, Martin J. Bligh wrote:\\
> \\
> The observation re low repeat rate is interesting ... might be amusing \\
> to do some really basic profile-guided optimisation on this grounds,\\
> take readprofile / oprofile output, and compile the files that don't\\
> get hammered at all with -Os rather than -O2. Given their low frequency\\
> (by definition), I'm not sure that improving their icache footprint will\\
> have a measureable effect though.

Icache footprint has nothing to do with repeat rates, which is exactly why 
repeat rates are interesting for -Os.

Icache footprint is directly proportional to the \_static\_ size of the code 
(ie exactly the thing that -Os is supposed to optimize for), while 
instruction-level performance measurement is only valid on the \_dynamic\_ 
code.

And with modern CPU's with big caches, a \_lot\_ of cache misses are the 
forced kind - the startup costs, not the actual runtime cost. That's not 
always true (if you touch big data sets, you'll have replacement misses 
too, of course), but it's not really false either.

So think of the I\$ (and TLB, and page load/map - all the same) cost as a 
fixed cost that will always be there, but that -Os tries to minimize. 
That's \_one\_ dimension in the total cost.

The "traditional" -O2 kind of "try to make the code run fast" 
optimizations tend to try to minimize a totally different dimension, 
namely the dynamic code speed.
And the time required for running the program is the sum of the static and 
dynamic factors. In other words, a \_good\_ optimization should try to 
minimize not one or the other, but the sum.

And low repeat rates means that the dynamic component is smaller, which 
clearly makes the static component more important.

For example, if you are doing mp3 encoding, the repeat rates for the core 
loop are huge, and the code is small, so clearly the static component is 
largely insignificant. Use -O2.

But if you're running a GUI program then just the loading time is often
quite noticeable, and if you can improve that by, say, 10%, then that can
\_more\_ than make up for almost any amount of stupidity in your code.  
Especially since a lot of the code isn't even all that loopy and tends to
have low repeat rates. You're almost guaranteed to be better off using -Os
than -O2.

If you've got performance counter data, check the I\$ and ITLB miss ratios, 
and if they are at all noticeable, think about the fact that a I\$ miss 
tends to cost a lot more than a few more dynamic instructions. 

I suspect the kernel I\$ behaviour is generally pretty good, and the ITLB 
behaviour is improved even further thanks to large pages etc. That said, a 
user app that blows the I\$ will blow the kernel out of the I\$ too, so 
small is always beautiful, even in the kernel.

\qquad Linus

--\\
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in \\
the body of a message to majordomo@vger.kernel.org \\
More majordomo info at  \url{http://vger.kernel.org/majordomo-info.html}\\
Please read the FAQ at  \url{http://www.tux.org/lkml/}

\end{insertnote}

在邮件中，Linus指出，CPU的指令缓存是有限的，更小的代码意味着程序能将自身更多的部分放入指令缓存从而带来指令缓存命中率的提升。更大的代码导致CPU更多的发生 Icache miss（指令缓存不命中），指令缓冲一旦没有命中，CPU不得不暂停执行到内存读取指令并刷新指令缓存。众所周知，CPU之所以有缓存设计，就是因为内存无法和CPU同频运行。
CPU的一级缓存是单周期访问的，但是容量有限。通常只有数十KB；而二级和三级缓存虽然大很多\footnote{在i7级别的CPU上三级缓存有8MB。但是入门级别的CPU可能就没有三级缓存}，但是访问时间却要好几个时钟周期；但是内存的访问是更慢的了，达到数十个周期。也就是说，如果一次Icache miss发生，CPU将会浪费几十个周期到二级和三级缓冲刷新，但是如果三级缓存中都没有，必须到主内存刷新，浪费的时钟周期将达数百个\footnote{缓存刷新的时候会执行预读取，所以浪费的是数个内存访问周期。}。随着CPU主频的提升，访问一次内存导致的CPU时钟周期浪费也会越来越高。更大的指令除了导致更容易出现Icache miss，也导致可执行文件变的更大，也将是初次加载的
时候要花费更多的时间将代码从硬盘读取到内存。

不论是从运行时的速度上考虑还是从加载速度上考虑，更小的代码总是意味着更快的速度。更何况将算没有将缓冲填满，更小的代码也给其他程序留下了更多的缓存空间。所以整个系统以-Os参数进行优化似乎能获得从整体而言最快的系统。



\subsection{链接时优化（LTO，Link Time Optimization）}

Linux系统从内核到应用程序，几乎都是由C/C++语言写成的。C家族语言都需要经历“编译”$\Rightarrow$“链接”的过程才能最终转化为可执行文件。

C家族语言的源代码是分开编译的。一个程序通常会包含多个源代码文件，每个源码文件分别编译，最好执行链接合并成一个可执行文件。

大多数优化都是发生在编译的时候。


\subsection{PGO}
\section{  有目的的优化 – 查找性能瓶颈}
\subsection{ 查找性能瓶颈}
\subsection{  优化瓶颈}
\section{  benchmark – 优化的基准测试}
\subsection{  CPU 单核能力测试}
\subsection{  CPU 多线程性能测试}
\subsection{  文件系统 IO 测试}
\subsection{  网络性能测试}
\subsection{  GPU/OpenGL 性能测试}


\chapter{时光机器-版本控制系统}\label{chap:VCS}
\section{   历史和后悔药	}
\section{   中心式版本控制仓库 CVS	}
\section{   CVS 后继 SVN	}
\section{GIT 划时代的分布式版本控制\label{sec:git}}
\subsection{  Bitkeeper	}
\subsection{  Linus 消失的一周	}
\subsection{  版本控制设计为一个文件系统	}
\subsection{ 去中心化	}
\subsection{  GIT典型工作流	}
\subsection{  GIT 简单使用	}


\appendix

{ \include{faq} }

%{ \include{wars} }

{ \include{manpage} }


\chapter{名称缩写}

\chapter{图片索引}
%\cleardoublepage
{
\renewcommand{\cleardoublepage}{}

\renewcommand\listfigurename{}
\vskip -3cm
%\addtocounter{chapter}{1}
%\addcontentsline{toc}{chapter}{图片索引}
\listoffigures 
%\cleardoublepage
}

\include{app_gentoolife}

\end{document}
