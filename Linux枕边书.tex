% !TeX spellcheck = <none>

\newcommand{\compileall}{def}


\documentclass[amstex,twoside]{ctexbook}

% 16开本
\usepackage[
		paperwidth=195mm,
		paperheight=271mm,
		%装订线宽10mm,页边距 28mm
		lmargin = 38mm,
		rmargin = 28mm,
		tmargin = 36mm,
		bmargin = 30mm
	]{geometry}

\usepackage{needspace}
\usepackage[below,section]{placeins}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{soul}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage{amsthm}
\usepackage{stmaryrd}

% always load hyperref as last packages
\usepackage[colorlinks,linkcolor=black]{hyperref}

%\input{draftcopy}

%=====================================================================================
% font setting
%=====================================================================================
\input{setfonts}

%=====================================================================================
% define new command and environment 
%=====================================================================================

%=====================================================================================
% define new command and environment 
%=====================================================================================
\newenvironment{notice}{\tt}{}
\newenvironment{insertnote}{ \ttfamily\CJKfamily{KaiTi} }{\vskip 0.5cm }
\newenvironment{code}{\small\tt\begin{longtable}{p{0.8\textwidth}}}{\end{longtable}}

\newcommand{\RTLpar}{% right-to-left paragraph alignment
  \leftskip=0pt plus .5fil%
  \rightskip=0pt plus -.5fil%
  \parfillskip=0pt plus .5fil%
}

\newenvironment{quotes}[2][0.55]{\pushQED{#2}%
\begin{flushright}%
\begin{minipage}{#1\textwidth}\begin{flushright}\noindent\it\RTLpar}{%
 \\------\popQED{}\end{flushright}\end{minipage}\end{flushright}\vskip 8mm }%

\newcounter{lizi}[chapter]

\newenvironment{example}[1]{ \addtocounter{lizi}{1} \vskip 2.5ex \bf 例\hskip -0.05em\arabic{chapter}.\arabic{lizi}： #1%
\par %
 \tt\small\CJKfamily{zhfs}}{ \vskip 2.5ex  }

\newcommand{\theexample}{\arabic{chapter}.\arabic{lizi}}

\makeatletter\newcommand{\chatu}{\@ifstar%
                     \chatuStar%
                     \chatuNoStar%
}\makeatother

\newcommand{\chatuNoStar}[3][scale=0.35]{%
\begin{figure}[h]%
\noindent\centering%
\includegraphics[#1]{pics/#2}%
\caption{#3\label{fig:#2}}%
\end{figure}%
}


\newcommand{\chatuStar}[3][scale=0.35]{%
\begin{figure*}[!h]%
\noindent\centering%
\includegraphics[#1]{pics/#2}%
\label{fig:#2}%
\end{figure*}%
}


\newcommand{\faqref}[1]{~附录A.\nameref{FAQ}~“\nameref{#1}”}
\newcommand{\secref}[1]{节\ref{#1}~\nameref{#1}}

\newcounter{faqs}

\makeatletter
\newcommand\@publisher{}
\newcommand{\publisher}[1]{
\renewcommand\@publisher{#1}
}

\newcommand\@company{}
\newcommand{\company}[1]{
\renewcommand\@company{#1}
}
\makeatother


%=====================================================================================
% style settings
%=====================================================================================

% 阿拉伯数字章节
\setcounter{chapter}{-1}
\CTEXsetup[number={\arabic{chapter}}]{chapter}
% 对齐设置
\tolerance=4500
\punctstyle{hangmobanjiao}
\CJKecglue{}
\CJKsetecglue{} %{\hskip 0.1em plus 0.05em minus 0.05em}

%=====================================================================================
% book info
\input{bookinfo}
%=====================================================================================


\begin{document}

%=========================================================
% 首页
%=========================================================
{

\include{coverpage}
\include{thanks}
}

%=========================================================
%目录
%=========================================================
\tableofcontents

%=========================================================
% 序言
%=========================================================
\ifdefined\compileall
	\include{preface}
\else
	\addtocounter{chapter}{1}
\fi


%=========================================================
% 正文开始
%=========================================================

\ifdefined\compileall
\include{chp_unix}
\else
\addtocounter{chapter}{1}
\fi 

\ifdefined\compileall
\include{chp_hackerandlinux}
\else
\addtocounter{chapter}{1}
\fi 


\chapter{初识Linux}

\begin{quotes}[0.63]{Linus~Torvalds}
To kind of explain what Linux is, you have to explain what an operating system is. And the thing about an operating system is that you're never ever supposed to see it. Because nobody really uses an operating system; people use programs on their computer. And the only mission in life of an operating system is to help those programs run. So an operating system never does anything on its own; it's only waiting for the programs to ask for certain resources, or ask for a certain file on the disk, or ask to connect to the outside world. And then the operating system steps in and tries to make it easy for people to write programs.
\end{quotes}

Linus发布他的内核的时候，Linux就只是一个内核而已。一个操作系统不当当依靠一个内核就能工作。还需要各种程序供用户使用。最少的，用户需要一个shell进行人机交互。
用户需要管理磁盘，管理他的文件。等等操作都需要依靠各种各样的程序进行。如果用户只是将Linux内核运行起来，那他将什么都做不了。所以用户需要的，是一个Linux内核和一套工具软件。这样的组合才能构成用户操作机器的环境——也就是说，一个操作系统。于是人们有时候简单的称呼这样的操作系统为Linux。但是我们得知道，这只是泛称，Linux的实际含义就是Linus和其他黑客开发的一个内核，并不是一个完整的操作系统。

由于Linux只是一个内核，所以用户需要的工具软件就需要向别的地方寻找了。所幸RMS宣誓的GNU已经开发的差不多了，就只差个名字叫GNU Hurd的内核。等等，我们不是有Linux内核了么？

没错！只要我们将GNU的系列软件和Linux内核搭配起来，不就有一个完整的操作系统了么？我们需要一个shell, GNU bash就是我们要找的。我们需要各种命令行工具， GNU coreutils就是我们要找的，我们需要编辑器，GNU emacs就行。我们需要开发工具编写自己的程序，GCC GDB GNU make等等就是我们需要的。 我们要的各种构成UNIX系统的要素GNU通通提供了。额，除了内核。所以RMS提议使用Linux内核+GNU userland\footnote{
前文提到过，UNIX需要CPU提供特权和非特权两个代码级别。内核的代码运行在特权级别。用户的程序运行在非特权级别。故而用户程序统称userland。}的操作系统应该叫做GNU/Linux。

那还等什么，赶紧到GNU的网站上下载吧！

\subsection{使用Linux内核的操作系统——发行版}
且慢！我还未拥有一个UNIX环境，GNU网站上提供的都是源代码，Linux也是源代码，我如何使用他们？编译？
那么我首先需要一个UNIX系统，并有一个能工作的编译器，才能编译这些软件吧！

这是一个先有鸡还是先有蛋的问题。

再说，就算我已经安装了一个Minix或者BSD系统，想编译出一个使用Linux内核的完整操作系统，也是一个巨大的工程吧！

俗话说，有需求的地方就会有市场。

于是有那么些人开始将Linux内核以及各种软件搜集到一起，预先从源码编译成二进制的可执行程序然后打包放到光盘上出售。并编写了方便的安装程序。只要把光盘塞入PC的光驱，跟着光盘里安装程序的提示一步一步做下去就能安装好一个完整的系统。

这种以Linux为内核的操作系统和其他的软件一起打包组合而成的套装就是发行版。


\section{发行版的意义}
当然，发行版的意义并不是简单的将软件打包和降低初学者的门槛哦\textasciitilde

第一：通过将大量的程序打包到统一的仓库，使得很多默默无闻的软件被显示到可安装软件列表上。增加了这些低调的软件开发者的潜在用户。虽然说用户多了开发者不一定有好处，但是光是想到有那么多人会用自己开发的软件，想想都觉得来劲不是么？

第二：许多软件特定版本的\emph{组合}可能会导致一些潜在bug。这些是软件开发者无从测试的。一个特定版本的发行版将基础软件的版本全部确定下来。只要保证这些版本的配合不会产生bug就可以了。由于用户使用发行版提供的软件，就减少了各种没有预料到的组合。所以在生产环境，随机的升级某个软件是非常忌讳的哦\textasciitilde。

第三：许多软件开发商形容Linux是活动的靶子。每过6个月\footnote{Ubuntu每6个月发行新的版本。}，系统各个软件都版本大换血。原先测试好的软件活不过6个月——下一个版本出来就出各种问题了。但是开源软件因为是发行版负责打包编译，所以可以避免这儿个问题。发行版维护者会及时发行某些软件因为另一些软件的升级而不工作了，通常简单的问题维护者自己就可以将错误修正——同时将修改回馈上游。开源软件可以放心的躲过每6个月一次的劫数——除了拒绝开源的。

第四：第三条提过，发行版积极的向上游回馈修改\footnote{咳咳，并不是每个发行版都那么好心。Ubuntu就曾经因为回馈不足引发舌战过。}。
有时候发行版回馈的补丁不仅是躲过6月劫数那么简单。一些发行版直接参与上游软件的开发，特别是和发行版结合紧密的软件。Fedora是RedHat赞助的社区发行版，默认使用GNOME桌面，而GNOME有相当一部分开发者就是RedHat雇员。


\section{包管理和软件仓库}

是什么东西促使一堆软件的集合变成了一个发行版呢？答案是包管理机制和围绕它建立的一个软件仓库。

\subsection{包管理}

人要用电脑，就免不了要安装软件。浏览器，办公软件，游戏等等。软件安装了，免不了要升级和卸载。
%人发行版需要

所有的程序都带上升级卸载程序，是个不错的主意，也是个愚蠢的主意。不符合UNIX的KISS原则。

符合KISS原则:
\begin{itemize}
\item 安装程序应该只有一份。
\item 所有的软件使用统一的方式安装，不能区别对待

\item 使用方便。提供直观间接的命令行或者图形界面。

\item 干净卸载。卸载不能留下任何不该留下的东西。所谓燕过不留痕。

\item 解决依赖问题。一个软件或多或少的会依赖其他的软件。最明显的例子，如果系统里没有安装libc，所有的软件都不可能运行。一个软件要想正常工作，它依赖的软件必定也要安装。　包管理要最终软件之间的相互依赖关系。安装一个软件的时候能将它依赖的软件也安装，卸载软件的时候能将依赖的软件（如果没有其他的软件也依赖它的话）一并删除。

\item 打包方便，不能方便了最终用户而是发行版维护人员痛苦不堪。

\end{itemize}

各个发行版使出浑身解数，开发了各种软件包格式和对于包管理器。比较流行的也就只有两个而已：RPM和deb。

\subsection*{RPM}

RPM是Redhat Package Manager的缩写，不过后来RPM被Redhat以外的发行版采用的，似乎RPM成了另一种缩写：Rpm Package Manager\footnote{吐槽吧，学的GNU啊。递归缩写}。

RPM格式的扩展名是.rpm，分源码包和二进制包。源码包将rpm规格说明文件（.spec）和程序源码打包为一个.src.rpm包（或者.srpm） 。源码包可以用来构建二进制rpm包。
要安装rpm包，使用rpm命令进行。具体使用请参考man手册。比较常规的用法我会在
%\secref{软件管理}　介绍。
第\ref{软件管理}章~\nameref{软件管理}介绍。

\begin{insertnote}
\vskip 0.5cm
man手册的用法很简单啦，打man后面跟个要帮助的命令，rpm就是
\begin{code}
\$man rpm
\end{code}
按q退出查看。PgUp和PgDown可以翻页。
\end{insertnote}

RPM被广泛使用，包括RHEL、Fedora、OpenSuSe、RedFlag都是使用的rpm包格式。

\subsection*{deb}

包管理世界的另一大流派是deb。deb因其所使用的软件包扩展名为.deb而得名。实质上是Debian的缩写。因为它是Debian专用软件包格式。
因为Ubuntu是Debian修改而来，自然也采用了deb包管理。

和RPM一样，deb也有源码包和二进制包。从源码包可以编译得到二进制包。要安装deb包，使用dpkg命令进行。具体使用请参考man手册。比较常规的用法我会在第\ref{chap:软件管理}章~\nameref{chap:软件管理}介绍。

\subsection*{ebuild}

Gentoo的ebuild严格来说并不是软件包格式。rpm deb之类的，可以直接安装对应的二进制包。包管理器检查包的依赖，依赖检查后将包里的文件解压安装到系统里就可以了。

Gentoo的ebuild却并不是这样的。ebuild大致是一个BASH脚本（不能直接执行，只能由包管理器调用）。Gentoo的包管理器通过执行ebuild完成“自动下载源码，解压，编译，安装”这样的操作。

%TODO 更多ebuild介绍

\subsection{软件仓库}

发行版搜集了各种软件，并编译成二进制包。通常发行版收集的软件包数量以万计。这么多包是不可能一次性全部装到一张光盘上的。也完全没有那种必要。用户拿到光盘的那一刻开始软件就已经过时了。

如果将所有的包都集中存放到服务器上，用户要安装的时候直接到服务器上获取就可以了。用户获得的软件总能保证是最新的。只需要比较本地安装的软件版本和服务器上存储的最新版本就可以知道是否有更新了。

这样在服务器上集中存储的软件包就集合成了一个仓库。发行版的工作就是维护这个仓库，时不时的向仓库更新软件。

软件仓库可是个伟大的发明。乔帮主从Linux社区学到了软件仓库创立了App Store赚了大发。微软也开始学软件仓库的思想，据说Windows 8打算使用软件仓库。

限于仓库的格式问题，不同的发行版有不同的工具让用户访问软件仓库。

RPM系的发行版，使用yum\footnote{不要和rpm混淆哦！一个是安装软件包的，一个是访问软件仓库的。}访问仓库。用户可以下载　XXX.rpm 然后使用　rpm -i XXX.rpm 安装这个包，但是更便捷的做法是直接使用 {\tt yum install XXX} 安装名为XXX的软件。yum会到仓库里搜索XXX软件并将对应的rpm文件下载下来，如果有未安装的依赖，将依赖的软件也下载下来。然后调用rpm安装。

\begin{example}{Fedora下安装手写输入法}
手写，handwrite，搜索
\begin{code}
\#yum search handwrite
\end{code}

在结果页面，有个叫　ibus-handwrite的软件。ibus是一个输入法框架，自然ibus-handwrite就是手写输入法了。
开始安装（注意需要使用root帐号运行，参考\faqref{FAQ:su}）
\begin{code}
\#yum install ibus-handwrite
\end{code}
回答yes后ibus-handwrite就被安装到系统上了。
当然，前提是保证网络连接：）
\end{example}

要删除软件，使用 yum remove XXX.

对deb系的发行版，使用apt-get（俗称超级牛力）哦。基本用法和yum一致。apt-get install 安装软件，apt-get remove 卸载软件。
区别就是，yum是在线搜索，apt-get是离线搜索。你需要每天使用apt-get update（也不需要每天啦！
长久没用apg-get的时候先执行一下apt-get update就行了。）刷新缓存，
之后apt-get就使用本地缓存的软件包信息而不用每次都连接到服务器进行搜索。

另外，更新系统yum使用的操作是　yum update，而apt-get同样的操作用来更新本地软件包信息缓存了，故而更新系统在apt-get下使用的命令是apt-get upgrade。

而Gentoo这样的系统嘛，也有非常强大的工具：{\bf emerge}。emerge　XXX就可以安装名为XXX的软件。

\begin{example}{Gentoo下安装vim}
要安装vim非常简单，emerge就可以了
\begin{code}
\#emerge　vim
\end{code}
emerge会忠实的到vim的网站上下载vim的代码，解压，编译，然后安装。如果vim依赖的软件还未被安装的话，emerge会首先安装它们。

\end{example}

\subsection*{在仓库中搜索}

虽然仓库很好用，但是在用的时候大家都会有一个疑问：怎么知道一个软件对应的包的名字？

这就需要到仓库中搜索需要的软件了。搜索条件一般为软件的名字。通常软件包的名字和软件本身的名字一致。但也有例外。就拿glibc来说，在deb系里，它的包名是libc6。
这些问题都有历史渊源，说来话长，咱就不废话了。总之记住：软件包的名字并不总是和软件本身的名字一致。所以有时候需要搜索后才能安装。另外一个问题是，有时候我们只是希望安装一个“类型”的软件，比如想安装个画图软件，但是恰巧并不知道任何一款画图软件的名字。

针对这2个问题有两个办法。

第一个问题，属于特定发行版下的“软件包改名”问题。一般使用发行版的软件管理工具的搜索命令。以软件本身的名字作为关键词搜索即可。比如　yum search vim、apt-cache search sudo、emerge -s vnc。

第二个问题，命令行下无解。如果使用图形工具可以方便的浏览仓库中所有的软件。还是分门别类的哦！

\chapter{安装 Linux}

\begin{quotes}[0.5]{insomnia}
It only takes three commands to install Gentoo!
\end{quotes}

Linux介绍了那么多，是时候将它安装到我们的电脑上了。接下来要边安装边学习哦。要安装一个Linux系统，我们总是选择一个发行版来安装。那么到底选择什么样的发行版呢? 理想的发行版通常是这样的一个发行版：它非常第容易安装，非常的容易适用；软件仓库里的软件非常丰富，我可以用包管理安装一切软件而不需要自己手动安装；对于一些软件我希望能容易的进行定制；快，非常快。在对各个发行版做里权衡后，我选择Gentoo作为本书中介绍Linux知识所使用的平台。


\begin{notice}
 注意：Gentoo只是我们选择的众多发行版中的一个，我并不打算把本书变成一个Gentoo入门教程。如果这样，读者还不如选择阅读Gentoo官网上的手册。我尽量将所涉及到第知识通用化。如果这样的知识点只适用于Gentoo, 我会进行说明并辅之以其他发行版的等位操作\footnote{不同发行版达到同样的目的采取的不同操作。}。
\end{notice}

本书并不打算引起发行版之争\footnote{指不同的人使用不同的发行版，并常常在网上争论自己使用的发行版要比别人的优秀}，
但是又必须解释为什么使用了Gentoo这个非常罕见的发行版而不是同其他书本那样采用最流行的发行版，比如Ubuntu或者Red Hat系。

最直接的原因也许就是作者本身使用的就是Gentoo，以自己最熟悉的发行版写作，可以避免不熟悉系统进行错误的讲解\footnote{这确实是一个理由，但是Gentoo必定有比其他的发行版更值得作为本书的平台。}。
当然，如果仅仅这一个理由未免太牵强。
{ \it Gentoo可以让读者将精力放到学习Linux本身，而不需要关注发行版的细节，这就是我采用Gentoo的原因。}
另一个能做到这种效果的发行版为LFS\footnote{严格来说，LFS 算不上发行版，只是一个教你如何手工编译出一个能用的系统的手册。}（Linux From Scratch）。
但是LFS太繁琐，恐怕还没有学习到Linux的知识就已经中途放弃了。


\section{安装准备}

当然是准备一台电脑啦！Gentoo虽然号称为本机编译优化，但是编译本身非常耗费系统资源，所以一台主流配置的电脑是必不可少的！
\footnote{Gentoo支持的硬件架构非常多，不是一定要用个人电脑的。
但是作为初学者，我们就用最常见的个人电脑，不折腾各种稀奇古怪的电脑，最重要的是，Gentoo对x86体系也是支持的最好的（这不废话么，用户量摆那里么）。}


除了一台电脑，还要准备个Fedora或者Ubuntu的LiveCD\footnote{参考附录A. FAQ 的“什么是LiveCD”。
}，这里不推荐Gentoo自己的LiveDVD\footnote{同LiveCD。}，因为前者更容易获取和使用。

当然，还有网络。Gentoo虽然可以脱离网络进行安装，但是需要将所可能需要用到的源码提前下载，这是非常麻烦的。所以最好准备一个安装的时候可以访问的网络，也就是说LiveCD 环境里必须能使用网络。Fedora 或者Ubuntu那样的LiveCD 通常提供了完整的桌面环境，使用这些桌面环境的网络设置，让LiveCD 能访问互联网就可以了。你可能需要使用 NetworkManager 提供的图形客户端进行配置，通常是在桌面右上角的系统通知区域。要使用 NetworkManager 配置网络，请参考第6章的内容。

嗯嗯，不过就算是x86还分为x86\_32（ 没有特殊指明的情况下x86特指x86\_32） 和x86\_64\footnote{因为历史原因，AMD率先推出支持64位运算的x86CPU，所以Gentoo管x86\_64叫amd64，这和x86又被称呼为 i386 是一样的原因。}呢。
由于x86\_64是在x86的基础上发展起来的，所以x86\_64向下兼容x86。 也就是说，64位的CPU可以运行32位的软件。但是反过来就不行了。

既然存在两种x86，选择起来就费脑筋了。怎么知道自己的CPU是x86\_64的还是x86\_32 的呢？答案是，现在生产的CPU都是x86\_64了。当然如果你想准确的知道CPU到底支持不支持64位指令，在Window下你可以选择执行CPU-Z 软件获得CPU信息，如果是Linux就简单的多，在终端下执行lscpu命令就可以了。

（1）  Linux下使用lscpu：

在终端下执行lscpu，该命令的第一行输出就是CPU的体系结构。在我的电脑上，其输出为：

\begin{code}%
Architecture:        x86\_64\\
CPUop-mode(s):        32-bit, 64-bit\\
Byte Order:            Little Endian\\
CPU(s):                8\\
On-lineCPU(s) list:   0-7\\
Thread(s) per core:    2\\
Core(s) per socket:    4\\
Socket(s):             1\\
Vendor ID:             GenuineIntel\\
CPUfamily:            6\\
Model:                 42\\
Stepping:              7\\
CPUMHz:               1600.000\footnote{如果CPU支持动态降频，这里显示的是当前频率而不是CPU的标称频率。}\\
BogoMIPS:              6420.96\\
Virtualization:        VT-x\\
L1d cache:             32K\\
L1i cache:             32K\\
L2 cache:              256K\\
L3 cache:              8192K\\
\end{code}

第一行的Architecture:        x86\_64就表明此CPU的结构是x86\_64。


\vskip 1em
（2）  Windows 下使用CPU-Z：

\chatu{cpuz}{cpuz截图}
如图\thefigure所示。我红圈标注的EM64T表示CPU支持64位指令。对于AMD系的CPU，您大可放心，全部支持64位指令。


\begin{insertnote}
\subsection*{小插曲  64位 vs 32位}

如果是x86\_64的CPU，应该选择amd64\footnote{AMD64 就是x86\_64。}
的Gentoo还是x86的呢？既然现在的CPU都支持 64位指令的，为何还有那么多人使用 32 位的系统？

x86\_64虽然能执行x86代码，但并不是没有代价的。Windows下大部分现有的程序都是32位的，如果安装的64位Windows，32位软件并不能100\%兼容。而且所有的64位软件同时有32位的版本，所以Windows用户非但没有迫切的升级到64位系统的意愿，放而有为了兼容性考虑不得不安装32位系统的处境。

64位系统如果不执行64的程序，那性能还不如直接使用32位的系统和32位的程序。所以在 Windows 统治的世界里，64 位CPU的地位非常尴尬。32位CPU通过PAE\footnote{Physical Address Extension，物理地址扩展。允许32位CPU使用36位地址从而突破4G内存限制。}同样能获得 >4G 内存的支持（非服务器版Windows人为阉割32位版本的PAE支持，故而32位桌面版Windows不能支持超过4G内存。）。

大概也就是因为这个原因，所以不明真相的群众就以为64位除了支持大内存外一无是处。继续固守32位。64Bit vs 32bit的战斗因此打响。

x86\_64对x86的提升不仅仅是更大的内存，同时增加的有

(1)  更大的寄存器 64位CPU自然拥有64位宽度的寄存器。

(2)  更多的寄存器x86\_64相比x86增加了8个通用寄存器,增加8个MMX寄存器。

(3)  默认支持SSE\footnote{SSE指令是Intel为x86添加的扩展，加快了浮点运算的速度。}指令集。

(4)  更有效的指令编码。

这些都无形中增加了x86\_64指令编译的软件的运行速度。所以，如果你的CPU支持x86\_64，请必定选择x86\_64。
Linux上没有Windows上遇到的问题。
Gentoo下几乎所有软件都是本机编译的，自然不存在兼容性问题。
而个别非开源软件也多数拥有 64位版本，更不需要操心兼容性问题。
\end{insertnote}

好，我们列一个清单：


\begin{itemize}
\item[ \checked] 一台电脑
\item[ \checked] 一张LiveCD
\item[ \checked] Internet
\item[ \checked] 本书或者Gentoo 安装手册。
\item[ \checked] 耐心，很多很多的耐心
\end{itemize}

你准备好了么？

准备好的话，将LiveCD塞入光驱，开始一步步安装属于你的Gentoo吧。有关如何使用LiveCD请参考\faqref{FAQ:UseLiveCD}。
启动LiveCD，首先配置好网络环境，有关网络环境的配置请参考 \secref{sec:ifconfig}。


\section{分区规划}
任何系统都是安装到硬盘使用的
\footnote{好吧，先忽略掉LiveCD 和  WinPE 这类不需要安装的系统，咱讨论的是一般用途的桌面操作系统。}，
安装到硬盘之前，必须先划好家。在介绍如何分区前，首先得知道什么是分区，然后参考
FHS\footnote{FHS 是文件系统目录结构的一个标准。规定了根分区下各个子目录的名称和用途。}
指示结合自己的实际情况规划好分区。

\subsection{分区基础知识}
最初，计算机使用软盘，软盘是没有分区的。后来蓝色巨人IBM发明了硬盘。硬盘的容量一下子比软盘大出好多倍。当时的MS-DOS所使用的FAT12文件系统无法管理那么大的硬盘。于是西雅图的巨人和蓝色巨人想出来把硬盘划成逻辑上的几个区域，每个区域大小都在MS-DOS能管理的范围之内——这样的逻辑区域就是分区。人们发现将硬盘划分为逻辑上的几个区域后，更容易组织硬盘上的数据了；而且一个文件系统错误只会影响到一个分区的数据，其他分区不受影响，数据的安全性也得到的提升。因而后来的DOS虽然将FAT12进化到了FAT16，能管理当时的大容量硬盘了，但是分区这个功能却保留了下来\footnote{虽然是MS-DOS的发明，但是Linux可不会拒绝这样的发明。Linux还支持 BSD 发明的分区格式，总之，Linux决定支持越多的分区表格式越好，这极大的方便了用户，不是么？}。

既然用户划了分区，操作系统总得知道用户到底怎么划分的，描述分区的数据被称作分区表。既有分区表，必须有个地方存储，也必须知道到哪里去读取分区表。MS-DOS的把分区表和引导程序放入硬盘的第一个扇区\footnote{扇区是硬盘最小寻址单位。参考附录A. FAQ里的条目“什么是扇区”。}。

硬盘的第一个扇区又被称呼为MBR\footnote{MBR是硬盘的第一个扇区，具体解释请参考附录A. FAQ 里的条目“什么是 MBR”。}。
MBR既要存储引导程序，又要储存分区表，是个寸土寸金的地方，分区表大小受限，只有4个表项。也就是说，一个 MBR分区表最多只能有4个分区。要是只有四个，似乎并不够用。

MS-DOS将其中一个分区作为扩展分区，然后再扩展分区里再建分区表。扩展分区里面的分区就是逻辑分区，MBR 上的分区表就是主分区表。主分区表里划分的分区自然就是主分区了。所以一个MBR格式分区表最多允许3个主分区和1个扩展分区，或者4个主分区。扩展分区里再创建逻辑分区，没有数量限制。
\chatu{logicalpart}{链式逻辑分区表}

\begin{notice}
注意：扩展分区里的逻辑分区并不是表格形式存储的，而是“链式”存储。如图\thefigure所示。每个逻辑分区包含查找下一个逻辑分区的信息。因而一个逻辑分区的破坏有可能造成链式效应，将所有的逻辑分区全部摧毁。
\end{notice}

由于近来UEFI\footnote{参考附录A “UEFI 和 BIOS”。}  的兴起，
UEFI指定的分区表格式GPT也流行开来了。
和MBR不同的是UEFI不需要专门的引导扇区，引导程序由UEFI直接从文件系统上加载。所以GPT只是分区表，不需要和引导程序共存。

MBR 的分区表只有64个字节大小，只能包含最多4个分区的信息。
GPT包含128个分区表项，最多允许一个硬盘划分成128个分区，足够了。
能表示更多的分区并不是GPT唯一的优点，MBR分区表只能管理2.2TB
\footnote{MBR使用4个字节表示分区起始位置的偏移量。
偏移量以扇区为单位，一个扇区为512字节，那么MBR分区表能管理的最大硬盘大小为$2^{31}*512Byte = 2TB$。
又因为硬盘厂家以1000为进制而不是1024，故而大约为2.2TB。}%
以下大小的硬盘，GPT却可以管理容量超过9ZB\footnote{1ZB=1024PB 1PB=1024TB. 硬盘厂家的计算是 1ZB=1000PB 1PB=1000TB。}的硬盘。
在大容量硬盘越来越普遍的今天，MBR显得越来越力不从心。GPT正好接替MBR成为今后PC硬盘的主流分区表格式。

如果你电脑的固件是UEFI，不管硬盘实际是否大于2TB，建议最好使用GPT分区表。

\subsection{为磁盘分区}

\chatu{gparted-gui}{gparted界面}

\FloatBarrier

\normalfont

有很多种工具可以对硬盘进行分区。今天的主角是 gparted , 这个是一个非常简单易用的分区管理软件，带图形界面的哦~~

要打开gparted，在终端执行sudo gparted。如果 Fedora 的LiveCD提示没有这个命令，则用命令sudo yum install gparted或者apt-get install gparted进行安装。gparted界面如图\thefigure所示。

在gparted里所做的一切操作都不是立即执行的，只有应用操作后才被一次性执行。所以未应用前撤销操作是来得及的。
下面我把为硬盘分区所需要的几个主要操作图解一下。请读者根据此处的图示熟悉操作流程，并在学习下一个小节后自行分区。

\chatu{gparted-apply}{gparted应用操作}
\noindent要应用操作：\\\indent
1. 单击“编辑”|“应用全部操作”菜单。如图\thefigure所示。\\\indent
2. 在弹出的警告对话框中选择“是”。

\chatu{gparted-newpart-boot}{gparted新建分区}

\noindent建立一个分区：\\\indent
1. 选择磁盘的空白区域，右击后在菜单里选择“新建”。\\\indent
2. 在弹出的对话框里指定一个大小、分区类型和文件系统，如图\thefigure所示。\\\indent
\hskip 4em %
\begin{notice} %
  注意：分区表为GPT格式的只能选择主分区。
\end{notice} \\\indent
3. 单击“添加”按钮，新建的分区就编排在了任务列队里了\\\indent

\chatu{gparted-delpart}{gparted删除分区}
\noindent删除一个分区:\\\indent
1. 右击要删除的分区在菜单里选择“删除”。如图\thefigure所示。 %\\\indent

\chatu{gparted-newpt1.png}{新建分区表}

\noindent新建一个分区表：\\\indent
1. 单击“设备”｜“创建分区表”菜单，如图\thefigure所示。

\chatu{gparted-newpt2.png}{新建分区表}

\indent2.在打开的对话框里点“高级”前面的箭头，选择一个分区表类型。默认为MS-DOS分区表，也就是MBR分区表。
我需要在这里我选择gpt分区表。如图\thefigure所示。

\FloatBarrier

好了，gparted的基本操作就完成了，接下来学习一下文件系统的结构后按照自己的意愿为自己的系统分区吧。

\subsection{文件系统结构标准（FHS）}

Linux继承自UNIX树形目录。每个目录各司其职，并被FHS（Filesystem Hierarchy Standard）标准化。表3.1所列是一个不怎么完整的FHS标准，但是对于读者决定如何为他自己的电脑分区已经足够了。

\begin{longtable}{|l|p{0.7\textwidth}|}\hline
\caption{FHS标准参考}\\
\hline
/ & 根目录 \\\hline
/bin & 基本系统程序。如 ls cat grep \\\hline
/sbin & 只供管理员使用的基本系统程序 \\\hline
/boot & 内核和引导程序，通常为独立分区\\\hline
/dev & 设备文件目录 \\\hline
/etc & 存放系统配置文件。不允许存放为独立分区\\\hline
/home & 存放非root用户的家目录。 
比如foo用户的家目录就是/home/foo
一般用来存在个人文件和个人设置。
通常强烈建议独立为一个分区。\\\hline
/lib & 系统基本库，被 /bin /sbin 里的程序依赖的库 \\\hline
/media & 可移动媒体的挂载目录。比如cdrom和u盘。被/run/media代替\\\hline
/mnt & 临时挂载目录\\\hline
/opt & 通常用于安装非开源软件，如Adobe Reader \\\hline
/proc & 虚拟的文件系统，用来获得内核和运行中的程序的信息\\\hline
/root & root用户的家目录\\\hline
/srv & 做服务器使用的时候 ，用来存储服务的数据。如一个git服务器通常将仓库存放于/srv/git\\\hline
/tmp & 临时目录。其中文件关机丢失。建议挂载为tmpfs虚拟文件系统，对于tmpfs的介绍可以参考第7章。 \\\hline
/usr & 非基本系统程序根目录，下面的结构和 / 差不多 \\\hline
/usr/bin & 同 /bin。只是非基本程序。如xeye  elinks . \\\hline
/usr/sbin & 同 /sbin。只是非基本程序。如system-config-firewall \\\hline
/usr/include & 头文件目录。\\\hline
/usr/lib & 同 /lib。只是其包含的库是不被/sbin、/bin使用的。\\\hline
/usr/share &  保存架构无关的共享数据。如图标\\\hline
/var & 系统运行中会不停变化的文件。比如各种log，包管理器的数据库，等等。通常在服务器上是独立分区，个人电脑可以不独立划分。\\\hline
/var/cache & 缓存。该目录下的文件可以安全删除，要求使用它的程序必须能重建它。比如fontconfig的缓存。\\\hline
/run 和 /var/run & 临时目录。包含本次系统运行时的信息。\\\hline
/var/log & 存放各种日志文件。\\\hline
/var/tmp & 临时文件，可能重启后还在。注意和/tmp的区别。\\\hline
\end{longtable}


知道了系统各个目录的作用，就好为目录进行分区了。通常我们使用4个分区 /boot、/、/home 和一个交换分区。

\begin{notice}
注意：我在使用“/home分区”这个术语的时候，我指的是为“/home”分一个单独的分区，并且将这个分区挂载到“/home”目录下。我通常不使用“挂载到/home目录的分区”而直接简述为“/home分区”。同样的，“/分区”（或者根分区）指的就是挂载到根目录的分区。
\end{notice}

/boot独立为一个分区的好处是防止根文件系统的错误蔓延导致/boot/*文件破坏无法正常启动。另一个好处是 /分区可以使用引导程序（如GRUB）不支持的文件系统格式。例如GRUB不支持XFS文件系统格式，但是你可以让/boot分区使用ext2格式从而使 /分区可以使用XFS格式。如果/boot没有独立出一个分区。那 /分区就只能使用引导程序所支持的文件系统了。

/home独立一个分区的好处就是将用户数据彻底和系统数据分离。由于/home目录通常频繁读取写入，和 /分区隔离可以避免 /分区被碎片化。

提示：其他目录，比如“/var”，可以独立一个分区也可以不独立。就看你系统的用处了。作为桌面用途，完全没必要。如果是服务器，“/var/log”可能会很大。邮件服务器的“/var/mail”就可能会非常大，所以非常有必要使用独立分区。

\subsection{文件系统选择}


Linux支持的文件系统非常多，有自家系列 ext2/ext3/ext4、甲骨文公司开发的btrfs，来自硅谷图像的XFS等等等等。

不过选一个文件系统没那么纠结的。对于根分区\footnote{根目录所在分区}，既然大部分发行版默认使用ext4，那就ext4吧。

为了引导程序的兼容性，/boot分区仍旧使用ext2或者ext3。

对于/tmp这样的目录，强烈建议使用tmpfs\footnote{参考第7章“文件系统”。}。tmpfs是一种内存文件系统，所有tmpfs上创建的文件都是在内存里的，关机后就会消失。非常适合用作/tmp的文件系统。既能加快系统速度，又能保护硬盘。

对于/home目录，如果是个BT爱好者，会有很多大文件，我推荐使用XFS文件系统。其他情况下还是ext4各方面性能比较平衡。

如果希望为自己选择最佳的分区格式，请参考第7章“文件系统”的内容。

\section{开始安装}

废话了那么多，介绍了一些安装前需要知道的基础知识，现在终于要进入正题了，安装Gentoo。
Gentoo的安装非常简单，首先是分区。这个前面已经介绍过了。我现在假定读者已经在LiveCD 环境中完成分区了。下面开始真正的安装。


\subsection{shell 快速入门}

由于安装Gentoo需要执行shell命令，所以我需要讲解一下最基本的shell命令。高级的shell操作讲解要到

机器只能接受二进制指令，可是人需要工作在更高一层。人希望直接提供文本形式的指令由机器执行。shell 是操作系统提供给用户的解释器。shell把来自用户的命令转化为机器指令并执行。

命令虽然是文本，但也不是自由格式的。计算机是死的，自然不能接受人类的语言，只能是比较固定的几个格式。

一条shell命令的最常用格式为:

\begin{code}
命令 [选项] [目标]
\end{code}

选项是可选的，可以有一个或多个；多个选项间用空格隔开；有些命令没有选项；目标通常是一个文件的文件名，或者目录名。

请看一个命令做为例子： 

\begin{code}
root@gentoo \textasciitilde \# ls -l --all /  
\end{code}
在这里：

\begin{itemize}
\item root@gentoo \textasciitilde \# 是shell提示符。\#是root账户，普通账户是\$。root@gentoo 表示当前登录用户为root,当前登录机器是gentoo,后面的 \textasciitilde{}　表示当前目录为　\textasciitilde{}，　\textasciitilde{}　在shell中表示用户主目录，也就是　\$HOME。root的主目录为 /root,　普通用户为/home/用户名。
\item -l 是一个短选项。短选项 “-”开头，后面跟单个字母。在这里 -l 表示以“长格式”列出。所谓“长格式”就是相对与一般格式，除了要列出文件名，好要列出文件所有者，权限模式，文件大小
\item -{}-all 是一个长选项。长选项使用两个“-” 开头，后面跟一个单词。在这里 -{}-all 表示列出所有 文件，包括隐藏文件。
\item / 在这里为操作对象参数，在这里是一个目录。表示要列出 / 下的文件。
\item ls 的所有参数都是可选的，如果不使用任何参数，ls 列出当前目录下的文件。

\end{itemize}

shell命令分两种，一种是内部命令，另一直是外部命令。内部命令是由shell直接执行的\footnote{最常用的内部命令是cd。}。
外部命令则是独立的程序。比如ls就是独立程序，它的路径为/bin/ls。shell使用一个PATH环境变量\footnote{参考附录A FAQ“什么是环境变量”。}来查找外部命令。

现在我们只需要知道shell最常用的命令形式就可以了。在以后的学习过程中，我会像大家介绍 shell 的其他命令格式，包括各种循环和函数使用。现在还要一个比知道更多的shell命令更重要的知识需要知道：
\begin{center}\em
shell字符串扩展
\end{center}

还是 ls 这个命令作为例子，假设当前目录下有“a.txt”“ab.txt”两个文件。执行下面的命令：

\begin{code}
root@gentoo \textasciitilde \# ls *.txt
\end{code}

结果就是列出 a.txt ab.txt 两个文件。

在这里：
\begin{itemize}
\item *.txt 会被扩展成 a.txt ab.txt
\item a.txt 和 ab.txt 被作为2个参数传递给ls。
\item “*”是通配符，表示匹配任意多个字符；“?”表示匹配任意的一个字符。

\begin{insertnote}
注意：shell的字符串扩展不仅仅支持*和?这样的通配符，更高级的用法将在后续章节将到。
\end{insertnote}


\end{itemize}


比如你执行的是下面这个指令：

\begin{code}
root@gentoo \textasciitilde \# ls ?.txt
\end{code}

结果就只显示a.txt文件。要取消shell字符串扩展，加引号即可，如下面这条命令：

\begin{code}
root@gentoo \textasciitilde \# ls "*.txt"
\end{code}

执行结果为：

\begin{code}
ls: 无法访问*.txt: 没有那个文件或目录
\end{code}


我们知道，ls *.txt 相当于 ls a.txt ab.txt，可是如果执行下面的命令

\begin{code}
root@gentoo \textasciitilde \# ls "a.txt ab.txt" 

ls: 无法访问a.txt ab.txt: 没有那个文件或目录 

root@gentoo \textasciitilde \# 
\end{code}

shell将“a.txt ab.txt”整体（不包含引号）作为了一个参数传递给ls了。

要理解shell的这种行为，首先要明白shell是如何传递参数给程序的。

\begin{insertnote}
\subsection*{shell如何传递参数给命令}

编写过C程序的同学都知道，C程序的入口点在main，main的原型为

\begin{code}
int main(int argc, char * argv[]);
\end{code}

argc为参数列表中参数的个数，argv是个参数列表。argv[0]是程序自己，argv[1]为第一个参数，依次类推。
参数是直接由启动该程序的操作系统传递进来的，不需要还调用什么函数来获得参数列表
\footnote{Windows下确实是调用GetCommandLine()获得参数列表的，由C语言启动函数（真正的入口点）负责获得参数列表然后调用main()。}。
操作系统知道调用该程序的参数列表是因为程序是由execv()系统调用加载的。原型：
\begin{code}
int execv(const char *path, char *const argv[]);
\end{code}
path就是要执行的程序。
argv的最后一个由NULL结尾，故而内核会知道有几个参数，转化为main里的argc。

\end{insertnote}

在本例中，
shell
启动ls程序的参数应该是这样的
\begin{code}
argv[0]="ls";\\
argv[1]="a.txt ab.txt";\\
argv[2]=NULL;

execv("/bin/ls",argv);
\end{code}

所以ls会把"a.txt ab.txt"（不包含引号）作为一个参数。也就是说，参数和参数之间的分隔是由shell完成的\footnote{Windows下的程序，参数和参数之间的分隔是C库的启动函数完成的。GetCommandLine()后分割命令行参数再调用main()}。


那么，shell进行字符串扩展和命令行参数分割的时候遵循的规则是这样的：

\begin{itemize}
\item shell进行字符串扩展的时候，只对游离的*和?进行扩展。如果*和？处于引号之内则不进行扩展。
\item shell以空格为参数分割的界限。但是对于使用*和?扩展出来的字符串，以文件名为界限。比如文件名内的空格不会成为分割的界限。
\end{itemize}


如果执行的是下面的命令
\begin{code}
root@gentoo \textasciitilde \#ls　*.txt c.txt
\end{code}

shell对命令解析的步骤是：

首先进行命令行字符串扩展，*.txt 扩展为　a.txt ab.txt；接着进行参数分割，这样就是3个参数: a.txt ab.txt c.txt；最后将这3个参数传递给ls。也就是执行下面的操作

\begin{code}
argv[0]="ls";\\
argv[1]="a.txt";
argv[2]="ab.txt";\\
argv[3]=NULL;

execv("/bin/ls",argv);
\end{code}

\subsection*{本节回顾}

目前shell知识讲解仅限于能让读者小小入门，并顺利完成Gentoo的安装。现在小结一下shell的简单用法。

\begin{itemize}
\item shell以文本模式命令行作为用户界面。
\item 命令行的规则是　命令+参数，以回车键代表输入完成，请立即执行命令。
\item 参数之间以空格隔开。
\item 文件名参数可以用通配符，shell会自动扩展后作为参数传递给要执行的命令。扩展后的文件名是每个文件名一个参数而不管文件名本身是不是包含空格。
\item 如果需要避免shell对通配符进行shell扩展，加引号。
\item 避免空格成为参数之间的分割的办法也是将带有空格的参数用引号引起来。
\end{itemize}

掌握这些知识应该用于完成安装Gentoo足够了。

\subsection{正式开始安装过程}

现在，Gentoo的安装可以正式开始了！现在再检查一下

\begin{itemize}
\item	使用LiveCD启动，处于LiveCD环境中。
\item	LiveCD里已经配置好网络，能访问Internet。
\item	完成分区规划。已经为将要安装的Gentoo规划并划分好分区。
\item	现在处于LiveCD的命令提示符下。
\end{itemize}

一切准备就绪，可以开始安装了。

首先要做的事情就是创建一个　gentoo　目录。这个将要用来安装Gentoo的分区就暂时挂载到这个目录下。如不特殊说明，我使用 \#　代表命令提示符， \#后的命令表示需要手工输入并敲回车执行。

\begin{code}
\#mkdir　/gentoo\\
\#mount /dev/sdXX /gentoo
\end{code}

\begin{insertnote}
\subsection*{mount命令解释}

在UNIX操作系统下，一个文件系统是要挂载到某个目录下才能访问其中的文件的。Windows和DOS下，操作系统会分配一个“盘符”，但在UNIX下，使用挂载命令将文件系统挂到一个目录下。被挂载的目录就成了那个挂载的文件系统的根目录，也称为挂载点。

\end{insertnote}

这里　/dev/sdXX　是读者为Gentoo划分的根目录。

系统目录准备好了，接下来下载Gentoo的stage3。打开　\url{http://mirrors.163.com/gentoo/releases/amd64/current-stage3/} 或者如果打算使用x86就打开\url{http://mirrors.163.com/gentoo/releases/x86/current-stage3/}下载以最近的日期结尾的 stage3 压缩包。

然后解压到 /gentoo
\begin{code}
\#tar stage3-*.tar.bz2 -C /gentoo 
\end{code}

接着下载　portage 快照
\begin{code}
\#wget http://mirrors.163.com/gentoo/snapshots/portage-latest.tar.bz2\\
\#tar portage-latest.tar.bz2 -C /gentoo/usr/portage
\end{code}

解压完成后，复制dns配置　
\begin{code}
\#cp /etc/resolv.conf /gentoo/etc/resolv.conf
\end{code}

如果还有划分了其他目录，也要一并挂载进来

挂载home分区，boot分区等（如果有划分独立分区的话）
\begin{code}
\#mount /dev/sdXX /gentoo/boot\\
\#mount /dev/sdXX /gentoo/home
\end{code}

各使用读者划分好的分区代替命令中的　/dev/sdXX。

下面是挂载/dev/ /proc /sys的。这里使用宿主系统的/dev /proc 和 /sys　目录。
\begin{code}
\#mount --rbind /dev/ /gentoo/dev\\
\#mount --rbind /sys /gentoo/sys\\
\#mount --rbind /proc /gentoo/proc
\end{code}

好了，最好这些操作，Gentoo最小环境（能用但是不能启动）的基本环境就搭建完毕了。
执行

\begin{code}
\#chroot /gentoo　/bin/bash
\end{code}
或者如果你喜欢简洁的操作
\begin{code}
\#chroot /gentoo
\end{code}

\begin{insertnote}
\subsection*{chroot命令解释}

chroot 命令能将某个目录变成根目录并在新的根目录里执行shell或者命令行第二个参数指定的程序。

执行 chroot /gentoo 后，chroot 将自己的根目录（不影响系统其他进程的根目录）切换到新的目录，然后执行新的根目录里的 \$SHELL（通常是/bin/bash）。
这样获得的新shell就继承了chroot的根目录设定，也就是 /gentoo。 试试在里面执行　mkdir /test。然后开个新的终端检查看看　/gentoo/test 目录是不是在了。
\end{insertnote}


好了，现在就已经进入Gentoo的环境了。接下来要做的就是编译一个可启动的内核，编译一些引导必备软件，安装一个引导程序Gentoo就能启动了。

\subsection{内核编译}
编译内核，对初学者来说是个艰巨的任务。不过这是通往资深用户和熟练管理员的必经之路。该做的迟早要做，不如现在就做个了断吧。

首先获取一个内核代码。推荐使用git获得内核的代码而不是下载tar压缩包。因为更新到下一个版本的时候git只会下载差异部分而不会重新下载。
git的具体用法请参考　\secref{sec:git}。

必须把内核代码放到　/usr/src/linux　哦，这样依赖内核头文件的软件才能找到所需的内核代码（仅限Gentoo设定）。

{
\bf\noindent 提示：
}{
\em shell　下一行太长可以在后面输入$\backslash$并在下一行输入剩余的命令。shell会在下一行自动出现提示符 $>$　。
}


\begin{code}
\#cd /usr/src\\
\#git clone \textbackslash \\
>~ git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
\end{code}

内核代码非常大，这一步操作会比较费时。可以先放一边，重新打开个新的终端然后chroot /gentoo，进行下一节的操作。等内核的代码克隆完成了再回到这里继续。

Mark一下。

\subsubsection{新手使用 genkernel}

编译内核最难的地方就是配置内核了。 make menuconfig|xconfig|gconfig 最终的目的就是获得一个.config文件。其实后面的编译步骤都不难，难的就是一个能正常工作的 .config 配置文件。
似乎某些重要配置不能随意回答Yes或No，对于没有多少经验的人来说，还是有不小的难度么。

Gentoo开发者似乎注意到了不会自行编译内核的しんまい%ざこ%ばか
\footnote{内核对你来说和这个词是一样的。}%
，所以特意开发了しんまい的内核编译助手：genkernel。虽然genkernel能直接编译出一个工作内核，
但是以genkernel获得一个能工作的.config文件并在此基础上修改定制才是修炼之道。

这里就教大家用genkernel获得一个能启动的内核的.config配置文件好了。


\subsection{init 系统选择}
Linux内核被引导后，会自动加载 /sbin/init 程序，之后系统的启动就完全交给了init程序。由于init是第一个启动的程序，所以他的PID\footnote{Linux用一个数字代表一个进程。需要对进程操作的地方可以使用该数字。比如向进程发送信号，就是用PID标识发送的目标的。}是1。\footnote{PID 0是个特殊进程（或者是根本就不是进程吧），每当系统空闲下来的时候PID　0才会执行，PID 0只做一个事情，就是让CPU进入节能模式。而且PID　0的个数就是CPU的个数。每个CPU都有一个属于自己的PID 0。所以系统真正的进程号是从1开始的。}

\begin{insertnote}
\subsection*{Linux启动过程}
计算机的启动步骤为 固件初始化 \textrightarrow 引导程序　\textrightarrow　内核加载并初始化　\textrightarrow　执行首个程序负责剩余的初始化　\textrightarrow　检查并挂载文件系统　\textrightarrow　启动后台服务　\textrightarrow　开启登录　\textrightarrow　（用户登录或者自动登录）　\textrightarrow　执行shell\footnote{Linux下命令行的shell就是bash。但是图形界面也可以算是一个shell哦，Desktop Shell是也。}。

PID 1 的任务就是操作系统启动过程中的{\em 最后一英里（last mile）}。

其实PID本身也不做什么操作，它只是依次启动其他服务：

启动磁盘检查服务，启动文件系统挂载服务（这些都死一次性服务，系统启动过程中一次性执行）；

启动udev服务，启动Dbus服务，启动电源管理服务等等（持续性服务，系统运行过程中一直执行的）；

最后启动登录服务。

命令行登录服务为 agetty 。在文本终端上显示登录提示接受用户登录。通常开启六个。tty1-tty6。使用组合键Ctrl+Alt+(F1-F6)访问。
图形登录服务（显示管理器，Display Manager）为　GDM或者KDM或者XDM .... 好多，就看用户的选择了。通常发行版有一个默认的。一般和使用的默认桌面有关。
默认使用Gnome桌面的发行版默认的显示管理器是GDM，默认使用KDE桌面的发行版默认使用的显示管理器就是KDM。也可以使用简洁的XDM。各有特点，但是功能都是一样的，可以随意互换。GDM一样能启动KDE桌面，KDM启动GNOME也没问题。

\end{insertnote}

简单的来说，启动操作系统过程中PID　1的任务就是bring up userspace。此外，PID 1还减负者收养孤儿的重任。

\begin{insertnote}
UNIX进程有父子关系。比如说你在shell下执行了一个程序，执行这个程序的进程就成为shell的子进程。子进程还可以有子进程的子进程。形成一个树形的进程关系。
\end{insertnote}

如果已经进程在子进程退出前就退出，那这个子进程就会成为没有父进程的“孤儿”。UNIX同时又规定一个进程必须有父进程，所以孤儿就被 PID 1收养成为PID 1 的子进程。


\subsubsection{sysvinit+openrc}

多数Linux发行版使用传统的sysvinit作为PID　1。　
sysvinit有一个运行级别概念。每个级别用一个数字表示。预定义的运行级别如下：

\begin{longtable}{|l|p{0.7\textwidth}|}\hline
0　& 关机\\\hline
1 & 单用户（救援）模式　\\\hline
2 & 无网络模式　\\\hline
3 & 多用户模式　\\\hline
5 & 图形模式　\\\hline
6 & 重启　\\\hline
\end{longtable}

不同的运行级别对sysvinit本身并没有特殊含义。只是人为这样的运行级别设定而已。
sysvinit使用配置文件/etc/inittab决定启动过程。其中有一行
\begin{code}
id:3:initdefault:
\end{code}
决定默认进入运行级别3。3替换改为5就可以默认进入运行级别5。

/etc/inittab告诉了sysvinit每个运行级别下应该执行什么程序。例如inittab通常包含这么6行：
\begin{code}
c1:12345:respawn:/sbin/agetty 38400 tty1 linux\\
c2:2345:respawn:/sbin/agetty 38400 tty2 linux\\
c3:2345:respawn:/sbin/agetty 38400 tty3 linux\\
c4:2345:respawn:/sbin/agetty 38400 tty4 linux\\
c5:2345:respawn:/sbin/agetty 38400 tty5 linux\\
c6:2345:respawn:/sbin/agetty 38400 tty6 linux
\end{code}

表示：在运行级别1 2 3 4 5下，启动c1，启动c1所需要执行的命令为/sbin/agetty 38400 tty1 linux, respawn表示服务退出后立即重新开启。
c2 c3 c4 c5 c6 在运行级别 2 3 4 5下启动，　1 下不启动。因为1是单用户模式嘛。

图形登录界面是由下面的设置控制的（以早期Fedora为例，现在的Fedora不使用Sysvinit）
\begin{code}
x:5:once:/etc/X11/prefdm 
\end{code}
/etc/X11/prefdm 查找用户偏好的DM\footnote{一般是GDM或者KDM。}并启动之。
可以看出图形管理器是在运行级别5开启的。


{\tt c1:12345:respawn:/sbin/agetty 38400 tty1 linux} 这一行的上面还包含了一些配置用于启动　/etc/init.d/ 下的服务程序。各个发行版的做法都不一样。没有借鉴意义。

总之最后的结果是是\textbf{按循序}启动 /etc/init.d/　下的脚本
（因为运行级别的关系不是每个脚本都会被执行。通常如果运行于级别5的话，所有服务都开启，也就是都会被执行。）。

我在这里强调了一个次序。因为服务和服务之间是有明显的依赖关系的。举些例子吧：提供HTTP服务的服务apache必须于mysql之后启动。因为php页面需要和mysql数据库交互；NetworkManager依赖DBus,因为它需要和DBus提供通信功能；NetworkManger同时也依赖wpa\_suplicant，因为它需要wpa\_suplicant实现wifi加密认证；等等等等。

维护各种服务之间的依赖关系保证正确的启动次序是一个系统管理员非常非常重要的工作。
但是也不必过于担心，发行版通常已经将这种重要的工作做的相当好了。

对于Gentoo，/etc/init.d/　下的脚本并非bash脚本，而是openrc脚本。openrc主要的作用是“解析和缓存依赖关系”。
每个脚本都包含　depend() 函数，openrc执行该函数获得依赖关系以决定脚本的执行次序。

而对于Fedora/RHEL这样的系统（老Fedora，Fedora 从版本16开始不再使用sysvinit）， /etc/rc?.d/ （?为运行级别数字）下面有　S??XX K??XX 这样的符号链接到　/etc/init.d/XX 脚本。 %话说这也是Gentoo的启动脚本名为openrc的由来。
S表示　Start，?? 是一个两位数的数字，代表启动的次序。
S表示　Kill，?? 是一个两位数的数字，代表停止的次序（停止的次序和启动次序一样重要）。
我表示我已经被Fedora这种模式弄晕了，Gentoo的openrc好歹是设置依赖关系自动决定启动次序的。这也是Fedora后来果断废除sysvinit的原因吧。Fedora的 /etc/init.d/下可是实实在在的shell脚本。没有依赖关系。引入Gentoo的openrc不如彻底革新到自动确定依靠关系或者是根本不需要依赖关系的新服务管理系统。

\subsubsection{SystemD}
sysvinit大量依靠脚本（/etc/init.d/* ）实现系统启动过程。脚本的一大特点就是慢。
另一个诟病的地方就是服务之间的关系复杂，很难搞懂。而且各个发行版并没有统一这些脚本。有的发行版为脚本加入了依赖关系，有的要依靠手工设置（是发行版打包的时候确定的）启动次序。管理上非常复杂。

那么，针对sysvinit的问题：慢、管理复杂，Redhat的一个牛人开发了SystemD做为PID 1以克服sysvinit的缺陷。

那么SystemD到底有哪些好处呢？

\begin{itemize}
\item 极度并行化启动。
		SystemD开发者说过，要系统启动更快的，第一条需要做到的是单位时间内启动更多服务。不像sysvinit那样串行启动，SystemD是高度并行的。SystemD同时启动多个服务。

\item 无脚本启动。SystemD开发者说过，要系统启动更快，你还需要做到的是整个系统启动过程启动更少的程序。SystemD实现不依靠一行shell脚本启动完整的系统。

\item	按需启动。SystemD开发者说过，要系统启动更快，按需启动是必不可少的。按需启动功能更进一步的使整个系统启动过程启动更少的程序。

\item	无需配置依赖性。
		按需启动还使得服务之间的依赖关系成了过去式。你不需要直接指定服务之间的依赖关系——只要一个服务用到了另一个服务，另一个服务会被按需启动，\em 就好像它本来就已经被启动了一样。

\end{itemize}

SystemD能实现按需启动和避开依赖性配置，原因就是实现了socket activation。

\subsection*{Socket Activation解释}
如果所有的服务可以同时启动而不考虑依赖性，服务就可以最大化的并行启动了。如果不考虑依赖性，管理员也可以大大的轻松。
那么服务和服务之间为何会相互依赖呢？答案是依赖它创建的Socket。{ \it Apache要在mysql之后启动，是因为网页需要数据库，需要mysql提供的数据库服务。它只所以需要这个服务，是因为它需要连接到mysql创建的socket。NetworkManager需要DBus服务，是因为NetworkManager需要连接到DBus，其实是连接到DBus创建的那个socket。}

如果，如果所有的Socket一开始就已经全部创建完成，所有的服务就可以同时启动了。因为他们连接到对方的时候不会再遇到“连接拒绝：地址不存在”错误。

如果没有Socket Activation, 同时启动NetworkManager和DBus的后果是，如果NetworkManager试图连接到DBus的时候，DBus还为创建它的socket,NetworkManager将出现连接错误而是服务启动失败。

有了Socket Activation, NetworkManager和DBus不再需要串行化启动，同时启动接口，NetworkManager总能连接上需要的Socket，因为它已经在那里了。
甚至DBus自身都不用启动，NetworkManager也能正常开启直到NetworkManager向这个socket发送了一些数据——这个时候DBus必须开起以便处理这个数据。这就是“安需启动”的实现方式。


\subsection{引导管理器}
\subsubsection{UEFI}

\subsection{安装基础系统}
\subsection{系统初步配置—重启前配置}

\subsubsection{nano 编辑器快速入门}

\chapter{使用Linux}
\section{Shell 基础和日常应用}

\section{文件管理}	
\section{文件编辑器}
\subsection{编辑器之神 vim	}
\subsection{神之编辑器 emacs	}
\subsection{够用就好 gedit	}
\section{系统管理基础}

\subsection{进程管理	}
\subsection{系统服务管理	}

\section{shell 进阶应用}

\chapter{软件管理}\label{软件管理}

\section{软件的分发}
\section{软件的编译}
\section{发行版的包管理}\label{section:pkgmgr}
	
\chapter{图形界面}
对命令行是不是有点枯燥了？是时候来电新鲜的东西了 只所以现在才讲，因为图形实在是太复杂了。

\section{窗口和图形}

\section{X 的历史}

TODO： X 是一个窗口系统，那么X为什么采用了 C/S 结构呢？
\subsection{ 窗口管理}
\subsection{ 渲染库和静态链接}
\section{桌面环境}
\subsection{GNOME}
GNOME 是事实上的标准。各个主流发行版的默认桌面环境。
\subsection{ KDE XFCE 和其他}

\section{  办公和打印	}
\subsection{  LibreOffice	}
\subsection{使用CUPS 打印文档	}
\section{ 声音的那些事	}
\subsection{  声音的数字编码	}
\subsection{  逐渐被遗忘的OSS	声音架构}
\subsection{ ALSA 高级Linux声音架构}
\subsection{  PulseAudio 优秀的声音服务器	}
\subsection{  播放器	}
\section{  让游戏放松自己	}
\subsection{  OpenGL 和 Mesa	}
\subsection{  硬件加速	}
\section{  Wayland	}
\subsection{ X 的错误	}
\subsection{  直接渲染}

\chapter{网络}
\section{  网络基础知识}
\subsection{  通信基础}
\subsection{  IP地址和TCP/IP协议}
\subsection{  路由表和路由协议}
\subsection{ 以太网和WIFI}
\subsection*{  小插曲：永恒的以太网}

\section{网络配置\label{sec:ifconfig}}
\subsection{  图形环境下的工具	}
\subsection{ 命令行配置工具}
\subsection{ 网络自动配置和DHCP}
\section{  网络攻击和防火墙	}
\subsection{ 网络攻击类型和检测}
\subsection{  iptables防火墙}

\chapter{文件系统}
\section{  磁盘上的文件系统	}
\subsection{  块设备和磁盘}
\subsection{ 超级块和inode}
\subsection{  典型磁盘文件系统举例}
\section{  虚拟文件系统	}
\subsection{  /proc内核信息窗口}
\subsection{  /dev设备文件系统和udev}
\subsection{  虚拟内存盘tmpfs}
\section{  网络文件系统	}
\subsection{  NFS	}
\subsection{  Windows 网络邻居 CIFS	}
\section{  其他的文件系统	}
\subsection{  LiveCD的最爱——压缩文件系统squashfs}
\subsection{  为Flash芯片设计的文件系统}

\chapter{架设服务器}
\section{  搭建 HTTP 服务器}
\subsection{  apache 用的最多的服务器}
\subsection{ nginx 轻量级服务器}
\subsection{ lighttpd 超轻量级服务器}
\subsection{ squid 加速代理	}
\section{  数据库	}
\subsection{  最流行的开源数据库 MySQL}
\subsection{  最优秀的开源数据库 PostgreSQL 	}
\subsection{  商业霸主 OracleDB	}
\section{  加速 DNS ，在本机搭建 DNS	}
\section{  共享打印机	}
\subsection{ CUPS 打印服务	}
\subsection{ Samba 打印机共享	}


\chapter{压榨机器的性能}
\section{  最廉价的优化 – 编译优化	}
\subsection{  编译期优化	}
\subsection{  链接时优化（LTO）	}
\section{  有目的的优化 – 查找性能瓶颈}
\subsection{ 查找性能瓶颈}
\subsection{  优化瓶颈}
\section{  benchmark – 优化的基准测试}
\subsection{  CPU 单核能力测试}
\subsection{  CPU 多线程性能测试}
\subsection{  文件系统 IO 测试}
\subsection{  网络性能测试}
\subsection{  GPU/OpenGL 性能测试}


\chapter{时光机器-版本控制系统}
\section{   历史和后悔药	}
\section{   中心式版本控制仓库 CVS	}
\section{   CVS 后继 SVN	}
\section{GIT 划时代的分布式版本控制\label{sec:git}}
\subsection{  Bitkeeper	}
\subsection{  Linus 消失的一周	}
\subsection{  版本控制设计为一个文件系统	}
\subsection{ 去中心化	}
\subsection{  GIT典型工作流	}
\subsection{  GIT 简单使用	}


\appendix

\include{faq}

\chapter{名称缩写}

\chapter{图片索引}
%\cleardoublepage
{
\renewcommand{\cleardoublepage}{}

\renewcommand\listfigurename{}
\vskip -3cm
%\addtocounter{chapter}{1}
%\addcontentsline{toc}{chapter}{图片索引}
\listoffigures 
%\cleardoublepage
}

\include{app_gentoolife}

\end{document}
