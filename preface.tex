
\chapter{序}
\begin{quotes}{George Santayana}
Those who cannot remember the past are condemned to repeat it.
\end{quotes}


不知道从什么时候开始用上了Linux，已经不记得刚开始用Linux的时候那段辛苦并乐在其中的学习过程了。
有一天，我重新用起了曾经那么熟悉，那么“简单”的操作系统，结果大失所望。我看到的是一个完全反人类的系统。
它的操作似乎很简单，但是一直总有说不出的感觉，让我觉得它的操作非常别扭。我感觉我第一次接触到Linux的时候也是这种感觉。

有人说，这是一种习惯。而我却更乐意认为那是一种文化。Linux和Windows是一种截然不同的文化。
Linux技术在飞快的进化，各种新技术层出不穷。但是骨子深处的UNIX文化确没变。

有人说，Linux不是UNIX，BSD、Sun Solaris、IBM AIX这些才是UNIX。
没错，这些系统确实继承了AT\&T\footnote{第一个UNIX系统由贝尔实验室开发。贝尔实验室当时属于AT\&T公司。}
的代码\footnote{BSD和AT\&T打了几年官司，后经重写将AT\&T代码完全剔除了。}，还获得了
OpenGroup\footnote{UNIX走向分裂后，几个大公司成立了OpenGroup共同持有UNIX商标。}认证
。但是对我来说，只有Linux才真正在文化上继承了UNIX。
既然Linux的文化源自UNIX，要学习Linux将不得不首先了解UNIX，
了解UNIX从诞生到发展，发展到分裂，分裂到混乱，混乱中统一，统一却失去了UNIX的文化，再到借Linux重生的故事。

故事虽然不是技术，但是了解一个技术诞生的背景，能深刻的理解它。

融入UNIX文化后，再来学习Linux就得心应手了。

但是我不愿意独立一个章节介绍UNIX历史，因为这本书是带领大家学习Linux的，不是故事书，
所以我把整书的序部分用来介绍UNIX的历史文化。因为序比较长，干脆就叫第\thechapter章。

\section{为什么又写一本书}

我不记得自己为了学习Linux查阅了多少资料，翻烂了多少本书。最终翻了那么多书后发现，
现在讲解Linux入门书籍多数都讲求“速成”而采取填鸭式讲解。就算速成后成功学会Linux，最终也会因为不了解Linux的文化而处处碰壁。
然后到网上发牢骚抱怨Linux不人性化。

\begin{notice}
习惯于Windows的人无法习惯于Linux的操作。所有与Windows不一致的操作都被认为“不人性化”。
\end{notice}

必须首先要让读者了解到UNIX文化的精髓，而后开始学习Linux，抛开一切对Windows的比较。这样学会的Linux，遇事首先会以UNIX的思维模式思考，然后提出非常UNIXy\footnote{UNIX的，UNIX化的。}的解决办法。

所以按照人对事物的认知，我对Linux的教学过程的安排将不同于其他的书，我的重点在“文化”，介绍原理而不简单的介绍的用法。
确实我会在书中有专门的章节安排详细讲解个各种实用工具，包括服务器的搭建，但读者可以把它当作是一个手册，用到的时候再翻阅。

在对发行版的考量上，我采用了Gentoo作为本书的参考发行版。在市场上还没有哪本入门书是使用Gentoo作为发行版的。
对于使用人数最多的Ubuntu\footnote{非常流行的一个发行版}发行版，我想一定存在非常非常多的教程。但是没有哪个教程能让我满意。
不是介绍的太过于片面而没有考虑到其他发行版，就是过分介绍了发行版之间的不同点。
原因就是Ubuntu（还有Fedora\footnote{RedHat的社区发行版，其改动将回馈到RedHat企业版。}这些）发行版，并不是只将软件进行打包，还进行了大量的修改使之符合发行版的风格。

\begin{notice}
就拿 /etc/init.d/ 下面的服务启动脚本来说吧，没有哪个发行版的脚本是一致的。
都经过了大量的修改。只介绍一个发行版还不够，但是为了“全面”而大而全式的把所有的发行版都介绍一遍，对初学者来说简直就是个噩梦。他会发现他需要为每个发行版都学习一次init脚本。
\end{notice}

如果说哪个发行版最尊重上游软件\footnote{所谓上游，就是软件的作者。发行版将软件从原始站点下载后重新打包，如果称发行版为下游，那原始软件开发者就是上游。}，进行最小的改动的话，那就是Gentoo了。

Gentoo几乎所有的软件包都是直接从上游代码编译而来，中间很少有加自己的补丁\footnote{对一个软件的修改被形象的称呼为打补丁。}。
有限的几个补丁也是为了修复bug而不是对软件进行修改。

这种接近上游软件的状态非常适合初学者的学习。

\section{UNIX的史前文明}

当你看《天宫韵音》\footnote{86版本的西游记电视剧的片头曲}的时候，最先播放的画面就是悟空出世。第一个音符响起的时候，悟空从绷床\footnote{没错！仔细看，确实是绷床！后期处理居然没处理掉。BUG无处不在啊！}上腾空而起。悟空就这样开天辟地般高调出世了。

但是UNIX的出世却非常低调，低调到需要介绍他那高调的前身\textbf{MULTICS}。

Multics的全称是\textit{MULTiplexed Information and Computing System}\footnote{注音这里的大小写混合。这种混合方式旨在告诉读者缩写的由来。}。我们先来了解一下计算机早期的背景。



\begin{insertnote}
\subsection*{Multics背景}

\chatu{TwoWomenOperatingENIAC}{为世界上的第一台电脑编程\protect\footnotemark}%
	\footnotetext{图片来自维基百科~\url{http://en.wikipedia.org/wiki/File:Two_women_operating_ENIAC.gif}}


计算机诞生的时候并没有操作系统，甚至连程序都没有。操作员重新插拔系统电路连接来实现某个功能。
如图\thefigure那样两个人在重新插拔电路为世界上的第一台电脑编程。

而今天的电脑只要执行不同的程序就能有不同的功能。程序的发明是个非常重要的进步\footnote{通过执行程序而不是直接修改电路实现计算功能，程序和数据一同存储，执行的时候同时进入主存储器，这种结构的计算机最早由冯.诺曼提出，又叫冯.诺曼结构。我们现在的个人电脑就是冯.诺曼结构的。}。有了程序就可以预先编撰好程序，只要输入了程序就能执行了，而不需要费时的重新插拔电路。

那个时候计算机程序的输入靠的是穿孔纸\footnote{用纸啊！太不环保了！}。一长条纸穿进去，程序就输入了，然后等待执行完毕。执行完毕后将结果打印到纸上
\footnote{别想多了，是简单的机械打印机。只能打印0\textasciitilde{}9数字、26个字母和特殊符号。有时就是这点功能都不能保证。可能只能打大写的A-Z而已。UNIX少说多做的传统就来源于此，不仅是为了节约纸张，更是节约打印时间。}。
每次程序执行完毕后操作员要准备好下一叠纸，按下机器的复位按钮机器重新开始读取纸张并执行....周而复始。

如果程序的执行不需要人准备下一叠纸就好了。第一个操作系统就在这样的需求下诞生了。不用人的帮助计算机就能批量执行程序。尽管一次还是只执行一个程序。但是能做到前一个程序执行完毕后自动读取下一个程序执行。

有时候一个程序要执行很长的时间，执行完毕后要花更长的时间打印结果，这个时候处理器的资源就是闲置了\footnote{写小看这个闲置，那个时候的计算机比劳斯莱斯贵多了。}。如果前一个程序在打印结果的时候后一个程序能开始执行就好了，这样就能最大限度的利用处理器的资源。

于是最初的多任务操作系统应运而生。它能将处理器的时间分配给多个程序，虽然在任意瞬间还是只有一个程序在执行，但是由于快速的在不同的程序间进行切换\footnote{专业术语叫上下文切换（Context Switch），所谓上下文切换，就是将当前程序的状态保存起来，然后调入先前保持的另一个程序的状态。这样那个被调入的程序就可以从被切换打断的那个地方继续执行。}，看起来就好像多个程序同时执行了。如图 \ref{fig:ContextSwitch}  所示。

\chatu[0.65]{ContextSwitch}{上下文切换}

但是那个时候的计算机，还不能进行实时交互。程序员写好纸条后，要交给计算机管理员\footnote{确切的说是操作员}，管理员将纸条输入计算机，然后等待计算机将执行结果输出。最后输出结果交给程序员，这样程序员才能知道程序的执行结果。


随着计算机性能的提高，出现了一种分时操作系统（Time Sharing Operating System）。 
它可以让大型主机提供数个终端，用户通过终端使用主机。
终端经一条很长很长的线缆\footnote{也可以通过电话线呢！}连接到主机上\footnote{那个时候主机很大，要放到专门的地方嘛。}。
当时的终端就是一个电传打字机和一个机械打印机，只具有输入/输出的功能，本身完全不具任何运算或者软件安装的能力。要使用计算机的人将程序或者命令通过终端输给主机，主机将执行结果传回终端。最后来屏幕代替了打印机，成为视频终端。

\chatu[0.8]{ctss}{分时操作系统}

如此一来，无论主机在哪里，只要在终端機前面进行输入输出的作业，就可利用主机提供的功能了。

前面已经讲过，之前的系统只能由一个操作员去操作。而分时系统为每一个使用计算机的人提供了一个终端。比较先进的主机大概能同时为30个终端服务。 至此，计算机终于能实时交互\footnote{其实只是接近实时。不过已经是一种进步了，不是么？}了。

Multics就是在分时系统的基础上开发的。

\end{insertnote}

MIT\footnote{麻省理工大学}计算机研究中心研究出来的CTSS(Compatible Time Sharing System)是世界上最早的分时系统，它在1961年首次演示。
正如一切软件开发者所遵循的鉄律：来不及添加的功能就放到第二版做吧！Multics就是CTSS来不及添加更多功能后希望开发的全功能第二版。1964年，MIT、通用电器（General Electric）和贝尔实验室\footnote{根据Multics Myths网站（一个网站致力于破除有关Multics的谣言）的说法，贝尔实验室应该是在1965年的时候才参加的。
}通力合作，计划开发一个完美的CTSS第二代。

Multics计划的目的是想要让大型主机可以\textbf{}为超过300个以上的终端服务和一整套完整的信息处理系统。
Multics支持模块化的硬件配置：CPU、内存，磁盘等硬件都可以在需要的时候在系统运行的过程中被动态增加或移除。在当时的系统差不多都是由汇编语言写成的时候，Multics就大胆的提出了使用高级语言\footnote{当时还没C语言呢！}编写整个系统。

Multics先进的系统模型的结果就是：从1964年立项1969年，整整5年过去了，Multics的开发一再受挫。
Multics迟迟不能完成，预定的目标越来越难以达成，在投入了巨大的人力物力资源后，
贝尔实验室终于决定在这场注定失败的项目\footnote{一种说法是Multics最终达成了设定的目标，所以不能算是一个失败的项目。但是我且以为Multics没能在期望的时间内达到设定的目标，就是失败的。}中提前退出。

但是Multics激发的灵感------高级语言编写的内核、文件系统、终端实时交互、多任务、多用户等------却在今后几十年内被延续到各种各样的系统上。这些最终将在接下来的几十年时间里分别在不同的系统上得以实现。

Multics是个优秀的系统。在参加Multics项目的日子里，贝尔实验室的研究人员已经习惯了不用等待就能通过交互式终端使用大型电脑的功能。
但是退出Multics项目后，他们又得继续原始生活了。由于习惯了Multics带来的便利，贝尔实验室的研究人员将发明一个简化的Multics，这个发明就是\textbf{UNIX}。

\section{UNIX的故事}

很显然Ken Thompson不愿意放弃Multics提供的交互式终端，
而且为了能继续玩他在Multics项目做研究的时候编写的“星际旅行”游戏，他头脑风暴了一把，用实验室废弃的一台PDP-7写了一个简陋的操作系统。
Ken Thompson为PDP-7开发的小型系统被称呼为UNICS（UNiplexed Information and Computing System） 。 这个名字的由来是因为Ken Thompson认为Multics太复杂，而Multics的功能可以用更简单的方式去实现。Dennis Ritchie注意到了他的同事为PDP-7开发的简单系统。两个人亲密无间的合作就这样开始了。

\chatu[0.2]{KandRwithPDP7}{Dennis Ritchie（站）和Ken Thompson（坐）在工作}

Dennis Ritchie和Dennis Ritchie的加入为Ken Thompson的系统带来的第一个变化就是高级语言。他们开始计划用B语言\footnote{C语言的前身，Ken Thompson创造的。}重写这个系统。

在重写UNICS的过程中，Dennis Ritchie改进了B语言，使之成为更加实用的C语言。Dennis Ritchie和Ken Thompson一起实现了C语言，并在1973年用C语言重写了UNICS。哦，不对，是UNIX。因为谐音的关系，不知道什么时候开始UNICS就被称呼为UNIX了。

UNIX很快就在贝尔实验室流行开来了。
1974年，Dennis和Ken第一次对外公布了UNIX。他们在《美国计算机通信》(Communications of the ACM)上发表了介绍UNIX的论文。
这篇论文使得外界对UNIX产生了极大的兴趣，纷纷开始向贝尔实验室索要UNIX。

老实说，AT\&T是个大公司。恩不对，还是个垄断公司。AT\&T垄断了美国的电话网。
根据1958年为解决反托拉斯案例达成的和解协议，AT\&T被禁止进入计算机相关的商业领域。
所以,Unix不能够成为一种商品。实际上，根据和解协议的规定，贝尔实验室必须将非电话业务的技术许可给任何提出要求的人。
Ken Thompson开始默默回应那些请求，将包含着UNIX源代码的磁带和磁盘一包包地寄送出去——据传说，每包里都有一张字条,写
着“love，ken”（爱你的，ken）。

UNIX的源代码在高校间广泛传播\footnote{UNIX因此获得了一个非常重要的传统“附带源代码”。正是这个传统催生了后来的开源运动。}，
其中有一份代码被寄到了加州大学伯克利分校。在那里，UNIX被孵化，催生了BSD（Berkeley Software Distribution）。

在伯克利，一些重要的UNIX功能被开发出来。最重要的莫过于socket了。在BSD开发出socket之前，UNIX的网络功能简陋得可怜\footnote{UNIX有个uucp命令可以通过电话线执行远程拷贝，仅此而已。}。


AT\&T对UNIX源代码的“慷慨\footnote{没那么好心。不过是AT\&T还没意识到UNIX的商业价值，同时暂时性的被反托拉斯和解协议束缚了。}”奉献促成了UNIX的繁荣。

大量的新功能被开发出来，各种功能补丁雪花般飘到贝尔实验室。各种版本的UNIX不断涌现，商业化的UNIX系统也出现了。
伯克利开发BSD的Bill Joy加入了新成立的Sun\footnote{是Stanford University Network的缩写。2011年被甲骨文（Oracle）收购。}公司开发基于BSD的SunOS\footnote{SunOS从 5.0版本以后就不再基于BSD开发了。}。
就连微软也曾开发名叫Xenix的UNIX系统\footnote{但是微软把UNIX作为一个产品的热情并没有持续多久。}。


\subsection{UNIX混乱和分裂}

UNIX世界百花争鸣的日子随着AT\&T公司的拆分一去不复返。1983年，美国司法部对在针对AT\&T的第二起反托拉斯诉讼中获胜，AT\&T和贝尔实验室被拆分。这次判决将AT\&T从1958年的禁止将UNIX产品化的和解协议中解脱了出来。AT\&T马上忙不迭地将UNIX商业化------这一举措差点扼杀了UNIX。

那时，没有人意识到，UNIX的产业化会破坏UNIX源码的自由交流，而恰是后者滋养了UNIX系统早期的活力。AT\&T收回了原先的UNIX源码的许可，挂上高价（而在这之前，AT\&T只对UNIX源码收取象征性的费用），对源码散发严加防护。来自高校的贡献开始枯竭。

刚刚进入UNIX市场的几家大公司马上犯下了最重大的战略错误------试图通过差异化寻求有力地位------这个策略导致了
UNIX的分歧，抛弃了UNIX的跨平台兼容性,造成了UNIX市场分割。

AT\&T 拆分后的数年内，UNIX社区忙着UNIX大战的第一阶段-----System V Unix（AT\&T的将UNIX商业化后推出的UNIX）和 BSD UNIX之间的内部争吵。争吵分成不同的层面，有些属于技术层面（socket vs stream,BSD tty 对 System V termio），有些则属于文化层面。
AT\&T对UNIX的商业化使得UNIX作为统一的操作系统环境分崩离析。市场上充斥着各种互不兼容的UNIX。
给软件开发和系统维护带来了沉重的负担。

\subsection{统一的UNIX和POSIX标准}

1983年/usr/group标准组开始了以调解System V UNIX和BSD UNIX的API为目标的严肃的标准化工作。
随后IEEE以/usr/group标准为基础制定了POSIX
\footnote{其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC9945。POSIX这个名称是由理查德·斯托曼应IEEE的要求而提议的一个易于记忆的名称。}
（Portable Operating System Interface\footnote{最初这个X是 of UNIX最后的那个X。但是后来鉴于POSIX可以用于非UNIX（这些系统被称为UNIX-like，如Linux和Minix）系统，于是去掉了of UNIX但是保留了X。 }，可移植操作系统接口）标准。并于1985年发布了第一版。

POSIX标准定义了UNIX（和UNIX-like）系统的API\footnote{ 参考\faqref{API}}（Application Programing Interface）和shell命令所要遵循的标准。

后续开发的各种UNIX版本也严格遵循这个标准。

\begin{notice}
注意：POSIX标准是源码级兼容的标准。意思是在一个系统上编写的软件可以在另一个系统上“无修改的”通过编译并正常运行。
但是如果是编译好的可执行程序拿到另一个UNIX系统下“不保证”能执行。

但是对于shell脚本就另当别论了。POSIX定义了一个shell所必须具备的功能和行为。只使用POSIX定义的shell功能的脚本可以未经修改直接在另一个UNIX系统上执行。
\end{notice}

那么UNIX的故事到这里就告一段落了。Linux文化的的另一个重要来源GNU也要登上历史舞台了。

\section{GNU 的故事}

GNU也不是什么开天辟地的存在。早在GNU出现之前，类似GNU提倡的那种开放源代码的黑客精神就已经存在了。他们相互共享软件的代码，相互修改对方的软件。相信软件是一种自由的可以共享的东西。他们当中最杰出的一名，在黑客文化行将灭亡的时候，发出了著名的《GNU宣言》。这个人就是Richard Matthew Stallman\footnote{他的简称RMS比他的名字更出名}。

\chatu{rms-full-size}{Richard Matthew Stallman}

\subsection{RMS在MIT}

它发生在MIT的人工智能实验室。

1971年RMS进入哈佛大学学习，同年受聘于麻省理工学院人工智能实验室（AI Laboratory），成为一名职业黑客。

RMS在人工智能实验室的最出名的发明就是Emacs编辑器。Emacs打从一开始就以源码的形式进行发布。Emacs出色的设计使得它非常的流行。许多人对Emacs进行了改进。这些改进最终都回到了RMS的手里。这种共享代码的方式深受黑客们的喜爱。对于RMS来说，自由的共享软件的源代码是多么自然的事情。

但是商业化的浪潮也侵袭到了MIT。RMS感觉到他熟悉的黑客圈开始消失。

\begin{insertnote}
\subsection*{该死的私有代码}
在软件私有化的浪潮开始前，所有的软件销售的时候都是附带源码的（不过修改代码重新发布的权利还是没有的）。软件通常是作为硬件的“附属品”。
人工智能实验室购买了许多的硬件设备。当硬件驱动有错误的时候，RMS和他的黑客同事们总是能修正这些硬件驱动的BUG。他们甚至能开发出新的驱动让硬件提供不同的功能。

后来开发商逐渐的都不再提供驱动软件的源代码了。这样驱动程序出了问题这些黑客们只能对着机器发呆等待厂家修正。
可想而知RMS心里有多么的痛恨这些私有代码。如果他们有这些糟糕的软件的代码，就能修改它们而不是被动的等待厂商的修复。
\end{insertnote}

进入80年代，他的同事们许多都离开了实验室开始创立公司。
RMS觉得自己被逐出了黑客的伊甸园,他把这一切都归咎于私有代码。

\subsection{为了自由}

RMS认为所有的软件都应该是自由的。自由的意思就是:
\begin{itemize}
\item 运行的自由。你可以自由的决定运行或者不运行这个软件。运行的话怎么运行这个软件，在何种环境下运行\footnote{可别小看这个自由，许多软件规定只能在家运行，不能在作为商业用途在公司运行。}。
\item 修改的自由。你可以获得程序的源代码，并进行修改。
\item 再发布的自由。你可以自由的传播不论是你修改过的还是未修改过的软件。
\end{itemize}

RMS可以编写更多的自由的软件来做抗争。但是只要一个系统的核心------操作系统------是私有的软件，写再多的自由应用程序又有何意义呢？
于是RMS要做的第一件事情就是创建一个自由的操作系统。UNIX本来是自由的，却被AT\&T变成了私有的软件。于是RMS想到编写一个自由的UNIX兼容系统。这个项目的名字就是GNU，是Gnu is Not Unix\footnote{这种递归缩写在很多项目里用到。}的递归缩写。

造一个自由的操作系统首先需要编译器。于是他开始开发C语言的编译器。也就是GCC。到了1985年，RMS发现靠一个人的力量做事情太慢了，他需要帮手。于是他成立了自由软件基金（Free Software Foundation 缩写FSF）。同年RMS撰写了著名的自由宣言《GNU宣言》（The GNU Manifesto）。

1986年，GDB\footnote{GNU Debuger，GNU调式器}发布。次年，第一版GCC\footnote{GNU C Compiler，GNU C编译器} 发布。至此开发一个软件所需要的3大件------编辑器、调式器、编译器------齐备。

RMS面临的另外一个问题是，他需要保护自由软件的成果不至于被偷窃。UNIX就是一个活生生的由共享源码的自由的软件变成了AT\&T的商业软件的例子。于是在1989年，RMS编写了著名的GPL\footnote{GNU Public License，GNU公共许可协议}协议。

\subsection{以Copyright保护Copyleft}

自由软件的目的是\textbf{去版权化},也被 称为Copyleft。
但是首先要用版权保护自己。软件的作者通常会随软件附带一份许可协议，这份许可协议由版权法保护，用户同意即生效。而且要使用该软件用户必须同意（当然前提是这个国家对版权的保护非常好。）。
用户可以同意并使用该软件或者不同意并退回所购买的软件\footnote{这有点像是霸王条款？}。通常这样的许可协议是用来保护开发者的：微软公司就在他的许可条款里堂而皇之的说因使用微软的软件导致的损失微软免责，这种免责条款被大多数公司所使用。

GPL却利用了这点来\textbf{保证用户的权利}。用户被赋予了和开发者同等的权利，只要保证一点：他同意继续保持软件为GPL授权。

\begin{itemize}
\item 当你下载了GCC，你有自由执行它的权利。GPL授权的GCC不会在许可协议里说，“嘿伙计，你只能在Windows下执行该软件\footnote{微软的Office软件有此条款。}”

\item 当你下载了GCC，你就拥有了GCC开发者相同的权利。你可以查看GCC的代码------FSF的网站上提供GCC源码下载------就和GCC开发者能查看GCC的代码一样。

\item  当你下载了GCC，你就拥有了GCC开发者相同的权利。你可以修改GCC的代码------就和GCC开发者能修改GCC的代码一样。

\item  当你下载了GCC，你就拥有了GCC开发者相同的权利。你可以把GCC修改后（或者没有修改）分享给任何一个人------就和GCC开发者能把这个软件发给你一样，而不会在许可协议里说，“嘿伙计，你不能把本软件拷贝给任何一个人，否则就是非法拷贝，是盗版”。

\end{itemize}

所有的这些权利你都能获得，只要你同意
\begin{itemize}
\item 当你再发行这个修改或者未修改后的软件的时候，你保证不修改它的许可协议。让它的GPL协议传播给下一代。
\item 当你在自己的软件里用到了一个GPL授权的软件的一部分或者全部的代码的时候------就算你没有将这个软件的代码直接包含到你的软件中，而只是使用里它提供的函数库------你保证将你的软件同样以GPL协议授权。
\end{itemize}

GPL就是通过如上的传染性保证自己能像病毒一样迅速传播。随着GPL授权的软件愈来愈多，最后几乎不可能编写一个完全不依赖GPL代码的软件了。这样所有的软件最终都将被迫GPL化\footnote{我不知道这个词语之前有没有人用过，我希望读者能理解这里个词语的含义，就是改变原先的许可协议为GPL。}。

到1992年，GNU项目开发出了一系列的软件，包括编辑器、开发工具链（编译器，调试器，C库，autotools\footnote{参考}）、shell和系统工具等等，再有一个内核就是完整的自由的操作系统了。但是GNU的Hurd内核一再跳票，距离发布的日子遥遥无期。这个时候GPL授权的Linux内核刚好填补了Hurd的位置，使GNU成了一个彻底完整的系统。至此UNIX的文化经过80年代的短暂中断后在GNU和Linux的组合系统中延续。
