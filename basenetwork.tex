
%\begin{quotes}[0.5]{microcai}
%The protocol is the kernel of the net. The kernel is the protocol of the UNIX. The UNIX is the source of the net.The source is the kernnel of the UNIX.UNIX, the net , the protocol , you are one.
%\end{quotes}

若要问世纪末最伟大的发明是什么，一定有人说，是Internet。Internet让全世界的电脑连在了一起。

\section{层次协议网络}

说到网络不得不提到OSI的7层网络模型。

\begin{table}[h]
\begin{center}
\caption{OSI模型}\label{tabel:ISOmodule}
\begin{tabular}{|c|c|c|c|}
\hline
& 数据单元 & 层 & 功能  \\ \hline % \cline{2-4}
\multirow{4}{*}{主机层}   &  \multirow{3}{*}{块数据} & 应用层  &  网络应用程序  \\ \cline{3-4}
&						 & 表现层 & 数据表现，加密解密，数据格式转化  \\ \cline{3-4}
&						 & 会话层 & 管理会话 \\ \cline{2-4}
& 分片数据  & 传输层 & 点对点的可靠通讯，流控制 \\ \hline
\multirow{3}{*}{媒介层}  & 数据包   & 网络层 & 网络寻址和路由 \\ \cline{2-4}
& 帧 & 链路层 & 物理寻址和交换 \\ \cline{2-4}
& 比特 & 物理层 & 物理信号传递：光电等 \\\hline
\end{tabular}
\end{center}
\end{table}

OSI定义的7层模型是参考模型。

第一层，物理传输层。典型的我们每天都能见到的就是以太网和Wi-Fi了。太网使用同轴双绞线传递差分信号，由以太网协议规范。网卡的接口电路负责实现。
使用同轴双绞线传递差分信号，可以认为能传递 0 和1。Wi-Fi则使无线信号进行传输。物理传输层的单位是比特。我们常说的100M网卡指的就是网卡使用的100M以太网协议，每秒可以发送100M个比特的数据。这个数据是指物理传输层的。56k调制解调器也是说的这一层的速率为56Kbit/s。


第二层，链路层。典型的链路层协议就是以太网了\footnote{什么？又是以太网？ 额，不是说了么，实际上没有完全参照OSI的模型。}。以太网协议包含了物理传输层和链路层两层协议。
在链路层，以太网使用“以太网帧”封装形式向上层提供基于帧的数据包传输功能。传输的单位是一个以太网帧。 以太网帧具体长度不确定，以太网协议只规定了最小和最大数据包长度。典型网络应用下，以太网最大帧长度为1518字节，最小帧长度为64字节。除去以太网帧的头部信息，以太网帧最大可以传输的有效数据为1500字节。

第三层，网络层。当下用的最广泛的网络层协议就是IP协议和它的升级版本IPv6协议\footnote{不过在不混淆的情况下，可以继续IP协议指的是IPv4。}。
IP协议发送的依然是数据包。每个数据包由“IP协议头+负载数据”构成。一个IP数据包正好作为链路层（比如以太网）的负载数据发送。IP协议为每一台主机分配了一个全球唯一的IP地址\footnote{实际上IP地址划分出了几个区段，不能用于因特网，只能用于自己组件的私有网络中。这类私有地址在全球范围内是可以重复的。但是在每个私有网络内部仍然是不能重复的。}。IP地址通常使用点分十进制表示法。

第四层，传输层。自然就是TCP协议了。TCP在IP包的基础上提供了可靠的流式传输协议。TCP将数据打散为一个一个的包，然后利用IP协议传输打散的包。
如果发生丢包，TCP协议还会重新传输丢弃的包。到目的地，TCP会将数据包重新组合为数据流。另一个传输层协议是UDP协议。 %不过只简单的把IP协议包装一下，所以不能提供可靠

第五层，会话层。还是TCP协议。TCP包含了连接建立，数据收发和连接断开。建立一个连接就是一次TCP会话。TCP协议使用“三次握手”建立连接。断开连接则是四次握手。

第六层，表现层。在TCP/IP中，这个层已经不是他们负责的啦。如果应用程序使用了SSL加密协议，比如使用 HTTPS 访问网站，则SSL可以认为是这一层的。
直接传递数据而不加密的应用中，这一层是缺失的。

第七层，应用层。这类协议众多。访问网站使用的HTTP协议，访问FTP使用的是FTP协议，等等。

在每一层协议中，都有一个“负载”用来承担上一层协议的数据。理论上来说每层都是独立的，没有一定要用第$n$层来装配第$n+1$层数据的说法。比如链路层可以不建立在物理传输层之上，而是依靠其他层的协议建立一个“虚拟”链路。典型的应用就是VPN（虚拟专用网）。

%而实际上，层之间甚至是可以交叉越级的。比如各种VPN\footnote{后面会介绍VPN是什么}协议就是利用的应用层来传输IP数据包。还有利用应用层传输以太网帧的。

实际上构成互联网基石的TCP/IP协议并没有完全按照7层实现，而是只有4层：网络接口层、网络层、传输层、应用层。

\section{网络接口层}

在IP网络中，物理传输层和链路层被看作为一层：网络接口层。
网络接口层的作用是因为向上层IP协议提供分组交换的网络。
分组交换的意思是，通信双方的传输单位是分组的数据包，每个数据包要么完整传达，要么整体丢弃。数据包在存在“交换设备”的情况下可以在交换设备中依据地址重新转发。

\subsection{以太网}

说起网络接口，大家都对RJ45接口不陌生。这个插头的符号都要成为网络接入的代名词了。因为它正是被大名鼎鼎的“以太网”选用的标准插接口。

\chatu[width=0.5\textwidth]{Ethernet_RJ45_connector_p1160054}{RJ45网线插头\protect\footnotemark}

\footnotetext{图片来自维基百科}

以太网，英文名Ethernet，是使用的最广泛的网络。从最初的10M/s传输速度到100M/s再到1000Mb/s,甚至10G/s的传输速率都研究出来了。现在应用最广泛的还是100M/s和1000M/s两种。
以太网最初由施乐公司开发，于1985年成为IEEE 802.3标准。此后横扫全球，将所有其他的有线网络一网打尽。

具体的来说，以太网定义了两个子协议，分别定义在物理和软件两个层次。物理层次来说，以太网规定了双绞线上的信号传递方式。%以差分电信号的形式传递基带信号\footnote{通信业的行话，未经过调制的数字信号就是基带信号。简单的理解就是0和1嘛。}。
链路层定义了以太网帧和它的工作方式。

以太网帧由“前导同步序列+太网帧头+负载数据+尾同步序列（帧间隙）”构成。同步序列用来在01比特流中识别出以太网帧。
%并且网卡在发送同步序列的时候还负责检测“碰撞”——多个网卡同时向一条线路上发送以太网帧。遇到碰撞的时候，网卡负责重发。
以太网帧头包含了负载数据的大小、发送方地址和接受方地址。
每个以太网接入设备\footnote{接口卡的话被称为网卡}被分配了全球唯一的地址。这个地址被称为MAC地址。
%操作系统能控制的就是以太网头部中的“发送地址和目的地址”以及负载数据。这一层依旧使用以太网协议。
以太网网卡会丢弃目的地址不是自己的数据，只接受发送给自己的数据和以太网广播数据（地址为一个特殊的广播地址）。除非进入“混杂”模式，这个时候会接受全部的数据。

\subsubsection{共享介质和冲突检测}

以太网是总线结构的共享介质网络。

TODO示意图 同轴电缆和集线器 %TODO

最初的以太网是采用同轴电缆来连接各个设备。电脑通过一个叫做附加单元接口（AUI，Attachment Unit Interface）的收发器连接到电缆上。
双绞线的淘汰同轴电缆后，以太网使用集线器将多个设备连接到一起，虽然物理上是点对点通信（集线器到终端），逻辑上仍然是总线结构。因为集线器只是简单的“复制”各个端口的数据。
这就带来了冲突问题：多个设备同时向总线发送数据必然会导致冲突。以太网使用CSMA/CD（Carrier Sense Multiple Access/Collision Detect，带冲突检测的载波侦听多路访问）技术
解决共享介质的冲突问题。具体步骤如下：

\begin{enumerate}
\item     开始 - 如果线路空闲，则启动传输，否则转到第4步
\item     发送 - 如果检测到冲突,继续发送数据直到达到最小报文时间 (保证所有其他转发器和终端检测到冲突)，再转到第4步.
\item     成功传输 - 向更高层的网络协议报告发送成功，退出传输模式。
\item     线路忙 - 等待，直到线路空闲
\item     线路进入空闲状态 - 等待一个随机的时间，转到第1步，除非超过最大尝试次数
\item     超过最大尝试传输次数 - 向更高层的网络协议报告发送失败，退出传输模式
\end{enumerate}

就像在没有主持人的座谈会中，所有的参加者都通过一个共同的媒介（空气）来相互交谈。每个参加者在讲话前，都礼貌地等待别人把话讲完。如果两个客人同时开始讲话，那么他们都停下来，分别随机等待一段时间再开始讲话。这时，如果两个参加者等待的时间不同（等待随机时间），冲突就不会出现。复杂的冲突检测问题被以太网以“等待随机时间”巧妙的解决了。就算再次冲突，两台设备多次出现相同的随机时间的概率也非常低。

\subsubsection{链路层交换}

这种“一个说，大家听”的特质是共享介质以太网在安全上的弱点，因为以太网上的一个节点可以选择是否监听线路上传输的所有信息。
共享介质也意味着共享带宽，所以存在效率低下问题，严重限制了同一个以太网网络上可以相互通信的机器数量。

大多数现代以太网用以太网交换机代替集线器。通过记录分析网络上设备的MAC地址，交换机可以判断它们都在什么位置，这样它就不会向非目标设备所在的网段传递数据包。

TODO 插图解释集线器和交换机的工作方式 %TODO

交换机加电后，首先也像集线器那样工作，转发所有数据到所有端口。
接下来，当它学习到每个端口的地址以后，他就只把非广播数据发送给特定的目的端口。这样，所有端口对之间的通讯互不干扰。因为数据不再广播，一定程度上带来了安全性。

%TODO 更详细的解释

\subsubsection*{小插曲：永恒的以太网}
以太网之父层说过，如果有什么技术要取代以太网，那么取代以太网的技术也会被称为以太网，所以以太网是永远不会消失的。\hspace{-0.5em}\footnote{原话见本章章标题下面的引用。}~最初的以太网标准是 10BASE5， 传输速度只有10M/s。但是100M/s有线网络开发出来后，本来取代以太网的协议依旧称呼为以太网——快速以太网是也。
1000M/s的网络开发出来了，本来要取代以太网的，结果又冠名为千兆以太网。果然被以太网之父说中了。以太网是永恒的。

以太网不仅征服了有线网络，还有无线网络。Wi-Fi，又被称呼为wireless-lan，无线局域网，另一个名字就是无线以太网。什么？又是以太网？是的，没错，依旧是以太网。
以太网征服了有线网络和无线网络，还不肯罢休，因为它又征服了光纤网络。
以太网标准本来就支持除了双绞线作为传输介质外，还可以使用光纤。新的100GBASE-ER4\footnote{传输速度为100G/s}能在单模光纤上提供超过40公里的传输距离。

连传统上不适用于以太网的“最后一英里\footnote{从ISP到用户的网络接入，因为大概距离也就一英里，故有此得名。}”，都用上以太网了。

EPON\footnote{Ethernet Passive Optical Network，以太无源光网络。}又被称呼为最后一英里的光纤。EPON以无源光纤作为传输介质，上层跑的还是以太网。
从前从运营商到用户都是使用的ASDL这里设备，EPON正在逐步取代ADSL\footnote{所谓光纤入户就是EPON。}。%，使得PPPoE\footnote{PPP Over Ethernet。}协议可以在光纤上直接运行。是的，EPON使用光纤作为传输介质，但是还是以太网协议。

以太网是一个局域网标准，但它的光纤版也开始侵入广域网了。10G以太网慢慢的侵吞原来的SONET/SDH光纤网络。

以太网所以能广泛应用，得益于它的简单和有效。相比于其他协议\footnote{作为对比，可以先阅读一下ATM相关资料。}，以太网协议非常简单。以太网协议将自己划分为链路层和物理传输层两个子协议。链路层部分以太网几十年如一日的保持了简单和稳定。不管是有线还是无线甚至是光纤，链路层的协议永远都是一样的。唯一变化的是传输层。从10M/s到10G/s，变化的永远是传输层。
但是其上的链路层永远是一致的。永恒的是以太网，永恒的是链路层以太网协议。

\subsection{无线局域网Wi-Fi}

无线局域网，工作在2.4GHz无线电频段。利用无线电波代替了双绞线。使用 802.11 作为物理传输层协议，在链路层依旧使用以太网协议。所以又称无线以太网。

Wi-Fi有两种工作模式，Infrastructure和Ad-hoc。

我们常用的模式就是Infrastructure。Infrastructure模式需要一个无线网桥。在家庭环境下通常这是一个无线路由器。需要访问网络的设备只需要连接到网桥就可以。设备和网桥之间建立无线点对点通信即可。
链路层交换由网桥实现。

TODO 网桥插图 %TODO 

一个无线设备不能同时连接到两个网桥，同一个地方出现多个无线网桥怎么办呢？这就需要SSID。SSID是接入点的名称，是一个字符串。用户连接到无线网络的时候可以由操作系统向用户呈现。

\chatu[width=0.75\textwidth]{showssid}{KDE显示本地搜索到的1个无线网络\protect\footnotemark}

\footnotetext{有个名为<hidden network>并不是真有这个网络，具体情况请参考 \secref{sec:networkmanager}。}



另一种模式又叫“去中心化”无线网络。因为 Ad-hoc 并不依靠一个 Infrastructure（无线网桥），可以由两台支持Wi-Fi的电脑直接通信。

TODO ad-hoc插图 %TODO 


\subsubsection{无线加密}

无线局域网和有线相比，更容易遇到数据监听和非法接入的问题。避免数据被监听和被非法盗用网络的办法就是给无线网络开启加密。

\begin{notice}
注意：加密协议工作在第一层。上层是以太网帧，然后使用加密协议将以太网帧进行加密，接着将加密后的以太网帧封装进802.11协议再通过无线电发送出去。
\end{notice}

Wi-Fi可以使用多种加密认证协议。比较常用的WEP和WPA。WPA和WEP使用密码进行加密，好处就是只需要输入一个密码就可以访问无线网络了，方便快捷。
WEP加密轻度低，已经面临破解风险，所以不建议使用了。好在WPA目前来说还有足够的加密强度。

\subsection{点对点协议}

ADSL对很多人来说并不陌生。用网线把电脑和ADSL猫连接在一起，电脑上创建一个拨号网络，拨号即可上网了。在这里，实际上使用了2个链路层协议和2个物理传输层协议哦。

两个物理传输层协议自然是指的以太网和使用电话线进行传输的ADSL。

ADSL拨号需要使用PPPoE拨号软件（Win98年代需要用户另外安装，现在各个操作系统都内置了）。所以这个链路层协议自然就是 PPPoE了。PPPoE是 PPP over Ethernet的简称。
另外一个链路层协议不用说其实就是 PPP over ADSL。

PPP（Point-to-Point Protocol，点对点协议）本身是个链路层协议，但是没有物理传输层的它，需要借助其他通讯层传输。借助以太网帧传输PPP协议就是 PPPoE。
%，借助UDP协议传输PPP有个好听的名字PPTP\footnote{是一种VPN哦，下节马上会介绍到。}。
PPP通常被封装到其他协议里，只是承载方式不同，不同底层协议所承载的都是PPP协议的数据包。故而有PPPoX （PPP over X\footnote{X取值很多很多很多}）之说。

%为其他协议创建的虚拟的链路向IP层提供统一的接口。

在进行ADSL拨号的时候，需要提供用户名和密码。这个认证就是PPP协议执行的。ADSL只是在模拟电话线路上传输数字信号的协议，并不能提供认证，所以需要PPP协议的帮助。

PPP提供的认证协议有：PAP, CHAP, MSCHAPv2, MSCHAP, EAP 五种。还提供MPPPE加密，BSD和Deflate压缩，TCP头压缩等功能。
%PPP主要用来在不支持链路层认证的网络上提供网络认证。

PPP（Point-to-Point Protocol） PPP本身是个虚拟的链路层协议，其作用就是为上层IP协议提供一次封装，并在链路层提供数据加密和身份认证。

\subsection{虚拟专用网-VPN}

PPP是个虚拟的链路层协议，那么谁给PPP提供第一层呢？如果第一层是电话线，那么PPP就是构建了拨号网络，如果第一层是以太网，那就是PPPoE。如果是使用应用层的协议来封装PPP呢？

使用应用层协议封装PPP，应用程序就可以自行定义数据传输，而仍然将实现IP协议的任务交给操作系统，这就有可能创建一个虚拟的局域网——Virtual Private Network名称由此得来。

目前有很多虚拟网实现，大名鼎鼎的有PPTP, L2TP。这些VPN都是在应用层协议，利用基础的TCP或者UDP协议传输经过自行开发的格式封装的PPP封包。在Linux下，这些虚拟的网络协议会
生成一个虚拟的网卡（ppp0 ppp1 等命名,数字代表是第几个创建的接口。），内核使用PPP协议封装IP协议，然后将封装好的PPP包交给实现VPN的程序，这些程序再将PPP包封装进自己的协议里，然后使用 TCP或者 UDP传输这些包。至于认证之类的就可以交给 PPP 协议了。这样就能避免重复开发。不过VPN也可以自行进行验证，然后由PPP执行第二次认证，双保险。%事实上OpenVPN就是这么做的。
当然也有的VPN并不使用PPP协议，直接封装IP包，所以并不会出现ppp0这样的设备。

那么，看上去是个应用程序的虚拟网其实是链路层的。也就是一种虚拟链路层\footnote{这也说明并不一定第n层是由第n-1层传输的。}。
因为VPN实现的是虚拟的链路层协议，并且通常是利用应用层来传输的，感觉像是一个隧道
一样，在遥远的两个主机之间建立了一条虚拟的通信链路，访问起来就像是本地的局域网一样。所以VPN协议又叫隧道协议。PPTP（点对点隧道协议）、L2TP（第二层隧道协议）名称里的T就是隧道的意思。

一般来说，能在链路层直接访问（链路层的交换设备能直接转发数据包到目的主机）的网络称为局域网\footnote{有时候一个比较大的局域网使用了路由器，使得不能在链路层交换的数据包也能通过路由器路由了。因为使用了路由器，所以已经不太符合局域网定义了。嗯嗯，不过他们禁止把那台路由器叫做路由器，而叫做三层交换机（工作在IP层的交换机），哪有路由器？我用的是交换机！所以还是局域网！}。隧道协议创建了虚拟的链路，也就是远程主机能在链路层直接访问了，所以虚拟局域网的名称由此得来。
因为使用隧道协议利用因特网创建一个“私有”的虚拟局域网，故而又被称作虚拟专用网。

\section{网络层：IP协议}

IP协议从OSI的模型上看，属于网络层。使用IP协议的网络就是IP网络\footnote{除了IP网外，还有电话网，有线电视网。}。
IP网络按照规模分为局域网，城域网和广域网。而当今世界上最大的广域网就是因特网。

IP网的作用类似快递——传递数据包。IP网并不保证数据包总是能到达目的地——虽然网络建设的时候总是力求降低丢包率，但是IP本身并不100\%保证数据传达。

IP网工作在网络层，需要使用链路层协议传输数据包。在全球范围内，IP骨干网使用的是ATM和X.25这样的光纤网络进行传输的。在本地局域网，使用以太网协议。从ISP到家庭用户，使用的是
ADSL这样的拨号网络。甚至可以不是物理网络：使用各种应用层协议传输IP包——这就是VPN的原理了。

由于IP协议不提供可靠的数据传输。IP只能尽量保证将数据包传递到目的地。在这里不可靠的意思有两层：第一个意思是数据包可能丢失，第二个意思是丢失不丢失发送方无从知晓。如果发送方知道数据丢失，则仍然任务协议是可靠的——发送方可以选择重发或者标记网络不可达——这意味着任何协议都无法完整数据包的送达。

IP的另一个不可靠特性是接受方收到的数据包次序和发送方并不能保证是一致的。可能会出现乱序。因为IP数据包是经过“路由”的。我们会在下一个章节介绍路由。

\subsection{路由表和路由协议}

上节说到IP协议传递的是分组的数据包，每个数据包标记了目的地址和发送地址。数据包在发送到目标之前会经过层层的“路由”。

TODO 路由示意图

解说： IP网络由主机和路由器以及连接它们的通讯线路组成。图中示意的是一台主机发送数据包到多台目标主机的过程。

主机A分别发送数据包到B、C、D，向B是直接发送。向C是通过B的转发到达。而发送到D的数据则经过了E、F、H的转发。另外一条可能的路径是B->G->F->H->D，不过这是一条比较“远”的路径。
像 F 这样的主机连接了大量的网络，专门用来转发数据包，被称之为路由器。B这样的主机，本身也提供服务，但是也转发数据包。在转发数据包的时候它是路由器，本身发送和接收数据包的时候它是主机。

一台主机是不是路由器主要看它在网络上的作用。我们有时候会把专门制造的用于路由的计算机称作路由器。当是IP网络上任意一台主机都可以担当路由器——只要它扮演了这个角色。

我们可以看到，一个数据包从A到D可以选的路径不止一条——但是有的路径经过的节点少，有的则多。也就是说，这些路径的质量是不能等同看待的。
衡量一个路径的标准自然就是用户最关心的：延迟和带宽。经过的节点越少通常来说延迟就越少。带宽自然是越高越好——为了尽量避免拥挤的线路，不仅仅是要选择带宽高的路径，还要选择带宽没被占满的。

如此一来就带来两个问题：第一个问题，IP数据包在进行路由的时候，如何知道哪条路径是可以将数据包准确的送达目的地的——这属于路由发现问题；第二条，拥有多个路径可选的时候 ，如何选择一个最佳路径——这属于路由选择问题。

在操作系统的实现上，内核是依据一个“路由表”执行路由的。路由表可以修改，所以选择最佳路径归结为“在系统运行中动态的修改路由表以让内核总是使用最佳路径”这个问题了。

路由表是一张表格，详细的列举了每个IP（也可以是一个区间，这样可以减小表的大小）应该使用哪个路径。比如对A来说，向C和B发送的数据，使用的网关就是B。路由表上记载的应该就是 C->B , B->B 这样对应的条目。但是对于D，路由表包含的是 D->E 。使用 E 来转发。而事实上E并不能直接将数据转发给D，E 的路由表里包含 D->F 这样的条目，因此E将数据包交给 F 来转发。数据就是这样层层转发的，路由表并不记录完整路径，而是接力棒一样。
所以用来接下一棒的路由器被形象的称呼为网关。

路由表可以由管理员手工输入（使用route(8)命令）。管理员输入的路由表被称为静态路由表。但是面对复杂的网络——尤其是那些运行在互联网的骨干上的路由器来说——手工维护显得非常不合理。
所以就催生了各种路由协议，在路由器之间动态维护路由表。粗略的列一下，大概有边界网关协议（BGP）、外部网关协议（EGP）和内部网关协议（IGP）。
大协议下还细分了许多子协议，用来进行距离探测，链路状态探测等。路由协议运行在互联网的骨干路由器上。用于路由器之间维护完整的优化的路由表。普通用户的机器通常并不需要运行路由协议。设置一个默认网关就足够了。

\begin{insertnote}
\subsubsection{默认网关}

默认网关告诉操作系统，所有条目都不匹配的时候使用这个网关。因为路由表总是从上而下进行匹配的，所以默认网关总是路由表的最后一条。

一般家庭局域网的机器上，路由表只有两条：一条告诉本机哪个IP范围的IP是直接发送的，其他的都使用默认网关。属于本地局域网的IP自然是不经过路由的。机器判定本地IP的范围使用的就是
DHCP\footnote{参见\secref{sec:DHCP}}的时候获得的掩码。而大部分IP地址都是用过默认网关进行路由的。毫无疑问这个默认网关就是家庭路由器:)。

\end{insertnote}

那么，接下来整理一下，我们在这个想象中的网络具体的观察一下IP协议的运转。

TODO 插图
%TODO

\begin{enumerate}

\item 局域网（Hub集线器） ： 主机A发送到主机B，因为是他们连接到一个集线器上，所以主机A首先发送一个以太网广播（ARP协议）获得B的mac地址。
然后就可以直接向B发送数据了。Hub集线器实际上就是把网线加终端电阻连接到一起。所以数据在Hub的端口之间是直接广播的。目的地址是B的mac地址的以太网帧被B收到——也就是收到A发送的IP包了。

\item 局域网（带交换机）： 主机A发送到主机C，因为是他们连接到同一台交换机上，所以主机A首先发送一个以太网广播（ARP协议）获得C的mac地址。
然后就可以直接向C发送数据了。数据由交换机交换传递到C连接到的端口，这样主机C的网卡就能收到A发送的IP包了。

\item 局域网（无线网桥\footnote{简称AP。}） ： 主机A发送数据包到D，中间通过了无线网桥，将有线以太网协议转化为802.11a/b/g协议，使用天线发送。802.11a/b/g协议属于第一层协议。第二层依然是以太网协议。网桥在这里是做了
第一层有线以太网协议到802.11a/b/g协议的转化。IP是第三层协议，所以这个时候依赖的第二层以太网协议本身没有变化。对IP层来说，无线和有线是透明的。都是以太网。所以这里依然使用ARP协议获得接收方的网卡地址，然后直接发送。这里网桥和交换机是一样的功能。

\item 局域网（无线到无线）： 主机A发送数据到D，这个时候断开网线，自动切换到使用无线网络。发送依然要经过网桥。仍然是以太网，依旧是ARP协议首先获得对方的mac地址，然后发送。数据由网桥转发到目的主机。

\end{enumerate}

\section{传输层：TCP和UDP}
为了提供可靠的通信，可以在IP协议的基础上加入数据接受确认、超时重发、和顺序重组功能就可以提供一个可靠的面向流的协议。该协议提供给上层可靠的面向流的协议——可靠的意思是，协议告诉你发送成功接收方就一定已经收到数据，协议告诉你发送失败接收方就是没接收到；面向流的意思是，数据在底层会被分包以使用IP协议传输，但是如何分包是不需要上层操心的，上层交给协议的 就是一连续的字节流，接收方收到后会重组为正确次序的字节流。除了可靠和流式这两个特点，还应该加入拥塞控制——发送速度不要超过网络能提供的最大带宽避免网络拥塞。整合这些需求后，诞生的就是TCP协议了。

由于主机通信双方并不可能只有一个程序。所以当一个TCP数据送达，只根据发送方地址来区分（这样的话一个主机只能向另一个发起一个链接了）太不合理了，所以TCP协议引入了“端口”的概念。
如此一来，一个主机就可以执行多个程序，使用不同的端口进行通信，相互之间不干扰。这样确定一条TCP链接的就是两个IP地址和2个端口了\footnote{发送方和接收方的端口，发送方和接收方的IP。}。如果没有端口，则两台主机之间只能建立一条TCP连接。

如果应用程序不需要TCP提供的可靠流式传输，想直接使用IP这样简单的“尽力送达”服务，另外有一个UDP协议可以使用。UDP协议在IP协议之上简单的加了一层“端口”。当然加入端口和TCP的原因是一样的——没有端口的话，一台主机岂不是只能有一个程序能接收数据？\footnote{操作系统将无法确定接收到的数据包应该传递给哪个程序。
有了端口，使用UDP协议的程序可以绑定到一个端口上，这样对应的端口接收到数据操作系统就可以知道将数据递交给哪个程序。}

对TCP来说，因为在进行数据传输前要建立连接，所以必须有一方是发起连接，另一方是等待被连接。等待被连接的一方，需要监听在某个端口，以便有连接上来的时候可以马上作出反应。比如通常Web服务器都在80端口监听，FTP服务器则是在21端口。选择被动连接，也就是监听的一方通常扮演服务器的角色

\subsection{TCP连接的建立}

建立连接之前，我们最关心的是目的主机是否可达，对吧？有一个简单的办法就是：向对方发送一个数据包，并要求对方回应。
如果发出一个数据包并收到了对方的回应，我方就能确定整个链路是畅通的。
但是对方收到了我方的数据，它能确定的是我方到它的数据链路是通畅的，接着它发回响应数据包的时候，它是不能确定自己的数据是不是能被我方收到的：网络中常常出现单向可达的故障。
所以对方回应后，我方必须再次发送确认数据。如此有一来二去共来回发送了3次数据包才能真正的确认双方链路畅通。

这就是建立 TCP 连接的三次握手。
在这三次握手的过程中，通讯双方交换了其他一些信息。这些信息将用于后续通讯。


TODO 插图解释 %TODO


\subsection{发送和确认}
IP协议只能做到“尽力送达”，要建立可靠的通信，必须“保证送达”。保证送达的简便办法就是接受方回送一个
“已经收到”的讯息。TCP每发送一个数据包，都要求对方在指定时间内回应。如果没有在限定的时间
内收到对方的回应，则进入超时重传。重传次数超过一定的限度，则认为连接丢失，并向上层应用报告连接丢失。通常意味着
应用程序会收到一个 “broken pipe”错误。

为了最大化利用现有的带宽，TCP并不是每发送一个数据包都等待对方的确认。而是在收到对方的确认之前可以发送多个数据包。操作系统建立一个已发送列队，收到对方的确认信息后将数据包从发送列队移除。否则等待超时后重发。
已发送列队小于指定大小的时候，发送待发送列队的数据，并将待发送列队的数据移到已经发送列队里。

TODO 多图片说明 %TODO

已发送列队就像一个窗口一样，随着接受方的确认向待发送列队推进。这个窗口的大小就被称为TCP发送窗口，由接受发根据自己的带宽告诉发送方建议的发送窗口大小。接受方可以通过控制发送窗口来控制数据传输速率。发送方的实际发送窗口可以比接受方给出的小，但是不能超过它。

\begin{insertnote}
\subsubsection*{为什么由接受方来确定最大发送窗口大小}
从网络上下载软件的时候，我们通常会注意到，下载速度受限于本地带宽。服务器通常有更好的带宽，如果服务器以自己
的带宽做支持的速率发送数据，因为我们并没有服务器那么富余的带宽，必然产生拥塞。
这就要求数据发送方不得以快于接受方的链路速度发送数据。所以必然是由接受方控制发送方的最大发送速率。

\end{insertnote}

\subsection{断开连接}

TCP有两种断开连接的办法：暴力断开和温柔断开。

相信大家在上网的时候，或多或少会遇到“连接被重置”吧。只要其中一方发送RESET包，就算断开连接了。
当然正常情况下需要温柔点在做法。TCP是一个双工协议——连接建立后，数据可以双传输。断开连接需要关闭两个发送方。

其中一方发送结束包（FIN标记），另一方确认后，即可关闭一方的发送。这个时候TCP连接处于单向数据传输状态：关闭发送的那一方只能接手数据不能再发送数据，这个状态也称半连接。接着另一方也执行同样的过程关闭发送权，这样TCP连接才算彻底断开连接了。
这过程共来回发送了4次数据包，所以称断开连接的4次握手协议。


TODO 插图

%TODO

\section{应用层}

在这一层就是各个应用程序自己的事情了。TCP提供了流式数据收发服务，UDP提供了不可靠的数据包收发服务。
应用程序自己可以在这个基础上构建自己的协议。比如HTTP协议，FTP协议。

IP/TCP协议中，应用层对应OSI的7层模型里的5、6、7层。第1、2、3层由操作系统实现，操作系统通过编程接口由应用程序自行实现应用层协议。

目前大部分操作系统为应用程序提供的网络变成接口为套接字（socket），由BSD发明，并被各大UNIX接受。连非UNIX系的Windows系统也是使用的套接字做为编程接口。

OSI模型里有一层，叫表现层。对于TCP/IP网络层次中是应用层。须知的是，表现层负责的是数据的加密传输——应用程序可以自行设计加密协议，不过如果能有个标准的协议层实现是最好不过了。HTTP协议是个文本协议，TCP传输的是未经加密的文本流。而一旦将他跑在一个加密层上，那就成了HTTPS协议了。

\subsection{安全套机字层:SSL}

HTTP和HTTPS的唯一区别就在于HTTPS使用了一层加密。这个加密协议就是SSL（Secure Socket Layer）。在TCP/IP网络中，SSL由应用程序实现。实际上应该是第六层。理想的 OSI模型应用层是第七层协议。
所以HTTP和HTTPS协议应该是一致的，HTTP协议的应用程序可以未经修改就能支持HTTPS。不过在TCP/IP协议上，SSL也得程序实现。在TCP之上，操作系统就爱莫能助了。好在我们还有库。应用程序只要使用 SSL库即可。不必自行实现。

使用最广泛的SSL库莫过于莫过于OpenSSL了。不过OpenSSL的协议包括了一条“修改OpenSSL的代码不能简单的以另外的协议发布，包括GPL”。着实让GNU不爽，于是GNU开发了gnutls作为应对。并在自己的项目中只使用gnutls库。

%SSL是一种加密通讯方案，但是并没有限定使用的加密算法。
为什么需要SSL呢？它有什么好处？要了解SSL的用处首先来了解一下中间人攻击问题。

\begin{insertnote}
\subsubsection{中间人攻击}

假设A向B发送一条讯息。他们的信息需要经过C的转发。
%如果A和B之间没有第三者转发，只需要担心窃听的话，简单的将数据加密就可以，但是正因为数据经过了C的转发，问题变得复杂起来。
互联网是个分布式的网络。接入互联网的人和机构何止千万。所以这负责中间转发的第三方一定会有心怀不鬼的，简单的来说，除了A、B自身，网络上的其他节点是不可信的。 

那么问题就来了，因为数据经过了C的转发，B如何确定这个数据有没有被C截获呢？
有时候A发送的是一条公告信息的话，并不在乎是否被C知道消息内容，但是B必须确认一件事：这确实是A发送的么？有没有C伪造了A的信息的可能？ 有时候，确定数据的来源确保没有被伪造比保护数据不被窃听更重要。

如果C伪造了A的数据向B发送，那么可能遇到非常严重的欺骗问题了。

事实上中间人攻击就发生在我们身边：朋友的QQ号被盗，导致自己被骗钱的事时有发生。
因为仅仅凭借一个QQ号就相信对方而没有没有去确认，这个和仅凭一个IP地址就相信对方不是一样的么？

\end{insertnote}

不管是IP协议还是TCP协议都没能提供担保数据原始发送方的真实性。那么SSL是如何做到的呢？
首先来了解一下非对称加密

\begin{insertnote}
\subsubsection*{非对称加密}
相信大家有接收或下载到过加密的压缩包。输入解压密码后即可解压。这个压缩包创建和解压的时候使用的是相同的密码。
这就是对称加密。使用相同的密钥完成加密和解密过程。

有的加密方案，需要两个密码。使用其中一个密码加密的数据只能使用另一个密码解密。这种加密方案就是非对称加密。
非对称加密通常将这2个密码中的其中一个公开，只保密其中一个。公开的那个叫公钥，保密的那个叫私钥。两个密码合称一个密钥对。

\end{insertnote}

那么非对称加密如何避免中间人攻击的？

假设A和B都生成了密钥对，并相互交换了对方的公钥。

现在，A将发出的每一个信息都用B的公钥加密。B同样是通过C的转发获得的A的信息。那么，这个信息因为是用B的公钥加密的，所以只能使用B的私钥解开。这样B的能100\%确定这份信息在传输的过程中没有被第三者窃取。
连A都不能从加密后的内容中获得原始内容。但是因为B的公钥是公开的，任何人都能获得B的公钥，所以B只能确定信息没泄漏，不能确定是A所发送的。

那么，A再次发送一个信息，使用自己的私钥进行加密。B同样是通过C的转发获得的A的信息。B使用A的公钥就能解密信息。那么对B来说，它能100\%确定是A发送的信息。因为只有A才有那个密钥。这种加密就是数字签名，这是比手写签名还难伪造的签名哦！

那么，把二者结合起来，A首先用自己的私钥将信息加密，然后再用B的公钥加密。再发送给B。这样A能确保只有B能看的到这个信息。B能确信这个信息是由A所发送。

那么接下来遇到一个棘手的问题了：B如何确定自己拿的那个公钥是A的公钥？如果A和B能面对面的交流，那没问题。见面的时候交换一下公钥即可。事实上内部使用SSL的都是这么做的。不过如果放到公网上，问题就没那么简单了。
比如访问Linux内核的官方网站\footnote{\url{https://www.kernel.org/} }，难道你飞机飞到美国，向Linux内核基金会主席索要公钥了么？
显然这个时候公钥需要通过网络分发。通常是在第一次访问其网站的时候下载其证书\footnote{SSL下，公钥称为SSL证书，稍后解释。}。显然下载证书的过程还无法避免中间人攻击。%——必须对下载到的证书进行认证！

SSL的证书就是一个包含了公钥的文件。除了可以包含公钥，它还可以包含多个签名——由其他证书将它的公钥加密生成的签名。签名有什么用呢？假设A和B私下是个好朋友，相互通过见面的形式交换了公钥。
这个时候B的一个好朋友C向A发送了一条信息。C声称自己是B的好朋友。A能信么？典型的情况下，A必须询问B才能确定。如果B事先用自己的私钥签署了一份文件，证明C的身份，那么A即可相信C的身份了。

SSL证书也是这个道理，一个证书可以为另一个证书签名，表明它认可这个证书所有者的身份\footnote{信任其身份和信任其本身是两码事。}。 

TODO SSL证书的链式签名。 %TODO

从图中可以看出，只要预先向每个系统植入一个根证书（Root CA），再由根证书持有者颁布证书给其他网站，即（希望）可解决中间人攻击了。注意，SSL只解决了身份信任问题，并不代码使用SSL连接的对方是受信任度。SSL证书是网站在互联网上的身份证，至于是否信任该网站，就看访问者自己了(笑)。根证书随操作系统附带，事实上系统安装的根证书不止一个。可以打开任意浏览器查看。以火狐为例

TODO 查看安装的根证书 %TODO

如果根证书本身不可信任呢？比如向错误的网站颁布证书，证明它是你信任的网站，再配合 DNS 污染这样的招数，完全可以在神不知鬼不觉中执行欺诈。所以通常浏览器都可以选择不信任某个证书。

TODO 举例，不信任CNNIC证书

通常网站是公开接受浏览的，所以并不检查用户的证书。浏览器简单的使用空证书即可浏览HTTPS加密的网站。
某些情况下，网站也要验证用户的身份，比如银行，这个时候用户也得使用证书了。相比将证书（私钥部分，公钥保存在银行数据里）保存在硬盘上被恶意程序偷窥（比如QQ，参考QQ和360的战斗。），
银行通常要求用户将证书保存在一个外置设备中——俗称U盾。
事实上将私钥保存在外部设备，有一个标准协议，PKCS\#11，只不过国内漠视国际标准\footnote{似乎觉得标准=公开=不安全。}，导致必须安装银行自己开发的浏览器插件才能使用网银，
对Linux用户来说真是可悲的事情——通常银行只开发IE使用的插件。
